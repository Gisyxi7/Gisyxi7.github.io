<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nju cs">
<meta property="og:type" content="website">
<meta property="og:title" content="Gisyxi7&#39;s blogs">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Gisyxi7&#39;s blogs">
<meta property="og:description" content="nju cs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gisyxi7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Gisyxi7's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Gisyxi7's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学不动了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/11/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/" class="post-title-link" itemprop="url">上下文无关文法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-11 18:06:39 / 修改时间：19:24:50" itemprop="dateCreated datePublished" datetime="2024-12-11T18:06:39+08:00">2024-12-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h1><p>正则语言的表达能力存在局限性，比如正则语言并不能表达回文串。现在我们介绍一种表达能力更强的语言，上下文无关文法。</p>
<h2 id="直观描述"><a href="#直观描述" class="headerlink" title="直观描述"></a>直观描述</h2><p><strong>上下文无关文法(context-free grammar)</strong>是一种描述语言的记号，对于描述嵌套结构是很有用的。</p>
<h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>定义<strong>上下文无关文法(context-free grammar,CFG)</strong>是一个四元组$G=(V,T,P,S)$:</p>
<ul>
<li>$T$为CFG要定义语言的字母表，称为<strong>终结符(Terminals)</strong>。</li>
<li>$V$为一个有限的其他符号的集合，每个符号代表了一个语言，称为<strong>变量(Variables)</strong>或者<strong>非终结符(Nonterminals)</strong>。</li>
<li>$S$为CFG要定义的语言变量，称为<strong>起始符号(Start Symbol)</strong>。</li>
<li>$P$为CFG的<strong>产生式(productions)</strong>集合，形如$head\rightarrow body$。<ul>
<li><strong>头(header)</strong>是一个变量</li>
<li><strong>体(body)</strong>是变量和终结符组成的字符串，可以是空串</li>
</ul>
</li>
</ul>
<p>一般来说，我们在字母使用下有以下约定</p>
<ul>
<li>用$A,B,C\cdots,S$表示变量</li>
<li>用$a,b,c\cdots$表示终结符</li>
<li>用$\cdots,X,Y,Z$表示非终结符或变量</li>
<li>用$w,x,y,z$表示只含有终结符的字符串</li>
<li>用$\alpha,\beta,\gamma,\cdots$来表示有终结符或变量的字符串</li>
</ul>
<p>根据上述定义，想要定义一个语言$\{0^n1^n|n\ge 1\}$:</p>
<script type="math/tex; mode=display">G=(\{S\},\{0,1\},\{S\rightarrow 01,S\rightarrow 0S1\},S)</script><p>定义：</p>
<p>称$\alpha A\beta$可以<strong>推导</strong>出$\alpha \gamma \beta$，记为$\alpha A\beta\Rightarrow \alpha \gamma \beta$。如果$A\rightarrow \gamma$是一个产生式。</p>
<p>称零步或多步推导为<strong>迭代推导</strong>，记为$\Rightarrow^*$</p>
<p>令$G$是一个上下文无关文法，则记$G$的语言为$L(G)$，称上下文无关文法定义的语言为<strong>上下文无关语言(Context-Free Language, CFL)</strong>。</p>
<h2 id="最左推导和最右推导"><a href="#最左推导和最右推导" class="headerlink" title="最左推导和最右推导"></a>最左推导和最右推导</h2><p>每一次推导我们都可以替换一个任意位置的变量，但是这个任意会带来很多的不确定性，为了避免不确定性，我们规定每次替换的变量为一个固定位置（最左或最右）的变量。</p>
<p>我们使用$\Rightarrow_l$表示最左推导，$\Rightarrow_r$ 表示最右推导。</p>
<h1 id="解析树"><a href="#解析树" class="headerlink" title="解析树"></a>解析树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>解析树(Parse Tree)</strong>是一棵用某个特定的上下文无关文法中的符号对每个结点做标记的树。如图所示：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/1.png?raw=true" alt="1"></p>
<h2 id="解析树，最左推导，最右推导"><a href="#解析树，最左推导，最右推导" class="headerlink" title="解析树，最左推导，最右推导"></a>解析树，最左推导，最右推导</h2><p>解析树、最左推导和最右推导是可以相互转化的，它们的表达能力是等价的。</p>
<p>由归纳法可以轻松证明。</p>
<h2 id="文法歧义"><a href="#文法歧义" class="headerlink" title="文法歧义"></a>文法歧义</h2><p>我们称一个文法是<strong>有歧义的(ambiguous)</strong>，如果在这个文法定义的语言中，存在一个字符串可以被两个及以上个解析树产出。</p>
<p>如果这个字符串存在多个对应的解析树，那么就意味着存在多种推导方式。</p>
<p>当然，也存在文法，在这个文法定义的语言中，所有的字符串都只有唯一的解析树，我们称之为<strong>LL(1)文法</strong>。</p>
<p>一般来说，LL(1)文法具有以下的特征：从左往右扫描字符串，且只看下一个符号。</p>
<h2 id="固有歧义"><a href="#固有歧义" class="headerlink" title="固有歧义"></a>固有歧义</h2><p>有的有歧义的文法可以修改成没有歧义的文法，但是存在一些上下文无关语言本身是具有<strong>固有的歧义性(inherently ambiguous)</strong>的，意思是这个语言的所有的文法都是有歧义的。</p>
<h1 id="上下文无关文法的范式"><a href="#上下文无关文法的范式" class="headerlink" title="上下文无关文法的范式"></a>上下文无关文法的范式</h1><h2 id="去除无用变量"><a href="#去除无用变量" class="headerlink" title="去除无用变量"></a>去除无用变量</h2><ul>
<li>无法推导的变量：无法推导出任何终结字符串。</li>
<li>不可达的符号：有一些变量或者终结符无论如何从起始符号推导都不会出现。</li>
</ul>
<p>以上的符号我们称为<strong>无用符号(unused symbols)</strong>。我们通过以下方法去除无用符号：</p>
<ol>
<li>删除不能导出终结字符串的符号</li>
<li>删除所有从起始符号不可达的字符串</li>
</ol>
<p><strong>这个顺序不能颠倒！！！</strong></p>
<h2 id="去除空串"><a href="#去除空串" class="headerlink" title="去除空串"></a>去除空串</h2><p>我们需要考虑不含$\epsilon$的语言，所以我们需要一个算法能够去除空串：</p>
<ul>
<li>找到所有空产生式：递归的找出所有能推导出空串的符号</li>
<li>去除空产生式：<ul>
<li>对于每一个产生式，如果产生式右边存在能推导出空串的符号，则每一个由可空的符号组成的子集，存在一个产生式，是将右边产生式的某个为空部分去掉得到的。</li>
<li>最后去掉所有的空产生式</li>
</ul>
</li>
</ul>
<h2 id="去除单元产生式"><a href="#去除单元产生式" class="headerlink" title="去除单元产生式"></a>去除单元产生式</h2><p><strong>单元产生式(unit production)</strong>指的是体只有一个变量的产生式。这些产生式也是可以去除的。</p>
<p>算法如下：</p>
<ul>
<li>发现单元产生式：归纳的找到所有有序对$(A,B)$使$A\Rightarrow^* B$为单元产生式<ul>
<li>基础情况：$(A,A)一定是满足要求的有序对</li>
<li>如果已经发现了$(A,B)$，且$B\rightarrow C$是一个单元产生式，则$(B,C)$也一定满足要求。</li>
</ul>
</li>
<li>去除单元产生式：一系列的单元产生式加上一个非单元产生式形成的推导在新文法中可以塌缩折叠成一个产生式。</li>
</ul>
<h2 id="乔姆斯基范式"><a href="#乔姆斯基范式" class="headerlink" title="乔姆斯基范式"></a>乔姆斯基范式</h2><p>如果$L$是一个上下文无关语言，那么对于$L-\{\epsilon\}$一定存在一个上下文无关文法：</p>
<ul>
<li>没有无用符号</li>
<li>没有$\epsilon-$产生式</li>
<li>没有单元产生式</li>
</ul>
<p>要找到这样的文法，一定<strong>遵循以下顺序操作</strong>：</p>
<ol>
<li>去除$\epsilon-$产生式</li>
<li>去除单元产生式</li>
<li>去除无用符号<ol>
<li>去除无法推导出终结字符串的变量</li>
<li>去除从起始符号不可达的变量</li>
</ol>
</li>
</ol>
<p>定义<strong>乔姆斯基范式(Chomsky Normal Form, CNF)</strong>：</p>
<p>称一个上下文无关文法符合 乔姆斯基范式(Chomsky Normal Form, CNF) ，如果每个产生式都满足下面两种形式的其中一种：</p>
<ol>
<li>$A\rightarrow BC$</li>
<li>$A\rightarrow a$，其中$a$是终结符。</li>
</ol>
<p>下面介绍一个算法将一个上下文无关文法修改成符合乔姆斯基范式。</p>
<ol>
<li>清理文法：去除无用符号，去除空产生式，去除单元产生式。</li>
<li>对于所有不是单个终结符的体，让右侧变成全部是变量的形式。</li>
<li>将体长度超过2的产生式分解成若干个体长度等于2的产生式</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/FLA%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/FLA%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">FLA复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-09 22:06:54" itemprop="dateCreated datePublished" datetime="2024-12-09T22:06:54+08:00">2024-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-11 18:27:35" itemprop="dateModified" datetime="2024-12-11T18:27:35+08:00">2024-12-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h1 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h1><h2 id="确定性有穷自动机"><a href="#确定性有穷自动机" class="headerlink" title="确定性有穷自动机"></a>确定性有穷自动机</h2><p>五元组$(Q, \Sigma, \delta, q_0, F)$</p>
<ul>
<li>$Q$ 是一个有限状态集合</li>
<li>$\Sigma$ 是一个输入字母表</li>
<li>$\delta$ 是一个状态转换函数，它将一个状态和输入符号映射到下一个状态</li>
<li>$q_0$ 是初始状态，$q_0\in Q$</li>
<li>$F$ 是一个终止状态集合，$F\subseteq Q$</li>
</ul>
<p>$\delta$是一个全函数，对于一个状态$q$和输入符号$a$，$\delta(q,a)$一定有对应的转移，如果没有，我们额外定义一个<strong>死状态</strong>。</p>
<p>对于一个自动机来说，它的语言是从初始状态走到终止状态的所有路径的标签字符串的集合。</p>
<h2 id="判断DFA的语言和一个自然描述的语言集合"><a href="#判断DFA的语言和一个自然描述的语言集合" class="headerlink" title="判断DFA的语言和一个自然描述的语言集合"></a>判断DFA的语言和一个自然描述的语言集合</h2><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/FLA%E5%A4%8D%E4%B9%A0/1.png?raw=true" alt="1"></p>
<p>先证$S\subseteq T$，使用归纳假设：</p>
<ul>
<li>如果$\delta(A,\omega)=A$，那么$\omega$没有连续的两个$1$并且不以$1$结尾</li>
<li>如果$\delta(A,\omega)=B$，那么$\omega$没有连续的两个$1$并且以单个$1$结尾</li>
</ul>
<p>再证$T\subseteq S$，使用反证法：</p>
<ul>
<li>假设$\omega\in T$没有被DFA接受</li>
</ul>
<h2 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h2><ul>
<li>证明一个语言不是正则语言（不使用泵引理）：反证法找矛盾</li>
</ul>
<h1 id="非确定性有穷自动机"><a href="#非确定性有穷自动机" class="headerlink" title="非确定性有穷自动机"></a>非确定性有穷自动机</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>五元组$(Q, \Sigma, \delta, q_0, F)$</p>
<ul>
<li>$Q$ 是一个有限状态集合</li>
<li>$\Sigma$ 是一个输入字母表</li>
<li>$\delta$ 是一个状态转换函数，它将一个状态和输入符号映射到下一个状态<strong>集合</strong></li>
<li>$q_0$ 是初始状态，$q_0\in Q$</li>
<li>$F$ 是一个终止状态集合，$F\subseteq Q$</li>
</ul>
<h2 id="NFA和DFA的等价性"><a href="#NFA和DFA的等价性" class="headerlink" title="NFA和DFA的等价性"></a>NFA和DFA的等价性</h2><ul>
<li>DFA-&gt;NFA 显而易见</li>
<li>NFA-&gt;DFA <strong>子集构造法</strong></li>
</ul>
<h1 id="带空转移的NFA"><a href="#带空转移的NFA" class="headerlink" title="带空转移的NFA"></a>带空转移的NFA</h1><p>在NFA的基础上再允许某个状态在没有输入字符的时候就转移到另一个状态，即接受$\epsilon$输入。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>引入<strong>状态闭包</strong>的概念，即可以通过任意个空转移到达的状态集合。</p>
<h2 id="NFA和-epsilon-NFA的等价性"><a href="#NFA和-epsilon-NFA的等价性" class="headerlink" title="NFA和$\epsilon$-NFA的等价性"></a>NFA和$\epsilon$-NFA的等价性</h2><ul>
<li>NFA-&gt;$\epsilon$-NFA 显而易见</li>
<li>$\epsilon$-NFA-&gt;NFA 先取闭包，后转移，最后再次取闭包</li>
</ul>
<h1 id="有穷自动机总结"><a href="#有穷自动机总结" class="headerlink" title="有穷自动机总结"></a>有穷自动机总结</h1><p>DFA，NFA和$\epsilon$-NFA是等价的，都只表示正则语言。<br>只有DFA能被真正实现。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><strong>并(union)</strong>：就是集合的并操作</li>
<li><strong>拼接(concatenation)</strong>：LM</li>
<li><strong>星闭包(Kleene closure)</strong>：L*</li>
</ul>
<h2 id="正则表达式与有穷自动机的等价性"><a href="#正则表达式与有穷自动机的等价性" class="headerlink" title="正则表达式与有穷自动机的等价性"></a>正则表达式与有穷自动机的等价性</h2><h3 id="正则表达式转换为-epsilon-NFA"><a href="#正则表达式转换为-epsilon-NFA" class="headerlink" title="正则表达式转换为$\epsilon$-NFA"></a>正则表达式转换为$\epsilon$-NFA</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.png?raw=true" alt="1"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.png?raw=true" alt="2"></p>
<h3 id="DFA转换为正则表达式"><a href="#DFA转换为正则表达式" class="headerlink" title="DFA转换为正则表达式"></a>DFA转换为正则表达式</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.png?raw=true" alt="3"></p>
<h2 id="正则表达式的代数运算法则"><a href="#正则表达式的代数运算法则" class="headerlink" title="正则表达式的代数运算法则"></a>正则表达式的代数运算法则</h2><ul>
<li>$R+\emptyset=R$</li>
<li>$R\emptyset=\emptyset R=\emptyset$</li>
<li>$\epsilon R=R\epsilon =R$</li>
<li>$(\epsilon+R)<em>=R</em>$</li>
<li>$R+SR=(\epsilon+S)R$</li>
<li>$\epsilon+RR<em>=R</em>$</li>
<li>$(R+S)<em>=(R</em>S)<em>R</em>$</li>
</ul>
<h1 id="正则表达式的判定性质"><a href="#正则表达式的判定性质" class="headerlink" title="正则表达式的判定性质"></a>正则表达式的判定性质</h1><ul>
<li>成员资格问题：模拟运行</li>
<li>空问题：是否有一个终止状态可达</li>
<li>无限性问题：是否有环</li>
<li>等价性：构造乘积DFA</li>
<li>包含关系：构造乘积DFA</li>
</ul>
<h2 id="泵引理："><a href="#泵引理：" class="headerlink" title="泵引理："></a>泵引理：</h2><p>对于一个正则语言$L$来说，存在一个整数$n$，使得对于$L$中的每一个长度大于等于$n$的字符串$w$，都可以写作$w=wxy$，满足：</p>
<ol>
<li>$|xy|\leq n$</li>
<li>$|y| &gt;0$</li>
<li>$\forall i \ge 0,xy^iz\in L$<br>判断一个语言不是正则表达式时使用泵引理，还可以利用正则语言的闭包性说明不是。还可以<strong>构造DFA</strong>来说明是正则语言。</li>
</ol>
<h2 id="正则语言的最小状态DFA"><a href="#正则语言的最小状态DFA" class="headerlink" title="正则语言的最小状态DFA"></a>正则语言的最小状态DFA</h2><p><strong>状态最小化(efficient state minimization)</strong> 操作。</p>
<p>这是一个递归算法：<br>基础情况：标记所有的只有一个终止状态的对，即区分字符串长度为0。<br>递归情况：如果对于某个输入符号$a$，$[\delta(q,a),\delta(r,a)]$被标记了，那么标记$[q,r]$。在没有更多的对可以被标记的时候，剩下的没有标记的对就是等价的了，并且可以合并成一个状态。</p>
<h1 id="正则语言的闭包性质"><a href="#正则语言的闭包性质" class="headerlink" title="正则语言的闭包性质"></a>正则语言的闭包性质</h1><ul>
<li>并操作、拼接操作以及星闭包操作下的闭包</li>
<li>交集、差集、补集下的闭包</li>
<li>逆运算下的闭包</li>
<li>同态运算下的闭包</li>
<li>逆同态运算下的闭包</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">迁移系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-09 14:08:40 / 修改时间：23:33:24" itemprop="dateCreated datePublished" datetime="2024-12-09T14:08:40+08:00">2024-12-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>迁移系统</strong>(transition system, TS) 是一个反应式的系统，直觉上它由一个所有可能状态的集合以及一些迁移(transition)——或者说状态转换(state change)——的集合组成。</p>
<p>我们可以用有向图来表示一个迁移系统，图中的结点表示状态，边表示迁移行为。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迁移系统是一个五元组$(S,S_0,T,\alpha,\beta)$:</p>
<ul>
<li>$S$ 是一个有限或无限的状态集合</li>
<li>$S_0$ 是一个初始状态集合，$S_0 \subseteq S$</li>
<li>$T$ 是一个迁移集合，$T \subseteq S \times S$</li>
<li>$\alpha$和$\beta$是两个从$T$到$S$的映射，对于任意的$t\in T$，有$\alpha(t)$表示迁移的<strong>源状态</strong>和$\beta(t)$表示迁移的<strong>目标状态</strong>。</li>
</ul>
<p>若$S$和$T$是有限的，则整个迁移系统也是有限的。</p>
<p>定义一个迁移系统$\mathcal{A}$的路径是一个迁移的序列$t_1,t_2,\dots,t_n$。</p>
<p>如果一个状态可以由初始状态经过一条路径达到，则称这个状态是<strong>可达</strong>的。<br>如果一个状态不可以到达任何其他状态，则称这个状态是<strong>终结状态</strong>。<br>如果一个状态是可达的同时又是一个终结状态，则称这个状态是<strong>死锁状态</strong>。</p>
<p>当然，这里$\alpha$和$\beta$的定义可以拓展到对一个路径取源和目标。</p>
<h2 id="带标签的迁移系统"><a href="#带标签的迁移系统" class="headerlink" title="带标签的迁移系统"></a>带标签的迁移系统</h2><p>一个被字母表$A$标记的，带标签的迁移系统(labeled transition system) 是一个 6 元组$\mathcal{A} = (S,S_0,T,\alpha,\beta,\lambda)$:</p>
<ul>
<li>前五元组是一个迁移系统</li>
<li>$\lambda$是一个从$T$到$A$的映射，对于任意的$t\in T$，有$\lambda(t)$表示迁移的<strong>标签</strong>。</li>
</ul>
<p>直觉上，一个迁移的标签意味着触发这个迁移的行为或者事件。</p>
<p>定义一条如果$c=t_1,t_2,\cdots$是一条路径，那么触发这些迁移的行为的序列$trace(c)=\lambda(t_1),\lambda(t_2),\cdots$被称为这个路径的<strong>踪迹</strong>。</p>
<h1 id="迁移系统的等价性"><a href="#迁移系统的等价性" class="headerlink" title="迁移系统的等价性"></a>迁移系统的等价性</h1><p>想要证明两个建模语言是等价的，我们可以用迁移系统来刻画它们的行为，然后通过证明迁移系统的等价性来证明建模语言行为的等价性。</p>
<h2 id="强同构等价"><a href="#强同构等价" class="headerlink" title="强同构等价"></a>强同构等价</h2><p>唯一的区别就只能是状态和迁移的命名不同</p>
<h2 id="弱同构等价"><a href="#弱同构等价" class="headerlink" title="弱同构等价"></a>弱同构等价</h2><p>如果这两个可达子迁移系统是同构的，我们称原来的两个迁移系统是 弱同构(weak isomorphic) 的。</p>
<h2 id="双模拟等价"><a href="#双模拟等价" class="headerlink" title="双模拟等价"></a>双模拟等价</h2><p>迁移系统具有相同的行为，并在同一时刻做选择。</p>
<h1 id="迁移系统的运算"><a href="#迁移系统的运算" class="headerlink" title="迁移系统的运算"></a>迁移系统的运算</h1><h2 id="自由积"><a href="#自由积" class="headerlink" title="自由积"></a>自由积</h2><p>将多个迁移系统的定义做一个笛卡尔积。</p>
<p>直观上理解，各个子系统的定义不变，加入了时钟来统一驱动多个系统。使之走相同的步数。</p>
<h2 id="同步积"><a href="#同步积" class="headerlink" title="同步积"></a>同步积</h2><p>当进程之间进行交互的时候，并不是所有可能的全局行为都是有用的，因为这些交互会受到进程通信和同步的限制。</p>
<p>因此，描述多进程系统的迁移系统一定是各个进程对应的各自迁移系统的自由积的一个子系统，我们可以用同步积来表达这种受到通信和同步约束的全局系统。</p>
<p>本质上就是加入了一个集合来判断自由积中哪些迁移是被允许的。换句话说，同步积只允许标签向量在同步约束中的全局迁移发生。</p>
<h2 id="tau-迁移和共享标签"><a href="#tau-迁移和共享标签" class="headerlink" title="$\tau $迁移和共享标签"></a>$\tau $迁移和共享标签</h2><p>自由积有时钟的限制，要求所有子迁移系统必须同进退，要想消除这个限制，只需要每个状态引入一个自环转移($\tau$ transition)就行了。</p>
<p>我们也可以使用共享标签来表示两个迁移必须同时发生，这样在表达上面会更加简洁。不过这并没有拓展同步积的表达能力就是了，只是换了一种更简便的表达方式而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-09 13:21:51" itemprop="dateCreated datePublished" datetime="2024-12-09T13:21:51+08:00">2024-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-10 16:18:06" itemprop="dateModified" datetime="2024-12-10T16:18:06+08:00">2024-12-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>正则表达式(regular expression, RE) 通过代数式的方式来描述语言。</p>
<p>如果$E$是一个正则表达式，记它定义的语言为$L(E)$。</p>
<p>首先回顾一下语言的操作：</p>
<ul>
<li><strong>并(union)</strong>：就是集合的并操作</li>
<li><strong>拼接(concatenation)</strong>：LM</li>
<li><strong>星闭包(Kleene closure)</strong>：L*</li>
</ul>
<p><strong>定义</strong>：<br>递归地定义正则表达式如下：<br>基础情况：</p>
<ol>
<li>一个符号是正则表达式</li>
<li>$\epsilon$是正则表达式</li>
<li>$\emptyset$是正则表达式<br>递归情况：</li>
<li>两个正则表达式的并是正则表达式，$E_1+E_2$</li>
<li>两个正则表达式的拼接是正则表达式，$E_1E_2$</li>
<li>一个正则表达式的星闭包是正则表达式，$E*$</li>
</ol>
<h2 id="操作符号优先级"><a href="#操作符号优先级" class="headerlink" title="操作符号优先级"></a>操作符号优先级</h2><p>星闭包&gt;拼接&gt;并 </p>
<h2 id="正则表达式和有穷自动机的等价性"><a href="#正则表达式和有穷自动机的等价性" class="headerlink" title="正则表达式和有穷自动机的等价性"></a>正则表达式和有穷自动机的等价性</h2><h3 id="将正则表达式转换成-epsilon-NFA"><a href="#将正则表达式转换成-epsilon-NFA" class="headerlink" title="将正则表达式转换成$\epsilon$-NFA"></a>将正则表达式转换成$\epsilon$-NFA</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.png?raw=true" alt="1"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.png?raw=true" alt="2"></p>
<h3 id="将DFA转化为正则表达式"><a href="#将DFA转化为正则表达式" class="headerlink" title="将DFA转化为正则表达式"></a>将DFA转化为正则表达式</h3><p>定义<strong>k-路径</strong>：<br>k-路径指的是DFA状态转换图上的某一条路径，其中，这条路径经过的所有状态的标号不超过k。</p>
<p>令$R^{k}_{ij}$表示从状态$i$走到状态$j$的k路径。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.png?raw=true" alt="3"></p>
<h2 id="正则表达式的代数运算法则"><a href="#正则表达式的代数运算法则" class="headerlink" title="正则表达式的代数运算法则"></a>正则表达式的代数运算法则</h2><ul>
<li>$R+\emptyset=R$</li>
<li>$R\emptyset=\emptyset R=\emptyset$</li>
<li>$\epsilon R=R\epsilon =R$</li>
<li>$(\epsilon+R)<em>=R</em>$</li>
<li>$R+SR=(\epsilon+S)R$</li>
<li>$\epsilon+RR<em>=R</em>$</li>
<li>$(R+S)<em>=(R</em>S)<em>R</em>$</li>
</ul>
<h1 id="正则语言的判定性质"><a href="#正则语言的判定性质" class="headerlink" title="正则语言的判定性质"></a>正则语言的判定性质</h1><p>语言类有两类重要的性质：</p>
<ul>
<li>判定性质<br>一类语言的<strong>判定性质(decision property)</strong>对应于一个算法，这个算法以某个语言的形式化描述(比如说一个DFA)为输入，然后告诉我们这个语言是否满足某些性质（比如说这个语言是否为空之类的）。语言的表示可以是形式化(formal)的（比如说RE，FA等等），也可以是非形式化(informal)的（比如说自然语言描述，集合描述等等）。</li>
<li>闭包性质<br>一类语言的<strong>闭包性质(closure property)</strong>说的是给定这个语言类的一些语言，对于这些语言进行某个操作得到的另一个语言依旧在同一个语言类中。</li>
</ul>
<p>下面讨论一些常见的判定性质。</p>
<h2 id="成员资格问题"><a href="#成员资格问题" class="headerlink" title="成员资格问题"></a>成员资格问题</h2><p>一个给定字符串是否属于一个给定正则语言。</p>
<p>转换成DFA模拟运行即可。</p>
<h2 id="空问题"><a href="#空问题" class="headerlink" title="空问题"></a>空问题</h2><p>判断一个给定的正则语言是否为空。</p>
<p>假设语言的表示为DFA，从初始状态开始，计算所有的可达状态的集合，如果至少有一个终止状态可达，那么这个语言就非空，否则为空。</p>
<h2 id="无限性问题"><a href="#无限性问题" class="headerlink" title="无限性问题"></a>无限性问题</h2><p>判断一个给定的正则语言的语言集合是否为无限大。</p>
<p>只要找DFA是否出现环。</p>
<h2 id="泵引理"><a href="#泵引理" class="headerlink" title="泵引理"></a>泵引理</h2><p>判断某个语言是不是正则语言。</p>
<p>使用<strong>泵引理</strong>：<br>对于一个正则语言$L$来说，存在一个整数$n$，使得对于$L$中的每一个长度大于等于$n$的字符串$w$，都可以写作$w=wxy$，满足：</p>
<ol>
<li>$|xy|\leq n$</li>
<li>$|y| &gt;0$</li>
<li>$\forall i \ge 0,xy^iz\in L$</li>
</ol>
<p>泵引理被用来判断一个语言不是正则语言。而不是用来判断是正则语言。</p>
<h2 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h2><p>判断两个正则语言是否等价。</p>
<p>构造<strong>乘积DFA</strong>：</p>
<ul>
<li>状态集：$Q\times R$</li>
<li>初始状态：$[q_0,r_0]$</li>
<li>转移函数：$\delta([q,r],a)=[\delta_L(q,a),\delta_R(r,a)]$</li>
<li><strong>终止状态</strong>：$[q,r]$，其中只有一个是原来DFA的终止状态。</li>
</ul>
<p>如果这个自动机是接受的语言是空集，则说明两个正则语言等价。</p>
<h2 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h2><p>判断两个正则语言是否包含。</p>
<p>仍然构造乘积DFA，但是终止状态定义为$[q,r]$，其中$q$是原来DFA的终止状态，而$r$不是$M$的终止状态。</p>
<p>这样乘积DFA是空集等价于$L\subseteq M$</p>
<h2 id="一个正则语言的最小状态DFA"><a href="#一个正则语言的最小状态DFA" class="headerlink" title="一个正则语言的最小状态DFA"></a>一个正则语言的最小状态DFA</h2><p>现在考虑如何将一个DFA找到其等价的最小状态DFA。下面我们介绍一种高效的 <strong>状态最小化(efficient state minimization)</strong> 操作。</p>
<p>这是一个递归算法：<br>基础情况：标记所有的只有一个终止状态的对，即区分字符串长度为0。<br>递归情况：如果对于某个输入符号$a$，$[\delta(q,a),\delta(r,a)]$被标记了，那么标记$[q,r]$。在没有更多的对可以被标记的时候，剩下的没有标记的对就是等价的了，并且可以合并成一个状态。</p>
<h1 id="正则语言的闭包性质"><a href="#正则语言的闭包性质" class="headerlink" title="正则语言的闭包性质"></a>正则语言的闭包性质</h1><h2 id="并操作、拼接操作以及星闭包操作下的闭包"><a href="#并操作、拼接操作以及星闭包操作下的闭包" class="headerlink" title="并操作、拼接操作以及星闭包操作下的闭包"></a>并操作、拼接操作以及星闭包操作下的闭包</h2><p>如果$L$和$M$是正则语言，那么$L\cup M$，$LM$，$L*$都是正则语言。</p>
<h2 id="交集、差集、补集下的闭包"><a href="#交集、差集、补集下的闭包" class="headerlink" title="交集、差集、补集下的闭包"></a>交集、差集、补集下的闭包</h2><ul>
<li>交集<br>  在交集下闭包，构造一个乘积DFA，令终止状态是两个共同的终止状态。</li>
<li>差集<br>  在差集下闭包，构造一个乘积DFA，终止状态是包含A的但不包含B的终止状态的状态对。</li>
<li>补集<br>  在补集下闭包。</li>
</ul>
<h2 id="逆运算下的闭包"><a href="#逆运算下的闭包" class="headerlink" title="逆运算下的闭包"></a>逆运算下的闭包</h2><p>递归的进行逆操作即可。</p>
<h2 id="同态运算和逆同态运算下的闭包"><a href="#同态运算和逆同态运算下的闭包" class="headerlink" title="同态运算和逆同态运算下的闭包"></a>同态运算和逆同态运算下的闭包</h2><p>对于一个字母表的<strong>同态(homomorphism)</strong>指的是一个函数，这个函数对于字母表中的每一个字符给出了一个字符串。</p>
<p>正则语言在同态和逆同态下是闭包的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">有穷自动机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-09 11:19:04" itemprop="dateCreated datePublished" datetime="2024-12-09T11:19:04+08:00">2024-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-10 11:19:24" itemprop="dateModified" datetime="2024-12-10T11:19:24+08:00">2024-12-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是有穷自动机"><a href="#什么是有穷自动机" class="headerlink" title="什么是有穷自动机"></a>什么是有穷自动机</h2><p>有穷自动机(finite automa) 是一个形式系统，它只记忆有限量的信息，这些信息通过它的 状态(states) 表示。当有 <strong>输入</strong>(input) 给到有穷自动机的时候，它会相应地改变自己的状态。告诉有穷自动机该如何根据输入改变自身状态的规则称为 <strong>转移</strong>(transition) 。</p>
<h2 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h2><p>双环表示 <strong>终止状态</strong>(final state) ，给定一系列的输入，称为 <strong>输入字符串</strong>(input string) ，从初始状态开始，根据每个输入符号转移到下一状态。如果读入一个特定的字符串能够让状态从初始状态变为终止状态，我们称这个输入被 <strong>接受</strong>(accepted) 了。</p>
<h2 id="一个自动机的语言"><a href="#一个自动机的语言" class="headerlink" title="一个自动机的语言"></a>一个自动机的语言</h2><p>称能够被一个自动机 A 接受的字符串的集合为 A 的 <strong>语言</strong>(language) ，记为 L(A) 。</p>
<h1 id="确定性有穷自动机"><a href="#确定性有穷自动机" class="headerlink" title="确定性有穷自动机"></a>确定性有穷自动机</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>确定性有穷自动机</strong>(Deterministic Finite Automa, DFA) 是一种定义语言的形式化系统，记为五元组$(Q, \Sigma, \delta, q_0, F)$</p>
<ul>
<li>$Q$ 是一个有限状态集合</li>
<li>$\Sigma$ 是一个输入字母表</li>
<li>$\delta$ 是一个状态转换函数，它将一个状态和输入符号映射到下一个状态</li>
<li>$q_0$ 是初始状态，$q_0\in Q$</li>
<li>$F$ 是一个终止状态集合，$F\subseteq Q$</li>
</ul>
<p>注意这里$\delta$是一个全函数，对于一个状态$q$和输入符号$a$，$\delta(q,a)$一定有对应的转移，如果没有，我们额外定义一个<strong>死状态</strong>。</p>
<h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><h3 id="图表示"><a href="#图表示" class="headerlink" title="图表示"></a>图表示</h3><p>用状态转移图表示DFA。</p>
<ul>
<li>用 结点(node) 表示状态</li>
<li>用 弧(arc) 表示转移函数</li>
<li>用标有 Start 的箭头指向起始状态</li>
<li>用 双圆(double circle) 表示终止状态</li>
</ul>
<h3 id="转移表"><a href="#转移表" class="headerlink" title="转移表"></a>转移表</h3><ul>
<li>行头表示状态，列头表示输入符号</li>
<li>用箭头指向初始状态，用星号标注终止状态</li>
<li>每一个表象都是转移函数的结果</li>
</ul>
<h2 id="扩展的转移函数"><a href="#扩展的转移函数" class="headerlink" title="扩展的转移函数"></a>扩展的转移函数</h2><p>之前定义的转移函数只对应一个状态面对<strong>单个</strong>字符输入的转移，现在扩展到对一个输入字符串的转移。</p>
<p>递归定义拓展的转移函数：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/1.png?raw=true" alt="1"></p>
<h2 id="DFA的语言"><a href="#DFA的语言" class="headerlink" title="DFA的语言"></a>DFA的语言</h2><p>定义对于一个DFA $A$，定义$A$能接受的语言集合为$L(A)$，记为$L(A)=\{w|\delta(q_0,w)\in F\}$。</p>
<p>PS: 证明一个语言集合等价于一个DFA定义的语言集合，需要证明两个集合互相包含。</p>
<h2 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h2><p>如果一个语言集合$L$可以被某个DFA<strong>恰好</strong>接受，那么我们称这个语言集合为<strong>正则语言</strong>(regular language)。</p>
<h1 id="非确定性有穷自动机"><a href="#非确定性有穷自动机" class="headerlink" title="非确定性有穷自动机"></a>非确定性有穷自动机</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>非确定性有穷自动机(Nondeterministic Finite Automaton, NFA) 可以同一时刻处在多个状态中。当有一个输入符号的时候，可以从一个状态转移到任意状态的集合。</p>
<p>直观上，NFA虽然转移函数给出了多个目标状态，但是一个输入字符串对于一个NFA总能找到自己正确的转移路径到终止状态（如果能被接受的话）。</p>
<p>定义为五元组，与DFA的区别是转移函数不是返回一个单独的状态，而是一个状态<strong>集合</strong>。</p>
<h2 id="DFA与NFA的等价性"><a href="#DFA与NFA的等价性" class="headerlink" title="DFA与NFA的等价性"></a>DFA与NFA的等价性</h2><p>DFA和NFA是等价的，现在展示互相构造：</p>
<h3 id="已知DFA构造NFA"><a href="#已知DFA构造NFA" class="headerlink" title="已知DFA构造NFA"></a>已知DFA构造NFA</h3><p>这是显然的，DFA就是一种特殊的NFA，只不过转移函数的新状态集合大小始终为1.</p>
<h3 id="已知NFA构造DFA"><a href="#已知NFA构造DFA" class="headerlink" title="已知NFA构造DFA"></a>已知NFA构造DFA</h3><p>使用<strong>子集构造</strong>。</p>
<h1 id="带空转移的NFA"><a href="#带空转移的NFA" class="headerlink" title="带空转移的NFA"></a>带空转移的NFA</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>我们可以在NFA的基础上再允许某个状态在没有输入字符的时候就转移到另一个状态，也就是说转移函数可以接受$\epsilon$输入。</p>
<p>带空转移的NFA被称为$\epsilon-NFA$。</p>
<p>只需要再多考虑<strong>状态闭包</strong>。</p>
<h2 id="NFA与带空转移的NFA的等价性"><a href="#NFA与带空转移的NFA的等价性" class="headerlink" title="NFA与带空转移的NFA的等价性"></a>NFA与带空转移的NFA的等价性</h2><h3 id="已知NFA构造带空转移的NFA"><a href="#已知NFA构造带空转移的NFA" class="headerlink" title="已知NFA构造带空转移的NFA"></a>已知NFA构造带空转移的NFA</h3><p>这也是显然的。</p>
<h3 id="已知带空转移的NFA构造NFA"><a href="#已知带空转移的NFA构造NFA" class="headerlink" title="已知带空转移的NFA构造NFA"></a>已知带空转移的NFA构造NFA</h3><p>取闭包，后转移，再取一次闭包。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/NJU-FLA%E5%A4%A7%E4%BD%9C%E4%B8%9A2024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/02/NJU-FLA%E5%A4%A7%E4%BD%9C%E4%B8%9A2024/" class="post-title-link" itemprop="url">NJU_FLA大作业2024</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-02 23:07:38" itemprop="dateCreated datePublished" datetime="2024-12-02T23:07:38+08:00">2024-12-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-09 23:33:09" itemprop="dateModified" datetime="2024-12-09T23:33:09+08:00">2024-12-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          Here's something encrypted, password is required to continue reading.
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/12/02/NJU-FLA%E5%A4%A7%E4%BD%9C%E4%B8%9A2024/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/02/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A1%AC%E6%A0%B8%E8%B0%93%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/02/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A1%AC%E6%A0%B8%E8%B0%93%E8%AF%8D/" class="post-title-link" itemprop="url">单向函数与硬核谓词</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-02 17:03:40 / 修改时间：21:06:03" itemprop="dateCreated datePublished" datetime="2024-12-02T17:03:40+08:00">2024-12-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第八章Theoretical Constructions of Symmetric-Key Primitives</p>
<p>我们已经引入了伪随机性的概念，并且定义了一些基础的密码学原语，包括伪随机生成器、伪随机函数和伪随机置换。在本章中，我们正式引入单向函数的概念——一种从非正式上讲“易于计算但难以反向计算”的函数——并展示如何在仅假设单向函数存在的情况下构造伪随机生成器、伪随机函数和伪随机置换。</p>
<h1 id="单向函数-One-Way-Functions"><a href="#单向函数-One-Way-Functions" class="headerlink" title="单向函数 One-Way Functions"></a>单向函数 One-Way Functions</h1><p>在本节中，我们将正式定义单向函数，并简要讨论一些被认为符合该定义的函数。接下来，我们引入硬核谓词（hard-core predicates）的概念，它可以被视为封装了单向函数反向计算的难度，并将在随后的构造中被广泛使用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单向函数$f$，是计算简单，但是难以反向计算的函数。</p>
<p>计算简单很容易形式化定义：即$f$是一个可以在多项式时间内计算的函数。</p>
<p>难以反向计算可以通过以下实验进行定义：<br>The inverting experiment $Invert_{\mathcal{A},f}(n)$</p>
<ol>
<li>均匀选取定义域中的x，并计算$f(x)$。</li>
<li>$\mathcal{A}$接受输入$1^n$和$y$，并输出$x’$。（这里$1^n$只是为了保证运行在关于安全参数n的多项式时间内）</li>
<li>若$y=f(x’)$，则实验结果为1，否则为0。</li>
</ol>
<p>注意，这里的实验并不要求必须满足$x=x’$，只要$y=f(x’)$即可。</p>
<p><strong>定义8.1</strong><br>$f$是一个单向函数，当且仅当满足以下两个条件：</p>
<ol>
<li>存在一个多项式时间算法$M_f$来计算$f$，使$M_f(x)=f(x)$。</li>
<li>对于任意多项式时间算法$\mathcal{A}$，都存在negl使<br>$Pr[Invert_{\mathcal{A},f}(n)=1]\leq negl(n)$</li>
</ol>
<p>条件2还可以用以下形式表示：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/1.png?raw=true" alt="1"></p>
<p>一个不是单向的函数并不意味着它在所有情况下（甚至“大多数情况下”）都容易反转。</p>
<p>任何单向函数都可以通过指数时间的暴力搜索进行反转。换句话说，这涉及一个原则上可以解决的问题，但假定它难以高效解决。</p>
<p>当一个函数始终满足$|f(x)|=|x|$时，我们称该函数为length-preserving的，如果在此基础上这个函数还是单射函数，那么称这个函数为one-way permutation的（单向置换）。</p>
<p>上述单向函数和置换的定义方便地考虑了一个在无限定义域和值域上的单一函数。然而，大多数候选单向函数和置换并不完全符合这一框架。相反，它们通常是通过某种算法生成一组参数。</p>
<p><strong>定义8.2</strong><br>$\prod=(Gen,Samp,f)$是一个概率多项式函数三元组，当其符合下面条件时被称为一个function family：</p>
<ol>
<li>Gen：输入$1^n$，输出参数$I$，其中$|I|\ge n$。每个$I$对应定义了集合$\mathcal{D}_I$和$\mathcal{R}_I$，分别是函数$f_I$的定义域和值域。</li>
<li>Samp：输入$I$，输出一个随机均匀分布的元素$x\in\mathcal{D}_I$。</li>
<li>f：一个确定性的算法，输入$I$和$x\in\mathcal{D}_I$，输出$y=f_I(x)\in\mathcal{R}_I$。</li>
</ol>
<p>当对于任意$I$，$\mathcal{D}_I=\mathcal{R}_I$且$f_I(x)$是双射时，我们称$\prod$是一个permutation family。</p>
<p>我们现在可以对应更改上述实验<br>The inverting experiment $Invert_{\mathcal{A},\prod}(n)$</p>
<ol>
<li>运行$Gen(1^n)$，并得到参数$I$。然后运行$Samp(I)$，并得到一个随机均匀分布的元素$x\in\mathcal{D}_I$。最后计算$y=f_I(x)$。</li>
<li>$\mathcal{A}$接受输入$I$和$y$，并输出$x’$。</li>
<li>若$y=f_I(x’)$，则实验结果为1，否则为0。</li>
</ol>
<p><strong>定义8.3</strong><br>一个function/permutation family $\prod$是one-way的，如果对对于任意多项式时间算法$\mathcal{A}$，都存在negl使<br>$Pr[Invert_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<h2 id="潜在的单向函数"><a href="#潜在的单向函数" class="headerlink" title="潜在的单向函数"></a>潜在的单向函数</h2><h3 id="Candidate-1"><a href="#Candidate-1" class="headerlink" title="Candidate 1"></a>Candidate 1</h3><p>我们尚且不能无条件的证明单向函数的存在，所以我们目前必须假设他们的存在，这基于以下事实：一些被广泛研究的问题目前尚未能发现任何多项式时间算法能解决，比如大整数的质因数分解。这个问题难就难在<strong>将两个数相乘得到它们的积很容易，但给定一个数找到它的因数却非常困难</strong>。</p>
<p>这给了我们灵感，我们定义$f_{mult}(x,y)=x\cdot y$，限制x，y的定义域为等长的素数。</p>
<h3 id="Candidate-2"><a href="#Candidate-2" class="headerlink" title="Candidate 2"></a>Candidate 2</h3><p>这个单向函数的构造依赖于子集求和问题，其定义为<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/2.png?raw=true" alt="2"><br>其中$x_i$是一个n比特的字符串，解释为一个整数，$J$是一个n比特字符串，表示指定了子集$\{1,\cdots,n\}$的元素。</p>
<p>这个函数的逆函数是一个NP-complete问题。</p>
<h3 id="Candidate-3"><a href="#Candidate-3" class="headerlink" title="Candidate 3"></a>Candidate 3</h3><p>现在展示一个a family of permutations是单向的。其中Gen是一个概率多项式时间算法，输出一个n比特素数$p$，以及一个特殊元素$g\in \{2,\cdots,p-1\}$。Samp输出一个均匀分布的整数$x\in \{1,\cdots,p-1\}$。最后，定义$f_{p,g}(x)=g^x \bmod p$</p>
<p>可以证明这个函数是单射，因此是一个置换。反转这个函数的困难基于离散对数问题的假设。</p>
<h2 id="硬核谓词-Hard-core-Predicates"><a href="#硬核谓词-Hard-core-Predicates" class="headerlink" title="硬核谓词 Hard-core Predicates"></a>硬核谓词 Hard-core Predicates</h2><p>尽管根据定义单向函数很难反转，这并不意味着我们不能得到任何有用的信息。</p>
<p>举个例子，假设$g$是一个单向函数，我们定义<br>$f(x_1,x_2)=(x_1,g(x_2))$，其中$|x_1|=|x_2|$。<br>很容易证明$f$是一个单向函数，尽管泄露了一半的输入信息。</p>
<p>对于我们的应用，我们需要识别某些关于$x$的特定信息，但是这些信息被$f(x)$隐藏。这促使了<strong>硬核谓词</strong>的概念。</p>
<p><strong>定义8.4</strong><br>一个函数$hc:\{0,1\}^*\rightarrow\{0,1\}$是函数$f$的硬核谓词，当且仅当$hc$可以在多项式时间内计算，并且对于任何的多项式时间算法$\mathcal{A}$，都存在negl使<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/3.png?raw=true" alt="3"></p>
<p>注意，这里的硬核谓词是一个布尔值函数。同时，上述定义并不要求$f$是一个单向函数。但是如果$f$是一个置换函数，那么除非他是单向的，否则没有硬核谓词。</p>
<p>硬核谓词不能简单的构造，这里给出定理，对于任何固定的谓词$hc$，总存在一个单向函数，使这个谓词不是这个单向函数的硬核谓词。</p>
<p>当然，也存在简单的硬核谓词，比如，假设$f$是一个函数，其输出就是丢弃最后的一个比特。那么$hc(x)=x_n$就是$f$的一个硬核谓词。这里$f$是不是单向函数无关紧要。但是，这种简单的硬核谓词在我们后续的构造工作中是没有作用的。</p>
<h1 id="从单向函数到为随机性"><a href="#从单向函数到为随机性" class="headerlink" title="从单向函数到为随机性"></a>从单向函数到为随机性</h1><p>这节我们展示如何从单向函数构造伪随机生成器，伪随机函数和置换。</p>
<p>首先，我们说明任何是否任何一个单向函数都有一个硬核谓词，这仍然是一个开放性问题。我们可以展示一个弱一些的结论。</p>
<p><strong>定理8.5(Goldreich–Levin theorem)</strong><br>假设存在一个单向函数$f$，那么一定存在另一个单向函数$g$和$g$的硬核谓词$gl$。</p>
<p>我们可以通过以下方式进行构造：<br>令$g(x,r)=(f(x),r)$，其中$|x|=|r|$。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/4.png?raw=true" alt="4"></p>
<p>下一步我们展示如何从一个单项置换的硬核谓词构造一个伪随机函数。</p>
<p><strong>定理8.6</strong><br>假设存在一个单向置换$f$，其硬核谓词为$hc$，那么我们可以构造以下的伪随机数生成器，其中expansion factor是$l(n)=n+1$。<br>$G(s)=f(s)||hc(s)$</p>
<p>直觉上看，因为输入是均匀的，所以置换后看起来也是均匀的，最后连接一个看起来是随机的$hc(s)$，所以整体上看起来是随机的。</p>
<p>当然，只能拓展一位的伪随机数生成器用处限制很大，但是幸运的是，我们可以获得任何多项式扩展因子的伪随机生成器。</p>
<p><strong>定理8.7</strong><br>如果存在一个expansion factor是$l(n)=n+1$的伪随机数生成器，那么对于任意的多项式$poly$，都存在expansion factor是l(n)=poly(n)$的伪随机数生成器。</p>
<p>因此，我们得出结论：可以从任何单向置换构造具有任意（多项式）扩展因子的伪随机生成器。</p>
<p>伪随机生成器对于构造 EAV 安全的私钥加密方案是足够的。然而，对于 CPA 安全的私钥加密（更不用说消息认证码了），我们依赖于伪随机函数。以下结果表明，后者可以从前者构造出来。</p>
<p><strong>定理8.8</strong><br>如果存在一个expansion factor是$l(n)=2n$的伪随机数生成器，则存在一个伪随机函数。</p>
<p><strong>定理8.9</strong><br>如果存在一个伪随机函数，则存在一个伪随机置换。</p>
<p>综合上述定理，我们发现，只要有单项置换函数，我们就可以构造出</p>
<ul>
<li>存在任意扩展因子的伪随机生成器、伪随机函数和强伪随机置换。</li>
<li>存在认证加密方案和安全的消息认证码。</li>
</ul>
<h1 id="来自单向函数的硬核谓词"><a href="#来自单向函数的硬核谓词" class="headerlink" title="来自单向函数的硬核谓词"></a>来自单向函数的硬核谓词</h1><p>我们在这一节证明<strong>定理8.5</strong>。<br>略</p>
<h1 id="构造伪随机数生成器"><a href="#构造伪随机数生成器" class="headerlink" title="构造伪随机数生成器"></a>构造伪随机数生成器</h1><p>我们首先展示如何在假设单向置换存在的情况下，构造将输入扩展一个比特的伪随机生成器。然后，我们再展示如何扩展这一构造，以获得任意多项式扩展因子。</p>
<h2 id="最小扩展因子的伪随机数生成器"><a href="#最小扩展因子的伪随机数生成器" class="headerlink" title="最小扩展因子的伪随机数生成器"></a>最小扩展因子的伪随机数生成器</h2><p><strong>定理8.18</strong><br>令$f$为一个单向置换，其硬核谓词为$hc$，那么我们可以构造以下的伪随机数生成器，其中expansion factor是$l(n)=n+1$。<br>$G(s)=f(s)||hc(s)$</p>
<p>证明如下：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/6.png?raw=true" alt="6"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/5.png?raw=true" alt="5"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/26/%E5%88%A4%E5%AE%9A%E6%80%A7%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/26/%E5%88%A4%E5%AE%9A%E6%80%A7%E4%B8%8E%E5%A4%8D%E6%9D%82%E5%BA%A6/" class="post-title-link" itemprop="url">判定性与复杂度</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-26 15:03:06" itemprop="dateCreated datePublished" datetime="2024-11-26T15:03:06+08:00">2024-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-09 23:15:53" itemprop="dateModified" datetime="2024-12-09T23:15:53+08:00">2024-12-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="判定性-Decidability"><a href="#判定性-Decidability" class="headerlink" title="判定性(Decidability)"></a>判定性(Decidability)</h1><p>到目前为止，我们已经学习了正则语言、上下文无关语言、递归语言（图灵可判定语言）、递归可枚举语言（图灵可识别语言）。</p>
<p>我们已经知道正则语言是上下文无关语言的子集，上下文无关语言是图灵可判定语言的子集。</p>
<p>事实上，我们学过的语言符合下图所示的关系。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/1.png?raw=true" alt="1"></p>
<p>我们这一节的目标是证明<br>$\text{decidable} \varsubsetneqq \text{RE} \varsubsetneqq \text{all languages}$</p>
<h2 id="可数与可数集"><a href="#可数与可数集" class="headerlink" title="可数与可数集"></a>可数与可数集</h2><p>首先回顾一下<strong>可数</strong>的概念。<br>我们称自然数集$\mathbb{N}=\{1,2,3,\dots\}$中的元素为<strong>可数</strong>。 （这里暂定自然数从1开始，但是没有本质的区别）<br>对于一个集合$S$，如果该集合是有限集，或者存在一个双射$f:N\rightarrow S$我们称$S$为<strong>可数</strong>。</p>
<hr>
<p><strong>定理</strong>： 实数集$\mathbb{R}$不可数。</p>
<p>证明如下：</p>
<p>假设$\mathbb{R}$是可数，那么存在一个双射$f:N\rightarrow \mathbb{R}$。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/2.png?raw=true" alt="2"></p>
<p>其中<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/3.png?raw=true" alt="3"><br>将有限小数和整数视为后面有无数个0的无限小数。</p>
<p>令x=0.b1b2b3…，其中bi≠aii。</p>
<p>所以x一定不在该表格的双射中。矛盾，所以$\mathbb{R}$不可数。</p>
<hr>
<h2 id="非递归可枚举语言"><a href="#非递归可枚举语言" class="headerlink" title="非递归可枚举语言"></a>非递归可枚举语言</h2><p>现在我们证明非递归可枚举语言(Non-RE Languages)的存在。</p>
<p>所谓非递归可枚举语言，是指不能由图灵机接受并判定的语言。</p>
<hr>
<p><strong>定理</strong>：非递归可枚举语言存在。</p>
<p>证明如下：</p>
<p>所有图灵机的集合是可数的。<br>显然，我们可以由一个有限长度的字符串确定性的表示一个图灵机（将所有要素全部写下来），而对于有限的字母表$\Sigma$，$\Sigma^*$是可数的，因此图灵机是一个可数集的子集，也是可数的。</p>
<p>所有语言的集合是不可数的。<br>用康托尔对角法很容易证明，仿照上面实数集不可数的证明思路。</p>
<p>所以从图灵机的集合到语言的集合的函数时不可逆的。即给定一个语言，不一定有对应的图灵机。</p>
<p>一个显然的事实是，给定一个图灵机，一定会有一个对应的语言；而上面的证明说明了给定一个语言，不一定会有一个能接收这个语言的图灵机，从而递归可枚举语言就是所有语言的真子集。从而得到非递归可枚举语言存在。</p>
<hr>
<p>到目前为止，我们从理论上将递归可枚举语言和所有语言区分开。</p>
<h2 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h2><p>现在我们要寻找一个不可判定的语言，将递归语言和递归可枚举语言彻底区分开来。</p>
<p><strong>定义</strong><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/4.png?raw=true" alt="4"></p>
<p>这里实际上HALT也可以看作一个语言，只不过这个语言接收一个二元组的字符表示作为它的输入字符串而已。</p>
<hr>
<p><strong>定理</strong><br>停机问题不可判定。</p>
<p>证明如下：</p>
<p>假设存在图灵机H能判定HALT问题。</p>
<ul>
<li>如果M对于输入x可以停机，那么H会接受$&lt; M, x&gt;$</li>
<li>如果M对于输入x不会停机，那么H会拒绝$&lt; M, x&gt;$</li>
</ul>
<p>现在定义一个新图灵机H’，它接受输入$&lt; M&gt;$, 即图灵机的字符串表示</p>
<ul>
<li>如果H接受了$&lt; M, &lt; M&gt;&gt;$，则死循环</li>
<li>如果H拒绝了$&lt; M, &lt; M&gt;&gt;$，则停机</li>
</ul>
<p>现在考虑给H’输入$&lt; H’&gt;$</p>
<ul>
<li>如果停机，那么H拒绝了输入，说明H不能停机</li>
<li>如果死循环，那么H接受输入，说明H可以停机</li>
</ul>
<p>显然这是矛盾的，因此H和H’都不存在。</p>
<hr>
<p>到目前为止，我们已经找到了一种语言，停机问题，是不可判定的，将递归语言和递归可枚举语言彻底区分了开来。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/5.png?raw=true" alt="5"></p>
<h2 id="图灵不可识别的语言"><a href="#图灵不可识别的语言" class="headerlink" title="图灵不可识别的语言"></a>图灵不可识别的语言</h2><p>下面给出一个具体的例子。<br><strong>定义</strong>：<br>定义一个递归可枚举(RE)语言的补集co-RE，则有如下关系：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/6.png?raw=true" alt="6"></p>
<p>这里的补集指的是所有的具体语言关于$\Sigma^*$的补集所形成的新的语言的集合。</p>
<hr>
<p><strong>定理</strong>：<br>一个语言$L$可判定，当且仅当它既是RE，也是co-RE。</p>
<p>充要性证明省略</p>
<hr>
<p>由此我们可以得出，HALT的补集不是递归可枚举的。</p>
<p>到此，我们就彻底搞清了各种语言之间的包含关系了。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/7.png?raw=true" alt="7"></p>
<h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>算法是什么：算法是一个必定会停止的图灵机，也就是一个递归语言/图灵可判定语言的图灵机。</p>
<p>真实世界中，运行算法会占用<strong>时间空间</strong>资源。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一个图灵机运行时间（步数），被称为<strong>时间复杂度</strong>。用一个函数表示：<br>$f:\mathbb{N}\rightarrow\mathbb{N}$<br>其中$f(n)$是$M$对于任意长度为$n$的输入停机所需要的最大步骤数（移动次数）。这里分析的是最坏情况。</p>
<p><strong>渐进表示法</strong><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/8.png?raw=true" alt="8"></p>
<h2 id="时间复杂度类"><a href="#时间复杂度类" class="headerlink" title="时间复杂度类"></a>时间复杂度类</h2><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/9.png?raw=true" alt="9"></p>
<p>用多带图灵机来编程通常会比单带的图灵机更方便一些。</p>
<ul>
<li>在我们讨论可判定性的时候，它们是等价的；</li>
<li>不过当我们讨论复杂度的时候，它们就不等价了。</li>
</ul>
<p>同时我们有以下定理<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/10.png?raw=true" alt="10"></p>
<h1 id="P与NP"><a href="#P与NP" class="headerlink" title="P与NP"></a>P与NP</h1><p>我们认为多项式运行时间是高效的，认为指数运行时间是不高效的。</p>
<h2 id="P"><a href="#P" class="headerlink" title="P"></a>P</h2><p><strong>定义</strong><br>定义 P 或者 多项式时间(polynomial-time) 是一类语言，它们在一个单带、确定性图灵机上是多项式时间可判定的。<br>$P=\cup_{k\ge 1} TIME(n^k)$</p>
<p>我们关注P是因为计算模型对多项式是不敏感的，换而言之，在一个确定性计算模型上面多项式时间的算法在另一个确定性计算模型上依旧是多项式时间的。</p>
<h2 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h2><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/11.png?raw=true" alt="11"></p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/12.png?raw=true" alt="12"><br>意思就是，对于具体的解能在多项式时间能判定。</p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>给定一个新问题，如果我们先买个要说明这个问题不可判定，我们通常有两种思路：</p>
<ol>
<li>从头开始论证</li>
<li>将一个已知不可判定的问题转变为新问题，使新问题的解决办法也可以解决旧问题。</li>
</ol>
<p><strong>归约(reduction)</strong> 是一种将一个问题转化成另一个问题的方式，使得第二个问题的解决方案也可以用来解决第一个问题。</p>
<p>首先我们定义什么是可计算的函数<br><strong>定义</strong>：<br>一个函数$f:\sum^<em> \rightarrow \sum^</em>$是<strong>可计算的(computable)</strong>，如果存在一个图灵机$M_f$，使得对于每一个输入$\omega$，$M_f$将$f(\omega)$写到纸带上并停机。</p>
<p>然后我们来定义归约<br><strong>定义</strong>：<br>A可以被映射归约(mapping reducible)为B，写作$A\leq_m B$，如果存在一个可计算的函数$f$，使得对于所有$\omega$，都有<br>$\omega\in A\Leftrightarrow f(\omega)\in B$<br>等价的<br>$\omega\notin A\Leftrightarrow f(\omega)\notin B$<br>$f$被称为从A到B的一个归约。</p>
<p>下图是语言$A$到$B$的归约的图示<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/13.png?raw=true" alt="13"></p>
<p><strong>定理</strong>：<br>如果$A\leq_m B$且$B$是可判定的，那么$A$也是可判定的。</p>
<p>注意其逆否命题的方向<br>如果$A\leq_m B$且$A$是不可判定的，那么$B$也是不可判定的。</p>
<p><strong>定理</strong>：<br>如果$A\leq_m B$且$B$是RE，那么$A$也是RE。</p>
<h2 id="Rice定理"><a href="#Rice定理" class="headerlink" title="Rice定理"></a>Rice定理</h2><p>我们发现图灵机的以下一些性质是不可判定的。</p>
<ul>
<li>接受字符$\omega$</li>
<li>在输入字符串$\omega$时停机</li>
<li>接受语言为空</li>
</ul>
<p><strong>定理</strong>：<br><strong>Rice定理</strong>： 图灵机的每一个<strong>非平凡</strong>的<strong>性质</strong>都是不可判定的。</p>
<p><strong>定义</strong><br>一个图灵机的<strong>性质property</strong>指一个语言$P$，满足对于任意两个图灵机$M_1,M_2$，如果$L(M_1)=L(M_2)$，则<br>$&lt; M_1&gt;\in P\Leftrightarrow &lt; M_2&gt; \in P$</p>
<p>如果存在一个图灵机$M_1$，使得$&lt; M_1&gt;\in P$且存在一个图灵机$M_2$，使得$&lt; M_2&gt;\notin P$，则称$P$是一个<strong>非平凡</strong>的性质。</p>
<h1 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h1><h2 id="多项式时间归约"><a href="#多项式时间归约" class="headerlink" title="多项式时间归约"></a>多项式时间归约</h2><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/%E5%88%A4%E5%AE%9A%E6%80%A7/14.png?raw=true" alt="14"><br><strong>定理</strong>：<br>如果$A\leq_P B$且$B\in P$，那么$A\in P$。</p>
<h2 id="NP完全理论"><a href="#NP完全理论" class="headerlink" title="NP完全理论"></a>NP完全理论</h2><p><strong>定义</strong><br>我们称一个语言B是<strong>NP完全的</strong>，当且仅当满足以下条件：</p>
<ol>
<li>$B\in NP$</li>
<li>$\forall A\in NP:A\leq_P B$<br>若只满足第二个条件，则称B是<strong>NP难的</strong>。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/22/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/22/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">哈希函数及其应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-22 22:37:32" itemprop="dateCreated datePublished" datetime="2024-11-22T22:37:32+08:00">2024-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-25 16:46:03" itemprop="dateModified" datetime="2024-11-25T16:46:03+08:00">2024-11-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第六章Hash Functions and Applications</p>
<p>我们现在关注一个具有广泛应用的加密原语：加密哈希函数。在最基本的层面上，哈希函数 $H$提供了一种确定性的方法，将较长的输入字符串映射为较短的输出字符串，通常称为digest。主要的要求是：找到 H 的碰撞（即两个不同的输入产生相同的digest）应该是不可行的。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>哈希函数是一类将任意长度的输入压缩为固定长度输出的函数。非加密哈希函数的经典用途是在数据结构中，它们可以用来构建哈希表，从而在存储一组元素时实现$O(1)$的查找。具体来说，如果哈希函数$H$的输出范围大小为$N$，那么元素x被存储在表格的第$H(x)$行。</p>
<p>一个良好的哈希函数要尽可能的减少碰撞(collision)。抗碰撞(Collision-resistant)哈希函数的目标也是避免碰撞，但是在数据结构的应用中，较少碰撞只是优化的要求，但是在密码学背景下，避免碰撞是一个严格的要求，因为攻击者可能会故意构造发生碰撞的值来进行攻击。所以设计抗碰撞哈希函数的难度要高于设计一般的哈希函数。</p>
<h2 id="Collision-Resistance"><a href="#Collision-Resistance" class="headerlink" title="Collision Resistance"></a>Collision Resistance</h2><p>形式上，$H$是一个双输入函数，接受一个密钥s和一个字符串x，输出$H_s(x)$。</p>
<p>这里的密钥和我们过去考虑的密钥有所不同，在过去的密钥我们希望保密，但是这里哈希函数中攻击者可能知道密钥，在这个前提下，我们希望哈希函数还具有抗碰撞性。</p>
<p><strong>DEFINITION 6.1</strong><br>一个哈希函数由一对概率多项式算法组成。</p>
<ul>
<li>Gen： 是一个概率算法，输出密钥s</li>
<li>H： 是一个确定性算法，接受一个密钥s和一个字符串x，输出$H_s(x)$，长度为$l(n)$</li>
</ul>
<p>如果H只接受固定长度的字符串输入，我们称哈希函数为fixed-length，H为compression function。显然这里输出的长度必须小于输入长度。</p>
<p>下面介绍攻击实验The collission-finding experiment $Hash-coll_{\mathcal{A},\mathcal{H}}(n)$:</p>
<ol>
<li>生成密钥s</li>
<li>攻击者接受s，输出$x,x’$。</li>
<li>如果这两个输出产生碰撞，则实验结果为1，反之为0</li>
</ol>
<p>$DEFINITON 6.2$<br>一个哈希函数是Collision Resistant当且仅当<br>$Pr[Hash-coll_{\mathcal{A},\mathcal{H}}(n) = 1]\leq negl(n)$</p>
<p><strong>无密钥的哈希函数</strong><br>实际上使用的哈希函数通常是没有密钥的，当然，这在理论上来看，总存在一个常数事件算法，直接输入碰撞对。<br>当然，现实世界里，找到碰撞对在计算上是很困难的。</p>
<h2 id="弱一些的安全定义"><a href="#弱一些的安全定义" class="headerlink" title="弱一些的安全定义"></a>弱一些的安全定义</h2><ul>
<li>Second-preimage resistance<br>对于一个哈希函数，如果给定s和x，找不到另一个能碰撞的字符串。</li>
<li>Preimage resistance<br>对于一个哈希函数，如果给定s和$H_s(x)$，找不到另一个能碰撞的字符串。</li>
</ul>
<p>coliision resistant $\Rightarrow$ second-preimage resistance $\Rightarrow$ preimage resistance</p>
<h1 id="Merkle–Damgard变换"><a href="#Merkle–Damgard变换" class="headerlink" title="Merkle–Damgård变换"></a>Merkle–Damgård变换</h1><p>许多应用需要“完全成熟”的抗碰撞哈希函数，这种哈希函数能够处理非常长的输入，甚至是任意长度的输入。然而，构造固定长度的哈希函数（即压缩函数）更为容易——这些函数只接受“短”的输入。幸运的是，Merkle–Damgård变换使我们可以将后者转换为前者。这种哈希函数域扩展的方法在实践中被频繁使用，例如MD5和SHA系列哈希函数。</p>
<p>假设已经存在压缩函数$(Gen,h)$，能接受长度大于2n的输入并输出长度为n的输出。那么我们可以通过下面的变换得到一个能处理任意长度输入的哈希函数<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/1.png?raw=true" alt="1"></p>
<p><strong>THEOREM 6.4</strong><br>如果$(Gen,h)$抗碰撞，那么构造的$(Gen,H)$也抗碰撞</p>
<p>证明如下：//TODO</p>
<h1 id="应用哈希函数进行消息认证"><a href="#应用哈希函数进行消息认证" class="headerlink" title="应用哈希函数进行消息认证"></a>应用哈希函数进行消息认证</h1><p>我们之前已经讨论了几种针对任意长度消息的消息认证码（MAC）的构造。在本节中，我们将看到另一种方法，该方法依赖于抗碰撞哈希函数。随后，我们会介绍一种被标准化并广泛使用的方案，称为 HMAC（哈希消息认证码），它可以看作是这种方法的具体实现。</p>
<h2 id="Hash-and-MAC"><a href="#Hash-and-MAC" class="headerlink" title="Hash-and-MAC"></a>Hash-and-MAC</h2><p>抗碰撞哈希函数可以自然地用于消息认证码（MAC）的域扩展。例如，假设我们有一个固定长度的 MAC，它可以处理长度为 l(n)-比特的消息，并且有一个输出长度为 l(n)-比特的抗碰撞哈希函数。那么我们可以通过对消息 m 进行哈希计算，然后使用 MAC 对哈希值进行认证，从而对任意长度的消息 m 进行认证。（参见构造 6.5。）</p>
<p>直观上，这种方法是安全的，因为：</p>
<ul>
<li>MAC 的安全性 确保攻击者无法认证任何新的哈希值。</li>
<li>抗碰撞性 确保攻击者无法找到与已使用哈希值相同的哈希的新消息。</li>
</ul>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/2.png?raw=true" alt="2"></p>
<p><strong>THEOREM 6.6</strong><br>如果$\prod$是一个secure的MAC，$\mathcal{H}$是一个抗碰撞的哈希函数，那么上述构造是一个secure MAC</p>
<p>证明如下：//TODO</p>
<h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>在原则上，可以通过将任意抗碰撞哈希函数与第4.5节中的固定长度消息认证码（MAC）相结合，来实现上一节提到的“哈希并认证”（hash-and-MAC）方法。然而，这种方法在实际中有至少两个缺点：</p>
<ul>
<li>需要实现两种密码学原语</li>
<li>哈希函数输出长度与分组密码分组长度之间的不匹配</li>
</ul>
<p>HMAC 的设计克服了哈希函数和分组密码之间的不匹配问题，同时通过高效的构造支持任意长度的消息。具体地，HMAC 使用了两次调用哈希函数的过程，同时结合了内置的密钥与填充操作，以确保安全性。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/3.png?raw=true" alt="3"></p>
<p><strong>THEOREM 6.8</strong><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/4.png?raw=true" alt="4"></p>
<p>证明如下：//TODO</p>
<h1 id="对哈希函数的攻击"><a href="#对哈希函数的攻击" class="headerlink" title="对哈希函数的攻击"></a>对哈希函数的攻击</h1><h2 id="Birthday-Attacks"><a href="#Birthday-Attacks" class="headerlink" title="Birthday Attacks"></a>Birthday Attacks</h2><p>最简单的攻击是在输入空间内穷举，但是复杂度高达$2^{n}$。</p>
<p>现在考虑一个问题，一个房间里有q个人，那么存在两个人生日相同的概率是多少。<br>我们不难发现，当$q\approx 2^{l/2}$时，碰撞的概率接近0.5。</p>
<p>所以，攻击者只需要尝试$2^{l/2}$次，就能显著提高找到碰撞对的概率。</p>
<p>所以，要达到相同的安全水平，哈希函数输出的长度应该是2n。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/11/21/CCA%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/11/21/CCA%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">CCA安全和认证加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-21 14:39:28" itemprop="dateCreated datePublished" datetime="2024-11-21T14:39:28+08:00">2024-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-11-22 22:34:22" itemprop="dateModified" datetime="2024-11-22T22:34:22+08:00">2024-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第五章CCA-Security and Authenticated Encryption</p>
<p>我们已经讨论过了两种攻击者，一种是监听信道，一种是纂改通信，对应的我们提出了保密性和完整性的目标。现在我们要讨论存在主动攻击者时的保密性问题，以及如何构建同时实现保密性和完整性的加密方案。</p>
<h1 id="选择密文攻击和CCA安全"><a href="#选择密文攻击和CCA安全" class="headerlink" title="选择密文攻击和CCA安全"></a>选择密文攻击和CCA安全</h1><p>我们上一章中考虑攻击者可以纂改信道，那么显然，攻击者可以有以下的手段，使通信接收方解密攻击者生成的密文，并且攻击者还能知道解密后的消息。</p>
<h2 id="Padding-Oracle-Attacks"><a href="#Padding-Oracle-Attacks" class="headerlink" title="Padding-Oracle Attacks"></a>Padding-Oracle Attacks</h2><p>现在考虑一种真实情况，客户端使用CBC模式加密向服务器发送消息，假设攻击者能够冒充客户端，向服务器发送其选择的密文，那么攻击者能获得服务器的相关反应来推断密文的有效性（比如服务器解密失败就会要求重传）。</p>
<p>在CBC加密模式下，我们要求消息长度为底层分组密码长度的整数倍，如果消息长度不满足，则需要进行填充。而填充也需要遵循一定的方案，服务器会解密并验证是否遵循正确的填充方案。</p>
<p>这意味着服务器会向攻击者提供一个填充查询机，来判断填充是否正确。并且攻击者是有方法根据这个信息来恢复密文对应的明文的。</p>
<h2 id="CCA-Security-的定义"><a href="#CCA-Security-的定义" class="headerlink" title="CCA-Security 的定义"></a>CCA-Security 的定义</h2><p>下面来形式化定义一下CCA安全。<br>我们仿照之前的实验方案，给出CCA不可区分实验：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/1.png?raw=true" alt="1"></p>
<p>注意这里，加密算法应该是概率性的，否则很容易通过加密查询来获取正确结果。</p>
<p><strong>DEFINITION 5.1</strong><br>一个加密方案是安全的当且仅当<br>$Pr[PrivK^{cca}_{\mathcal{A},\prod}(n)=1]\leq 1/2+negl(n)$</p>
<p>由此也可以引申出，如果一个方案是CCA安全的，在多密文不可区分实验中仍然是CCA安全的。</p>
<p>以上实验中给了攻击者很大的能力，比如能知道解密后的明文，但是现实中知道的信息不一定有这么多，我们这里在定义上希望攻击者足够强。</p>
<p>到目前为止，我们研究的大多数方案都不是CCA安全的。攻击者可以通过比特翻转等攻击方式来打破不可区分性。</p>
<h1 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h1><p>迄今为止，我们分别探讨了如何通过加密实现机密性，以及通过消息认证码实现完整性。下面定义的认证加密（Authenticated Encryption）旨在同时实现这两个目标。在对称密钥环境中，默认同时确保机密性和完整性是最佳实践。事实上，在许多需要机密性的应用中，完整性通常也是至关重要的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>考虑以下实验：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/2.png?raw=true" alt="2"><br>简单的说就是要求攻击者不能伪造一个有效的密文。</p>
<p><strong>DEFINITION 5.2</strong><br>一个方案是不可伪造的(unforgeble)，当且仅当对于任何多项式概率算法攻击者A，都有<br>$Pr[Enc-Forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<p><strong>DEFINITION 5.3</strong><br>一个方案是AE(authenticated encryption)当且仅当这个方案是CCA安全的并且是不可伪造的。</p>
<p>我们也可以通过一个单一的实验来定义AE加密方案。<br>假设现在攻击者可以遇到以下两种不同的情况：</p>
<ol>
<li>攻击者被提供了一个加密oracle和一个解密oracle的访问权限。</li>
<li>攻击者获得的是一个加密0字符串的oracle。一个始终返回错误符号$\perp $的解密oracle。</li>
</ol>
<p>如果攻击者不能区分这两种场景，这说明攻击者在真实世界中生成的新密文都将无效同时攻击者无法区分真实的加密。</p>
<p>该实验的定义如下：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/3.png?raw=true" alt="3"></p>
<p><strong>DEFINITION 5.4</strong><br>一个方案是AE-secure，当且仅当对于任何多项式概率算法攻击者A，都有<br>$Pr[PrivK^{ae}_{\mathcal{A},\prod}(n)=1]\leq 1/2+negl(n)$</p>
<p><strong>THEROREM 5.5</strong><br>定义5.3和定义5.4是等价的。</p>
<p>带有关联数据的认证加密：在许多情况下，可能只有部分内容需要加密，部分内容只要保证完整性即可。虽然对整体消息进行AE方案加密可以满足要求，但是效率较低，现实中，支持关联数据的认证加密方案在文献中被称为带有关联数据的认证加密（Authenticated Encryption with Associated Data，简称 AEAD）。</p>
<h2 id="CCA安全-vs-认证加密"><a href="#CCA安全-vs-认证加密" class="headerlink" title="CCA安全 vs 认证加密"></a>CCA安全 vs 认证加密</h2><p>我们根据定义可以直接得出任何认证加密（AE）方案也都是选择密文攻击安全（CCA-secure）的。然而，反之则不成立。</p>
<p>在现实世界中，确实存在情景只需要CCA安全而不关注认证加密。尽管如此，在存在活跃攻击者的情况下，大多数对称密钥加密的应用确实需要完整性保护。幸运的是，大多数自然构造的 CCA 安全加密方案通常也满足更强的认证加密定义。从这个角度来看，没有理由使用那些既是 CCA 安全但不是认证加密的方案，因为没有任何此类方案在效率上比认证加密方案更优。</p>
<h1 id="认证加密方案"><a href="#认证加密方案" class="headerlink" title="认证加密方案"></a>认证加密方案</h1><h2 id="一般构造"><a href="#一般构造" class="headerlink" title="一般构造"></a>一般构造</h2><p>直觉上认为将一个CPA安全的加密方案和一个安全的MAC方案结合就能得到一个AE方案，但是事实上不是这样的。</p>
<p>假设：</p>
<ol>
<li>$\prod_{E}=(Enc,Dec)$是一个CPA安全的加密方案</li>
<li>$\prod_{M}=(MAC,Verify)$是一个安全的MAC方案</li>
<li>两种方案使用独立的密钥$k_E$和$k_M$</li>
</ol>
<p>下面是常见的三种构造方式。</p>
<h3 id="Encrypt-and-authenticate"><a href="#Encrypt-and-authenticate" class="headerlink" title="Encrypt-and-authenticate"></a>Encrypt-and-authenticate</h3><p>$c\leftarrow Enc(k_E,m),t\leftarrow MAC(k_M,m)$<br>因为它未能将机密性和完整性紧密结合，导致标签可能泄露关于消息的信息，确定性MAC可能使攻击者意识到消息的重复发送等问题。</p>
<h3 id="Authenticate-then-encrypt"><a href="#Authenticate-then-encrypt" class="headerlink" title="Authenticate-then-encrypt"></a>Authenticate-then-encrypt</h3><p>$t\leftarrow MAC(k_M,m),c\leftarrow Enc(k_E,m||t)$<br>一般会用CBC模式进行加密，那么填充部分就可以用来实现攻击，因为不同的错误类型会提供有效信息。一个很直接的解决方案是使错误信息都返回同一种。但是这在现实中并不有效，不利于调试等等问题。</p>
<h3 id="Encrypt-then-authenticate"><a href="#Encrypt-then-authenticate" class="headerlink" title="Encrypt-then-authenticate"></a>Encrypt-then-authenticate</h3><p>$c\leftarrow Enc(k_E,m),t\leftarrow MAC(k_M,c)$<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/4.png?raw=true" alt="4"><br>直观上这样的构造很安全。</p>
<p>如果攻击者提交的密文 ⟨c,t⟩ 不来自加密 oracle，认证标签 t 将无法通过验证，解密 oracle 会返回错误。<br>如果攻击者提交的密文确实来自加密 oracle，那么攻击者已经知道该密文的解密结果。<br>这种设计使解密 oracle 对攻击者无用，从而避免了选择密文攻击（CCA）的潜在威胁。</p>
<p>在解密之前，首先验证标签 t。如果标签验证失败，解密算法立即返回错误，而不会尝试解密密文 c。<br>这种设计避免了与 Authenticate-then-Encrypt 方法类似的填充 Oracle 攻击，因为解密过程不会执行，攻击者无法通过错误信息获知关于明文的任何信息。</p>
<p><strong>THEROREM 5.7</strong><br>以上构造是AE安全的。</p>
<hr>
<p>证明过程有点复杂，可能期末复习的时候再整理。</p>
<hr>
<h2 id="标准化方案"><a href="#标准化方案" class="headerlink" title="标准化方案"></a>标准化方案</h2><p>下面介绍实际中应用较广的三种AE方案。</p>
<h3 id="GCM-Galois-Counter-Mode"><a href="#GCM-Galois-Counter-Mode" class="headerlink" title="GCM(Galois/Counter Mode)"></a>GCM(Galois/Counter Mode)</h3><p>可以看作是一种encrypt-then-authenticate。使用CTR-mode进行加密，GMAC实现消息认证。</p>
<h3 id="CCM-Counter-with-CBC-MAC"><a href="#CCM-Counter-with-CBC-MAC" class="headerlink" title="CCM (Counter with CBC-MAC)"></a>CCM (Counter with CBC-MAC)</h3><p>其设计基于 Authenticate-then-Encrypt 范式，结合了 CTR 模式和 CBC-MAC。</p>
<h3 id="ChaCha20–Poly1305"><a href="#ChaCha20–Poly1305" class="headerlink" title="ChaCha20–Poly1305"></a>ChaCha20–Poly1305</h3><p>是一种基于 Encrypt-then-Authenticate 范式的高效认证加密（AE）方案，设计上适合软件实现，特别是在缺乏 GCM 硬件加速的情况下。</p>
<h1 id="安全通信会话"><a href="#安全通信会话" class="headerlink" title="安全通信会话"></a>安全通信会话</h1><p>这里简单介绍以下通信双方如何实现兼顾保密性和完整性的通信。<br>一般可能遭受的攻击有消息重排攻击，重放攻击，消息丢弃攻击，反射攻击等等。</p>
<p>可以使用计数器(counters)来维护双方发送接受信息的数量，使用方向比特(directionality bit)来设定消息的来源和方向。将这些信息加入消息中从而抵御这些攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gisyxi7</p>
  <div class="site-description" itemprop="description">nju cs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gisyxi7</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
