<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nju cs">
<meta property="og:type" content="website">
<meta property="og:title" content="Gisyxi7&#39;s blogs">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Gisyxi7&#39;s blogs">
<meta property="og:description" content="nju cs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gisyxi7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Gisyxi7's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Gisyxi7's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学不动了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/20/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/20/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">公钥加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-20 01:51:57" itemprop="dateCreated datePublished" datetime="2024-12-20T01:51:57+08:00">2024-12-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/18/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E5%8F%98%E9%9D%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/18/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E5%8F%98%E9%9D%A9/" class="post-title-link" itemprop="url">【九】密钥管理与公钥加密变革</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-18 14:27:25" itemprop="dateCreated datePublished" datetime="2024-12-18T14:27:25+08:00">2024-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-20 01:50:56" itemprop="dateModified" datetime="2024-12-20T01:50:56+08:00">2024-12-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="密钥分发和密钥管理"><a href="#密钥分发和密钥管理" class="headerlink" title="密钥分发和密钥管理"></a>密钥分发和密钥管理</h1><p>我们一直没有讨论这样一个问题，在之前的私钥加密体系中，双方最初如何共享一个密钥。</p>
<p>显然，如果要安全的共享密钥，就必须要有一个安全的信道来可靠的共享，但这要付出很高的代价。保存密钥、分享密钥在开放系统中是非常困难的。</p>
<p>总之，关于私钥加密存在以下问题：</p>
<ul>
<li>密钥分发</li>
<li>管理和存储大量密钥</li>
<li>对开放系统的不适用性</li>
</ul>
<h1 id="部分解决方案：密钥分发中心"><a href="#部分解决方案：密钥分发中心" class="headerlink" title="部分解决方案：密钥分发中心"></a>部分解决方案：密钥分发中心</h1><p>一种解决的方法是使用密钥分发中心(Key-Distribution Center, KDC)。</p>
<p>假设这是一个大型公司的场景，所有员工之间需要能够进行安全通信，我们可以利用所有员工都信任某个实体（比如管理员），让这个可信实体充当KDC。</p>
<p>当新员工入职，KDC可以以安全的方式（比如面对面）交付给新员工密钥，这其中包括：</p>
<ol>
<li>KDC和新员工之间的共享密钥</li>
<li>新员工和员工之间共享的密钥</li>
</ol>
<p>当然这个方法需要员工储存很多密钥，我们可以通过另一种方式避免，考虑员工A和B需要进行通话：</p>
<ol>
<li>A用$k_A$向KDC发送消息，申请和B进行通话</li>
<li>KDC返回一个随机密钥$k$给A和B</li>
<li>A和B使用密钥$k$进行通信，结束后密钥$k$失效。</li>
</ol>
<p>以上方式的优点在于：</p>
<ul>
<li>每位员工只需要保存一个密钥</li>
<li>当一名员工加入组织，只需要与KDC建立密钥</li>
</ul>
<p>当然也存在缺点：</p>
<ul>
<li>对KDC的成功攻击会导致整个系统全部崩溃，也存在内部攻击的风险</li>
<li>KDC单点故障会或频繁请求会导致通信失败，负载过高。</li>
</ul>
<h2 id="使用-KDC-进行密钥分发的协议"><a href="#使用-KDC-进行密钥分发的协议" class="headerlink" title="使用 KDC 进行密钥分发的协议"></a>使用 KDC 进行密钥分发的协议</h2><p>我们下面介绍<strong>Needham–Schroeder协议</strong>。</p>
<p>当A请求和B通信：</p>
<ol>
<li>KDC将使用$k_A$加密的会话密钥和使用$k_B$加密的会话密钥(ticket)发送给A</li>
<li>A将ticket转发给B</li>
<li>双方获得会话密钥，进行通信</li>
</ol>
<p>以上方案的好处在于：</p>
<ul>
<li>减少了额外连接，KDC只需要建立一次连接</li>
<li>支持会话的重新启动，但是事实上ticket会有有效期</li>
</ul>
<h1 id="密钥交换和Diffie–Hellman协议"><a href="#密钥交换和Diffie–Hellman协议" class="headerlink" title="密钥交换和Diffie–Hellman协议"></a>密钥交换和Diffie–Hellman协议</h1><p>上述的方案仍然存在最底层的问题，就是在初始分发的时候依赖一个安全信道。但是在互联网这样的开放系统中，是难以实现的。</p>
<p>为了在没有私密信道的情况下进行私密通信，Diffie和Hellman提出了<strong>Diffie–Hellman 协议</strong>。</p>
<p>首先我们仅讨论：</p>
<ul>
<li>攻击者只能窃听，无法干预信道</li>
<li>通信双方在开始时没有任何共享信息</li>
</ul>
<h2 id="安全性定义"><a href="#安全性定义" class="headerlink" title="安全性定义"></a>安全性定义</h2><p>首先我们假设双方运行一个随机化协议$\prod$，能够双方独立运行后生成相同的密钥，直观上，我们希望这个协议生成的密钥和完全随机的密钥对于攻击者是不可区分的。</p>
<p>令$\prod$是密钥交换协议，$\mathcal{A}$是攻击者，$n$是安全参数。<br>定义以下密钥交换实验$KE^{eav}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>双方都以$1^n$为参数运行$\prod$，得到$k$和$trans$（全部通信记录）</li>
<li>随机选择$b\in\{0,1\}$，如果$b=0$，则$\hat{k}=k$，否则随机选择$\hat{k}\in\{0,1\}^n$</li>
<li>$\mathcal{A}$接受trans和$\hat{k}$，并返回一个布尔值$b’$</li>
<li>如果$\mathcal{A}$返回$b’=b$，则实验结果为1，否则为0</li>
</ol>
<p>我们根据这个实验可以定义一个密钥交换协议$\prod$是安全的，当且仅当对于任何PPT攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/1.png?raw=true" alt="1"></p>
<h2 id="Diffie–Hellman-密钥交换协议"><a href="#Diffie–Hellman-密钥交换协议" class="headerlink" title="Diffie–Hellman 密钥交换协议"></a>Diffie–Hellman 密钥交换协议</h2><p>令$\mathcal{G}$是一个多项式概率性算法，其接受$1^n$作为输入，输出一个循环群$\mathcal{G}$，其阶$q$，其生成元$g\in\mathcal{G}$。</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li>共同输入：$1^n$</li>
<li>协议<ol>
<li>A运行$\mathcal{G}(1^m)$获得$(\mathbb{G},q,g)$</li>
<li>A随机均匀选择$x\in \mathbb{Z}_q$，计算$h_A:=g^x$</li>
<li>A将$(\mathcal{G},q,g,h_A)$发给B</li>
<li>B接受到$(\mathcal{G},q,g,h_A)$，随机均匀选取$y\in\mathbb{Z}_q$，计算$h_B:=g^y$，B将$h_B$发给A并得到密钥$k_B:=h_A^y$</li>
<li>A接受$h_B$，得到密钥$k_A:=h_B^x$</li>
</ol>
</li>
</ul>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/2.png?raw=true" alt="2"></p>
<p>双方的密钥都为$g^{xy}$。因此该方案的正确性得以证明。</p>
<h3 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>这个协议是安全的，证明如下：</p>
<p>我们首先修改了安全性实验，令$\hat{KE}^{eav}_{\mathcal{A},\prod}(n)$在$b=1$时令$\hat{k}$从$\mathbb{G}$中均匀选取。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/3.png?raw=true" alt="3"></p>
<p>而根据DDH问题的困难性假设，我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/4.png?raw=true" alt="4"></p>
<p>综上有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/5.png?raw=true" alt="5"></p>
<p>于是我们完成了证明。</p>
<h3 id="安全性评估"><a href="#安全性评估" class="headerlink" title="安全性评估"></a>安全性评估</h3><p>我们只考虑了攻击者仅窃听情况下的安全性，但是我们仍然要考虑：</p>
<ul>
<li>攻击者冒充一方</li>
<li>攻击者拦截并修改信息</li>
</ul>
<p>显然上述方案对这两种攻击不能防护。但是上述方案首次在理论上展示了不对称技术可以用于解决密码学中的难题。</p>
<h1 id="公钥加密变革"><a href="#公钥加密变革" class="headerlink" title="公钥加密变革"></a>公钥加密变革</h1><p>除了密钥交换，Diffie和Hellman还提出了公钥密码学的概念。</p>
<p>在公钥密码学中，希望进行安全通信的一方会生成一对密钥，一个公钥用于广泛传播，另一个私钥则保持秘密。这种方案也被称为非对称加密。我们可以通过公钥加密方案来保证消息的保密性，用数字签名保证消息的完整性。</p>
<p>公钥密码学的出现使得：</p>
<ol>
<li>允许通过公共信道进行密钥分发</li>
<li>减少了用户存储大量密钥的需求</li>
<li>更适合开放环境</li>
</ol>
<p>很显然，公钥密码学比对称密码学更强大，但是对称密码学更高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/17/%E6%95%B0%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9B%B0%E9%9A%BE%E5%BA%A6%E5%81%87%E8%AE%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E6%95%B0%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9B%B0%E9%9A%BE%E5%BA%A6%E5%81%87%E8%AE%BE/" class="post-title-link" itemprop="url">【八】数论与密码学困难度假设</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-17 11:16:30" itemprop="dateCreated datePublished" datetime="2024-12-17T11:16:30+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-19 16:50:33" itemprop="dateModified" datetime="2024-12-19T16:50:33+08:00">2024-12-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第九章 Number Theory and Cryptographic Hardness Assumptions</p>
<p>到目前为止我们构建的现代密码学系统无一例外都基于一些假设：</p>
<ul>
<li>对称密钥密码学和消息验证码都基于伪随机置换存在的假设</li>
<li>伪随机置换的存在基于单向函数存在的假设</li>
<li>单向函数的存在基于一些问题是难问题的假设</li>
</ul>
<p>这一章我们将研究数论，这是进一步研究难问题的基础。</p>
<h1 id="预备知识和基本群论"><a href="#预备知识和基本群论" class="headerlink" title="预备知识和基本群论"></a>预备知识和基本群论</h1><h2 id="素数和可除性"><a href="#素数和可除性" class="headerlink" title="素数和可除性"></a>素数和可除性</h2><p>首先，我们记$\mathbb{Z}$为整数集合。</p>
<p>对于$a,b\in\mathbb{Z}$，如果存在整数$c$，使得$ac=b$，则我们记作$a\mid b$，否则记作$a\nmid b$。（我们主要关注都是正数的情况，尽管这个定义在存在负数或零时也成立）</p>
<p>存在结论，如果$a\mid b$且$a\mid c$，那么$\forall X,Y\in\mathbb{Z}$，$s.t. a\mid(Xb+Yc)$。</p>
<p>如果$a\mid b$且$a&gt;0$，我们称$a$是$b$的<strong>除数</strong>(divisor)，如果$a\notin \{1,b\}$，则称$a$是$b$的<strong>非平凡除数</strong>(nontrivial divisor)或<strong>因子</strong>(factor)。如果一个大于一的正整数没有因子，则称其为<strong>素数</strong>(prime)，否则为<strong>合数</strong>(composite)。$1$既不是素数也不是合数。</p>
<p><strong>算数基本定理</strong>指出任何大于$1$的正整数可以唯一地写成素数的乘积，即$\forall N&gt;1,N= \prod_{i}p_i^{e_i}$。</p>
<p>我们熟悉的余数可以形式化表述为，令$a$是一个整数，$b$是一个正整数，一定存在唯一的整数$q,r$，使$a=qb+r$且$0\leq r&lt;b$。</p>
<p>对于给定整数的除法，我们可以在多项式事件内算出商和余数。在<strong>算法数论</strong>的背景下，整数输入通常用二进制表示，因此算法的运算时间是根据输入整数$N$的长度衡量的，记作$\parallel N \parallel =  \lfloor \log N\rfloor +1$。</p>
<p>我们称整数$a,b$的<strong>最大公约数</strong>(greatest common divisor)，记作$\gcd(a,b)$，是满足$c\mid a$和$c\mid b$的最大整数$c$。我们一般只考虑$a,b$都是正整数的情况。但是要注意$\gcd(0,b)=\gcd(b,0)=b$。若$p$为素数，则$\gcd(p,q)=1$或$gcd(p,q)=p$。如果$\gcd(a,b)=1$，则称$a,b$<strong>互质</strong>(relatively prime)。</p>
<p>对于$a,b$是正整数，那么存在整数$X,Y$使得$Xa+Yb=\gcd(a,b)$。</p>
<p>存在算法在多项式时间内计算$\gcd(a,b)$和对应的$X,Y$。</p>
<p>如果$c\mid ab$且$\gcd(a,c)=1$，则$c\mid b$。如果$p$是质数且$p\mid ab$，则$p\mid a$或$p\mid b$。</p>
<p>如果$a\mid N$且$b\mid N$且$\gcd(a,b)=1$，则$ab\mid N$。</p>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>我们用$a \bmod b$表示$a$被$b$整除的余数。</p>
<p>$a$和$b$同余表示为$a=b \bmod N$，等价于$N\mid (a-b)$。</p>
<p>同余是一个等价关系，其满足自反性、对称性、传递性。</p>
<p>同余也满足加法、减法和乘法的算数法则，如果$a=a’\bmod N,b=b’\bmod N$：</p>
<ul>
<li>$(a+b)=(a’+b’)\bmod N$</li>
<li>$ab=a’b’\bmod N$</li>
</ul>
<p>显然对于除法，同余是不可传递的。但是我们可以定义一种有意义的除法。</p>
<p>如果对于给定的整数$b$，存在一个整数$c$使得$bc=1\bmod N$，我们称$b$在模$N$的意义下是<strong>可逆的</strong>(invertible)，并称$c$是$b$在模$N$下的逆元。</p>
<p>$0$是不可逆的。如果$c$是$b$在模$N$下的逆元，那么$c\bmod N$也是。</p>
<p>当$b$是可逆的时候，我们记$b^{-1}$为唯一的在$\{1,\cdots,N-1\}$范围那内的乘法逆元。</p>
<p>当$b$是可逆时，我们定义除以$b$等价于乘$b^{-1}$，即$[\frac{a}{b}\bmod N]=[ab^{-1}\bmod N]$。</p>
<p>那么问题的关键就是哪些整数在模$N$下是可逆的。我们有以下结论：令$b\ge 1,N&gt;1$是整数，那么$b$在模$N$下是可逆的当且仅当$gcd(b,N)=1$。</p>
<p>要求$b$在模$N$下的逆元，先找出$X,Y$使得$bX+NY=1\bmod N$，然后计算$b^{-1}=[X\bmod N]$</p>
<p>当然，有关模的计算都是可以多项式时间内完成的。</p>
<ul>
<li>$[a+b\bmod N]$</li>
<li>$[a-b\bmod N]$</li>
<li>$[ab\bmod N]$</li>
<li>$[a^{-1}\bmod N]$</li>
<li>$[a^{k}\bmod N]$</li>
</ul>
<h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>令$\mathbb{G}$是一个集合，该集合上的一个二元运算就是一个将该集合中的两个元素映射到另一个元素的函数$\circ (\cdot,\cdot)$。我们写作$g\circ h$而非$\circ(g,h)$。</p>
<p>一个<strong>群</strong>(group)是一个集合$\mathbb{G}$和一个二元运算$\circ$，满足以下条件：</p>
<ul>
<li>闭包：$\forall g,h\in\mathbb{G},g\circ h\in\mathbb{G}$</li>
<li>存在单位元：$\exists e\in\mathbb{G},s.t.\forall g\in \mathbb{G},e\circ g=g\circ e=g$</li>
<li>存在逆元：$\forall g\in\mathbb{G},\exists h\in\mathbb{G},s.t.g\circ h=h\circ g=e$，我们称之为<strong>逆元</strong>(inverse)。</li>
<li>结合性：$\forall g,h,k\in\mathbb{G},(g\circ h)\circ k=g\circ (h\circ k)$</li>
</ul>
<p>一个群被称为<strong>阿贝尔群</strong>(abelian group)，当且仅当它还满足以下性质：</p>
<ul>
<li>交换性：$\forall g,h\in\mathbb{G},g\circ h=h\circ g$</li>
</ul>
<p>当$\mathbb{G}$为有限集合时，我们用$|\mathbb{G}|$来表示集合$\mathbb{G}$的阶(order)。</p>
<p>我们称$\mathbb{H}$是$\mathbb{G}$的子群(subgroup)，当且仅当$\mathbb{H}\subseteq \mathbb{G}$且$\mathbb{H}$在相同运算下也构成一个群。要验证是子群，我们需要检查：</p>
<ul>
<li>闭包</li>
<li>单位元</li>
<li>逆元</li>
<li>结合性和交换性无需单独验证，自动继承</li>
</ul>
<p>每个群$\mathbb{G}$都有两个<strong>平凡子群</strong>(trivial subgroup)：$\mathbb{G}$和$\{e\}$(单位元)。</p>
<p>若$\mathbb{H}\not = \mathbb{G}$，我们称之为<strong>真子群</strong>(strict subgroup)。</p>
<p>令$\mathbb{G}$是一个群，$a,b,c\in \mathbb{G}$，如果$ac=bc$，则$a=b$。如果$ac=a$，则$a$是该群的单位元。</p>
<h3 id="群的指数运算"><a href="#群的指数运算" class="headerlink" title="群的指数运算"></a>群的指数运算</h3><p>群中的元素可以多次计算：</p>
<ul>
<li>加法： $mg=g+g+\cdots+g$</li>
<li>乘法： $g^m=g\cdot g\cdot \cdots\cdot g$</li>
</ul>
<p>以下性质仍然成立：</p>
<ul>
<li>$g^m\cdot g^n=g^{m+n}$</li>
<li>$(g^m)^n=g^(mn)$</li>
</ul>
<p>如果该群是阿贝尔群，则还满足$g^n\cdot h^n=(gh)^n$。</p>
<p>这些也可以相应拓展到$m$为零或者负数的情况。</p>
<p>一般我们使用$0$表示加法中的单位元，$1$表示乘法中的单位元。</p>
<h3 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h3><p>令$\mathbb{G}$是一个有限群，其阶为$m$，那么$\forall g\in \mathbb{G},g^m=1$。</p>
<p>令$\mathbb{G}$是一个有限群，其阶为$m$，那么$\forall g\in \mathbb{G},x\in \mathbb{Z}$，我们有$g^x=g^{x\bmod m}$。</p>
<p>设$\mathbb{G}$是一个有限群，且$|G| = m &gt; 1$。设$e &gt; 0$是一个整数，并定义函数$f_e : G \to G$，其形式为$f_e(g) = g^e$。如果$\gcd(e, m) = 1$，那么$f_e$是一个<strong>置换</strong>（即一个双射）。此外，若$d = e^{-1} \bmod m$，则 $f_d$是$f_e$的<strong>逆函数</strong>。</p>
<p>这个构造在密码学应用中很有用。</p>
<h2 id="群-mathbb-Z-N"><a href="#群-mathbb-Z-N" class="headerlink" title="群$\mathbb{Z}^*_N$"></a>群$\mathbb{Z}^*_N$</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>$\mathbb{Z}^*_N=\{b\in\{1,\cdots,N-1\}\mid \gcd(b,N)=1\}$</p>
<h3 id="相关定理-1"><a href="#相关定理-1" class="headerlink" title="相关定理"></a>相关定理</h3><p>$\mathbb{Z}^*_N$在群运算是模$N$下的乘法，即$ab=[ab\bmod N]$，构成一个阿贝尔群。</p>
<p>定义$\phi(N)=|\mathbb{Z}^*_N|$</p>
<ul>
<li>当$N$为素数时，$\phi(N)=N-1$</li>
<li>当$N=pq$且$p,q$都是不同的质数时，$\phi(N)=(p-1)(q-1)$</li>
</ul>
<p>令$N=\prod_i p_i^{e^i}$，其中$p_i$都是质数，$e_i$都是正整数，那么$\phi(N)=\prod_i p_i^{e^i-1}(p_i-1)$。</p>
<p>取任意整数$N&gt;1$和$a\in \mathbb{Z}^*_N$，有$a^{\phi(N)}=1\bmod N$。如果$N=p$是素数且$a\in\{1,\cdots,p-1\}$，有$a^{p-1}=1\bmod p$。</p>
<p>设$N&gt;1$。对于大于零的整数$e$，定义$f_e:\mathbb{Z}^<em>_N\to \mathbb{Z}^</em>_N$，$f_e(x)=[x^e\bmod N]$。如果$e$和$\phi(N)$互质，则$f_e$是一个置换。如果$d=e^{-1}\bmod \phi(N)$，那么$f_d$是$f_e$的逆函数。</p>
<h2 id="同构和中国剩余定理"><a href="#同构和中国剩余定理" class="headerlink" title="同构和中国剩余定理"></a>同构和中国剩余定理</h2><h3 id="同构的定义"><a href="#同构的定义" class="headerlink" title="同构的定义"></a>同构的定义</h3><p>令$\mathbb{G},\mathbb{H}$是群，其操作符号分别为$\circ<em>{\mathbb{G}},\circ</em>{\mathbb{H}}$，我们称函数$f:\mathbb{G}\to\mathbb{H}$为<strong>同构</strong>(isomorphism)，当且仅当：</p>
<ul>
<li>$f$是一个双射</li>
<li>$\forall g,h\in\mathbb{G},f(g\circ<em>{\mathbb{G}}h)=f(g)\circ</em>{\mathbb{H}}f(h)$</li>
</ul>
<p>如果两个群之间存在这样一个函数，我们写作$\mathbb{G}\cong\mathbb{H}$</p>
<h3 id="中国剩余定理-Chinese-Remainder-Theorem-CRT"><a href="#中国剩余定理-Chinese-Remainder-Theorem-CRT" class="headerlink" title="中国剩余定理(Chinese Remainder Theorem, CRT)"></a>中国剩余定理(Chinese Remainder Theorem, CRT)</h3><p>令$N=pq$，其中$p,q$为互质的正整数，我们有以下结论：</p>
<script type="math/tex; mode=display">\mathbb{Z}_N\cong\mathbb{Z}_p\times\mathbb{Z}_q\text{ and }\mathbb{Z}^*_N\cong\mathbb{Z}^*_p\times\mathbb{Z}^*_q</script><p>令$f$是一个函数，定义为$f(x)=([x\bmod p],[x\bmod q])$，$f$是从$\mathbb{Z}_N$到$\mathbb{Z}_p\times\mathbb{Z}_q$的同构，同时$f$是从$\mathbb{Z}^<em>_N$到$\mathbb{Z}^</em>_p\times\mathbb{Z}^*_q$的同构。</p>
<h3 id="CRT应用举例"><a href="#CRT应用举例" class="headerlink" title="CRT应用举例"></a>CRT应用举例</h3><p>假设我们要计算$g=g_1\circ_G g_2$，其中$g_1,g_2\in\mathbb{G}$，要么直接计算，要么：</p>
<ol>
<li>计算$h_1=f(g_1),h2=f(g_2)$</li>
<li>计算$h=h_1\circ_H h_2$</li>
<li>计算$g=f^{-1}(h)$</li>
</ol>
<h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h4><p>计算$14\cdot 13\bmod 15$</p>
<ol>
<li>$(4,2)=f(14),(3,1)=f(13)$</li>
<li>$(4,2)\cdot (3,1)=([4\cdot 3\bmod 5],[2\cdot 1\bmod 3])=(2,2)$</li>
<li>$f^{-1}(2,2)=2$</li>
</ol>
<p>$14\cdot 13\bmod 15=2\bmod 15$</p>
<h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h4><p>计算$11^{53}\bmod 15$</p>
<ol>
<li>$f(11)=([11\bmod 5],[11\bmod 3])=(1,2)$</li>
<li>$(1,2)^{53}=([1^{53}\bmod 5],[(-1)^{53}\bmod 3])=(1,2)$</li>
<li>$f^{-1}(1,2)=11$</li>
</ol>
<p>$1^{53}\bmod 15=11\bmod 15$</p>
<h4 id="Example3"><a href="#Example3" class="headerlink" title="Example3"></a>Example3</h4><p>我们很容易求$f(x)=([x\bmod p],[x\bmod q])$，但如何求逆？</p>
<p>$(x_p,x_q)=x_p\cdot(1,0)++x_q\cdot(0,1)=x_p\cdot f^{-1}(1,0)+x_q\cdot f^{-1}(0,1)$</p>
<p>问题转变为求$1_p=f^{-1}(1,0)$和$1_q=f^{-1}(0,1)$</p>
<p>我们找$X,Y$使$Xp+Yq=1$</p>
<p>$1_q=[X_p\bmod N],1_p=[Yq\bmod N]$</p>
<h1 id="一些难问题假设"><a href="#一些难问题假设" class="headerlink" title="一些难问题假设"></a>一些难问题假设</h1><h2 id="Factoring"><a href="#Factoring" class="headerlink" title="Factoring"></a>Factoring</h2><p>令$GenModulus$是一个多项式时间算法，输入为$1^n$，输出为$(N,p,q)$，其中$N=pq$，$p,q$是长度为$n$比特的素数。该算法以可忽略的概率失败。</p>
<p>定义以下实验$Factor_{\mathcal{A},GenModulus}(n)$：</p>
<ol>
<li>运行$GenModulus(1^n)$，得到$(N,p,q)$</li>
<li>$\mathcal{A}$获得$N$，并输出$p’,q’$</li>
<li>如果$N=p’\cdot q’$，实验结果为$1$，否则为$0$</li>
</ol>
<p>因数分解是困难的，我们有以下结论，对于任何PPT算法$\mathcal{A}$，都存在$negl$使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E8%AE%BA/1.png?raw=true" alt="1"></p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>令$GenRSA$是一个多项式时间算法，输入为$1^n$，输出为$(N,e,d)$，其中$N$是两个长度为$n$比特的素数的乘积，并且$\gcd(e,\phi(N))=1,ed=1\bmod \phi(N)$。该算法以可忽略的概率失败。</p>
<p>定义以下实验$RSA-inv_{\mathcal{A},GenRSA}(n)$：</p>
<ol>
<li>运行$GenRSA(1^n)$，得到$(N,e,d)$</li>
<li>随机均匀选择$y\in\mathbb{Z}^*_N$</li>
<li>$\mathcal{A}$获得$N,e,y$，并输出$x\in\mathbb{Z}^*_N$</li>
<li>如果$x^e=y\bmod N$，实验结果为$1$，否则为$0$</li>
</ol>
<p>对于任何PPT算法$\mathcal{A}$，都存在$negl$使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E8%AE%BA/2.png?raw=true" alt="2"></p>
<h1 id="循环群中的密码学假设"><a href="#循环群中的密码学假设" class="headerlink" title="循环群中的密码学假设"></a>循环群中的密码学假设</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>令$\mathbb{G}$是一个阶为$m$的有限群，对于任意$g\in \mathbb{G}$，我们考虑以下集合：</p>
<script type="math/tex; mode=display">< g >=\{g_0,g_1,\cdots\}</script><p>根据之前的结论，我们有$g^m=1$，现在我们令$i$为最小的正整数使$g^i=1$，所以</p>
<script type="math/tex; mode=display">< g >=\{ g^0,g^1,\cdots,g^{i-1}\}</script><p>不难证明$&lt; g &gt;$是$\mathbb{G}$的子群。我们称$g$是$\mathbb{G}$的生成元(generator)。</p>
<p>我们定义在有限群$\mathbb{G}$中的一个元素$g$的阶是$i$，$g^i=1$。对于任意$g\in \mathbb{G}$，有$g^x=g^{[x\bmod i]}$。有以下推论：$g^x=g^y$当且仅当$x=y\bmod i$。<br>令$\mathbb{G}$是一个有限群，阶为$m$，对于$g\in\mathbb{G}$，其阶为$i$，我们有$i\mid m$。</p>
<p>令$\mathbb{G}$是一个有限群，阶为$m$是一个质数，我们称之为循环群(cuclic)，其中除了单位元之外的所有元素都是$\mathbb{G}$的生成元。</p>
<p>如果$p$是一个质数，那么$\mathbb{Z}_P^*$是一个阶为$p-1$的循环群。</p>
<h2 id="难问题假设"><a href="#难问题假设" class="headerlink" title="难问题假设"></a>难问题假设</h2><p>现在引入一些针对循环群的计算问题，这些问题被视为是难解的。</p>
<h3 id="The-discrete-logarithm-problem-and-assumption"><a href="#The-discrete-logarithm-problem-and-assumption" class="headerlink" title="The discrete-logarithm problem and assumption"></a>The discrete-logarithm problem and assumption</h3><p>离散对数问题是计算循环群中均匀选择的元素的离散对数，可以用以下实验来描述$DLog_{\mathcal{A},\mathcal{G}}$，其中$\mathcal{G}$是一个群生成算法：</p>
<ol>
<li>运行$\mathcal{G}(1^n)$，得到$(\mathbb{G},q,g)$，其中$\mathbb{G}$是一个循环群，阶为$q$是一个素数，$g$是$\mathbb{G}$的生成元</li>
<li>随机均匀选择$h\in \mathbb{G}$</li>
<li>$\mathcal{A}$获得$(\mathbb{G},q,g,h)$，并输出$x\in\mathbb{Z}_q$</li>
<li>如果$g^x=h$，则实验结果为1，否则为0</li>
</ol>
<p>这个问题目前被视为难问题，也就是说，对于任何PPT算法$\mathcal{A}$，都存在$negl$使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E8%AE%BA/3.png?raw=true" alt="3"></p>
<h3 id="The-Diffie-Hellman-problems-and-assumptions"><a href="#The-Diffie-Hellman-problems-and-assumptions" class="headerlink" title="The Diffie-Hellman problems and assumptions"></a>The Diffie-Hellman problems and assumptions</h3><p>这包含两个问题：</p>
<ul>
<li>CDH problem：给定$g,g^x,g^y$，计算$g^{xy}$</li>
<li>DDH problem：给定$g,g^x,g^y,g^{xy}$，区别$g^xy$和任意选择的群中元素$g^z$</li>
</ul>
<p>目前这两个问题被视为难问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A1%AC%E6%A0%B8%E8%B0%93%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A1%AC%E6%A0%B8%E8%B0%93%E8%AF%8D/" class="post-title-link" itemprop="url">【七】单向函数与硬核谓词</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-16 18:03:40" itemprop="dateCreated datePublished" datetime="2024-12-16T18:03:40+08:00">2024-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-17 16:31:43" itemprop="dateModified" datetime="2024-12-17T16:31:43+08:00">2024-12-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第八章Theoretical Constructions of Symmetric-Key Primitives</p>
<p>我们已经引入了伪随机性的概念，并且定义了一些基础的密码学原语，包括伪随机生成器、伪随机函数和伪随机置换。在本章中，我们正式引入单向函数的概念——一种从非正式上讲“易于计算但难以反向计算”的函数——并展示如何在仅假设单向函数存在的情况下构造伪随机生成器、伪随机函数和伪随机置换。</p>
<h1 id="单向函数-One-Way-Functions"><a href="#单向函数-One-Way-Functions" class="headerlink" title="单向函数 One-Way Functions"></a>单向函数 One-Way Functions</h1><p>在本节中，我们将正式定义单向函数，并简要讨论一些被认为符合该定义的函数。接下来，我们引入硬核谓词（hard-core predicates）的概念，它可以被视为封装了单向函数反向计算的难度，并将在随后的构造中被广泛使用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单向函数$f$，是计算简单，但是难以反向计算的函数。</p>
<p>计算简单很容易形式化定义：即$f$是一个可以在多项式时间内计算的函数。</p>
<p>难以反向计算可以通过以下实验进行定义：<br>The inverting experiment $Invert_{\mathcal{A},f}(n)$</p>
<ol>
<li>均匀选取定义域中的x，并计算$f(x)$。</li>
<li>$\mathcal{A}$接受输入$1^n$和$y$，并输出$x’$。（这里$1^n$只是为了保证运行在关于安全参数n的多项式时间内）</li>
<li>若$y=f(x’)$，则实验结果为1，否则为0。</li>
</ol>
<p>注意，这里的实验并不要求必须满足$x=x’$，只要$y=f(x’)$即可。</p>
<p><strong>定义8.1</strong><br>$f$是一个单向函数，当且仅当满足以下两个条件：</p>
<ol>
<li>存在一个多项式时间算法$M_f$来计算$f$，使$M_f(x)=f(x)$。</li>
<li>对于任意多项式时间算法$\mathcal{A}$，都存在negl使<br>$Pr[Invert_{\mathcal{A},f}(n)=1]\leq negl(n)$</li>
</ol>
<p>条件2还可以用以下形式表示：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/1.png?raw=true" alt="1"></p>
<p>一个不是单向的函数并不意味着它在所有情况下（甚至“大多数情况下”）都容易求逆。</p>
<p>任何单向函数都可以通过指数时间的暴力搜索进行求逆。换句话说，这涉及一个原则上可以解决的问题，但假定它难以高效解决。</p>
<p>当一个函数始终满足$|f(x)|=|x|$时，我们称该函数为length-preserving的，如果在此基础上这个函数还是单射函数，那么称这个函数为one-way permutation的（单向置换）。</p>
<p>上述单向函数和置换的定义方便地考虑了一个在无限定义域和值域上的单一函数。然而，大多数候选单向函数和置换并不完全符合这一框架。相反，它们通常是通过某种算法生成一组参数。</p>
<p><strong>定义8.2</strong><br>$\prod=(Gen,Samp,f)$是一个概率多项式函数三元组，当其符合下面条件时被称为一个function family：</p>
<ol>
<li>Gen：输入$1^n$，输出参数$I$，其中$|I|\ge n$。每个$I$对应定义了集合$\mathcal{D}_I$和$\mathcal{R}_I$，分别是函数$f_I$的定义域和值域。</li>
<li>Samp：输入$I$，输出一个随机均匀分布的元素$x\in\mathcal{D}_I$。</li>
<li>f：一个确定性的算法，输入$I$和$x\in\mathcal{D}_I$，输出$y=f_I(x)\in\mathcal{R}_I$。</li>
</ol>
<p>当对于任意$I$，$\mathcal{D}_I=\mathcal{R}_I$且$f_I(x)$是双射时，我们称$\prod$是一个permutation family。</p>
<p>我们现在可以对应更改上述实验<br>The inverting experiment $Invert_{\mathcal{A},\prod}(n)$</p>
<ol>
<li>运行$Gen(1^n)$，并得到参数$I$。然后运行$Samp(I)$，并得到一个随机均匀分布的元素$x\in\mathcal{D}_I$。最后计算$y=f_I(x)$。</li>
<li>$\mathcal{A}$接受输入$I$和$y$，并输出$x’$。</li>
<li>若$y=f_I(x’)$，则实验结果为1，否则为0。</li>
</ol>
<p><strong>定义8.3</strong><br>一个function/permutation family $\prod$是one-way的，如果对对于任意多项式时间算法$\mathcal{A}$，都存在negl使<br>$Pr[Invert_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<h2 id="潜在的单向函数"><a href="#潜在的单向函数" class="headerlink" title="潜在的单向函数"></a>潜在的单向函数</h2><h3 id="Candidate-1"><a href="#Candidate-1" class="headerlink" title="Candidate 1"></a>Candidate 1</h3><p>我们尚且不能无条件的证明单向函数的存在，所以我们目前必须假设他们的存在，这基于以下事实：一些被广泛研究的问题目前尚未能发现任何多项式时间算法能解决，比如大整数的质因数分解。这个问题难就难在<strong>将两个数相乘得到它们的积很容易，但给定一个数找到它的因数却非常困难</strong>。</p>
<p>这给了我们灵感，我们定义$f_{mult}(x,y)=x\cdot y$，限制x，y的定义域为等长的素数。</p>
<h3 id="Candidate-2"><a href="#Candidate-2" class="headerlink" title="Candidate 2"></a>Candidate 2</h3><p>这个单向函数的构造依赖于子集求和问题，其定义为<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/2.png?raw=true" alt="2"><br>其中$x_i$是一个n比特的字符串，解释为一个整数，$J$是一个n比特字符串，表示指定了子集$\{1,\cdots,n\}$的元素。</p>
<p>这个函数的逆函数是一个NP-complete问题。</p>
<h3 id="Candidate-3"><a href="#Candidate-3" class="headerlink" title="Candidate 3"></a>Candidate 3</h3><p>现在展示一个a family of permutations是单向的。其中Gen是一个概率多项式时间算法，输出一个n比特素数$p$，以及一个特殊元素$g\in \{2,\cdots,p-1\}$。Samp输出一个均匀分布的整数$x\in \{1,\cdots,p-1\}$。最后，定义$f_{p,g}(x)=g^x \bmod p$</p>
<p>可以证明这个函数是单射，因此是一个置换。反转这个函数的困难基于离散对数问题的假设。</p>
<h2 id="硬核谓词-Hard-core-Predicates"><a href="#硬核谓词-Hard-core-Predicates" class="headerlink" title="硬核谓词 Hard-core Predicates"></a>硬核谓词 Hard-core Predicates</h2><p>尽管根据定义单向函数很难反转，这并不意味着我们不能得到任何有用的信息。</p>
<p>举个例子，假设$g$是一个单向函数，我们定义<br>$f(x_1,x_2)=(x_1,g(x_2))$，其中$|x_1|=|x_2|$。<br>很容易证明$f$是一个单向函数，尽管泄露了一半的输入信息。</p>
<p>对于我们的应用，我们需要识别某些关于$x$的特定信息，但是这些信息被$f(x)$隐藏。这促使了<strong>硬核谓词</strong>的概念。</p>
<p><strong>定义8.4</strong><br>一个函数$hc:\{0,1\}^*\rightarrow\{0,1\}$是函数$f$的硬核谓词，当且仅当$hc$可以在多项式时间内计算，并且对于任何的多项式时间算法$\mathcal{A}$，都存在negl使<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/3.png?raw=true" alt="3"></p>
<p>注意，这里的硬核谓词是一个布尔值函数。同时，上述定义并不要求$f$是一个单向函数。但是如果$f$是一个置换函数，那么除非他是单向的，否则没有硬核谓词。</p>
<p>硬核谓词不能简单的构造，这里给出定理，对于任何固定的谓词$hc$，总存在一个单向函数，使这个谓词不是这个单向函数的硬核谓词。</p>
<p>当然，也存在简单的硬核谓词，比如，假设$f$是一个函数，其输出就是丢弃最后的一个比特。那么$hc(x)=x_n$就是$f$的一个硬核谓词。这里$f$是不是单向函数无关紧要。但是，这种简单的硬核谓词在我们后续的构造工作中是没有作用的。</p>
<h1 id="从单向函数到为随机性"><a href="#从单向函数到为随机性" class="headerlink" title="从单向函数到为随机性"></a>从单向函数到为随机性</h1><p>这节我们展示如何从单向函数构造伪随机生成器，伪随机函数和置换。</p>
<p>首先，我们说明任何是否任何一个单向函数都有一个硬核谓词，这仍然是一个开放性问题。我们可以展示一个弱一些的结论。</p>
<p><strong>定理8.5(Goldreich–Levin theorem)</strong><br>假设存在一个单向函数$f$，那么一定存在另一个单向函数$g$和$g$的硬核谓词$gl$。</p>
<p>我们可以通过以下方式进行构造：<br>令$g(x,r)=(f(x),r)$，其中$|x|=|r|$。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/4.png?raw=true" alt="4"></p>
<p>下一步我们展示如何从一个单项置换的硬核谓词构造一个伪随机函数。</p>
<p><strong>定理8.6</strong><br>假设存在一个单向置换$f$，其硬核谓词为$hc$，那么我们可以构造以下的伪随机数生成器，其中expansion factor是$l(n)=n+1$。<br>$G(s)=f(s)||hc(s)$</p>
<p>直觉上看，因为输入是均匀的，所以置换后看起来也是均匀的，最后连接一个看起来是随机的$hc(s)$，所以整体上看起来是随机的。</p>
<p>当然，只能拓展一位的伪随机数生成器用处限制很大，但是幸运的是，我们可以获得任何多项式扩展因子的伪随机生成器。</p>
<p><strong>定理8.7</strong><br>如果存在一个expansion factor是$l(n)=n+1$的伪随机数生成器，那么对于任意的多项式$poly$，都存在expansion factor是l(n)=poly(n)$的伪随机数生成器。</p>
<p>因此，我们得出结论：可以从任何单向置换构造具有任意（多项式）扩展因子的伪随机生成器。</p>
<p>伪随机生成器对于构造 EAV 安全的私钥加密方案是足够的。然而，对于 CPA 安全的私钥加密（更不用说消息认证码了），我们依赖于伪随机函数。以下结果表明，后者可以从前者构造出来。</p>
<p><strong>定理8.8</strong><br>如果存在一个expansion factor是$l(n)=2n$的伪随机数生成器，则存在一个伪随机函数。</p>
<p><strong>定理8.9</strong><br>如果存在一个伪随机函数，则存在一个伪随机置换。</p>
<p>综合上述定理，我们发现，只要有单项置换函数，我们就可以构造出</p>
<ul>
<li>存在任意扩展因子的伪随机生成器、伪随机函数和强伪随机置换。</li>
<li>存在认证加密方案和安全的消息认证码。</li>
</ul>
<h1 id="来自单向函数的硬核谓词"><a href="#来自单向函数的硬核谓词" class="headerlink" title="来自单向函数的硬核谓词"></a>来自单向函数的硬核谓词</h1><p>我们在这一节证明<strong>定理8.5</strong>。<br>略</p>
<h1 id="构造伪随机数生成器"><a href="#构造伪随机数生成器" class="headerlink" title="构造伪随机数生成器"></a>构造伪随机数生成器</h1><p>我们首先展示如何在假设单向置换存在的情况下，构造将输入扩展一个比特的伪随机生成器。然后，我们再展示如何扩展这一构造，以获得任意多项式扩展因子。</p>
<h2 id="最小扩展因子的伪随机数生成器"><a href="#最小扩展因子的伪随机数生成器" class="headerlink" title="最小扩展因子的伪随机数生成器"></a>最小扩展因子的伪随机数生成器</h2><p><strong>定理8.18</strong><br>令$f$为一个单向置换，其硬核谓词为$hc$，那么我们可以构造以下的伪随机数生成器，其中expansion factor是$l(n)=n+1$。<br>$G(s)=f(s)||hc(s)$</p>
<p>证明如下：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/6.png?raw=true" alt="6"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/5.png?raw=true" alt="5"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" class="post-title-link" itemprop="url">【六】哈希函数及其应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-16 15:37:32" itemprop="dateCreated datePublished" datetime="2024-12-16T15:37:32+08:00">2024-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-17 11:47:18" itemprop="dateModified" datetime="2024-12-17T11:47:18+08:00">2024-12-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第六章Hash Functions and Applications</p>
<p>我们现在关注一个具有广泛应用的加密原语：加密哈希函数。在最基本的层面上，哈希函数 $H$提供了一种确定性的方法，将较长的输入字符串映射为较短的输出字符串，通常称为digest。主要的要求是：找到 H 的碰撞（即两个不同的输入产生相同的digest）应该是不可行的。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>哈希函数是一类将任意长度的输入压缩为固定长度输出的函数。非加密哈希函数的经典用途是在数据结构中，它们可以用来构建哈希表，从而在存储一组元素时实现$O(1)$的查找。具体来说，如果哈希函数$H$的输出范围大小为$N$，那么元素x被存储在表格的第$H(x)$行。</p>
<p>一个良好的哈希函数要尽可能的减少碰撞(collision)。抗碰撞(Collision-resistant)哈希函数的目标也是避免碰撞，但是在数据结构的应用中，较少碰撞只是优化的要求，但是在密码学背景下，避免碰撞是一个严格的要求，因为攻击者可能会故意构造发生碰撞的值来进行攻击。所以设计抗碰撞哈希函数的难度要高于设计一般的哈希函数。</p>
<h2 id="Collision-Resistance"><a href="#Collision-Resistance" class="headerlink" title="Collision Resistance"></a>Collision Resistance</h2><p>形式上，$H$是一个双输入函数，接受一个密钥$s$和一个字符串$x$，输出$H_s(x)$。</p>
<p>这里的密钥和我们过去考虑的密钥有所不同，在过去的密钥我们希望保密，但是这里哈希函数中攻击者可能知道密钥，在这个前提下，我们希望哈希函数还具有抗碰撞性。</p>
<p><strong>DEFINITION 6.1</strong><br>一个哈希函数由一对概率多项式算法组成。</p>
<ul>
<li>$Gen$： 是一个概率算法，输出密钥$s$</li>
<li>$H$： 是一个确定性算法，接受一个密钥$s$和一个字符串$x$，输出$H_s(x)$，长度为$l(n)$</li>
</ul>
<p>如果H只接受固定长度的字符串输入，我们称哈希函数为fixed-length，H为compression function。显然这里输出的长度必须小于输入长度。</p>
<p>下面介绍攻击实验The collission-finding experiment $Hash-coll_{\mathcal{A},\mathcal{H}}(n)$:</p>
<ol>
<li>生成密钥s</li>
<li>攻击者接受s，输出$x,x’$。</li>
<li>如果这两个输出产生碰撞，则实验结果为1，反之为0</li>
</ol>
<p>$DEFINITON 6.2$<br>一个哈希函数是Collision Resistant当且仅当<br>$Pr[Hash-coll_{\mathcal{A},\mathcal{H}}(n) = 1]\leq negl(n)$</p>
<p><strong>无密钥的哈希函数</strong><br>实际上使用的哈希函数通常是没有密钥的，当然，这在理论上来看，总存在一个常数事件算法，直接输入碰撞对。</p>
<p>当然，现实世界里，找到碰撞对在计算上是很困难的。</p>
<h2 id="弱一些的安全定义"><a href="#弱一些的安全定义" class="headerlink" title="弱一些的安全定义"></a>弱一些的安全定义</h2><ul>
<li>Second-preimage resistance<br>对于一个哈希函数，如果给定$s$和$x$，找不到另一个能碰撞的字符串。</li>
<li>Preimage resistance<br>对于一个哈希函数，如果给定$s$和$H_s(x)$，找不到另一个能碰撞的字符串。</li>
</ul>
<p>coliision resistant $\Rightarrow$ second-preimage resistance $\Rightarrow$ preimage resistance</p>
<h1 id="Merkle–Damgard变换"><a href="#Merkle–Damgard变换" class="headerlink" title="Merkle–Damgård变换"></a>Merkle–Damgård变换</h1><p>许多应用需要“完全成熟”的抗碰撞哈希函数，这种哈希函数能够处理非常长的输入，甚至是任意长度的输入。然而，构造固定长度的哈希函数（即压缩函数）更为容易——这些函数只接受“短”的输入。幸运的是，Merkle–Damgård变换使我们可以将后者转换为前者。这种哈希函数域扩展的方法在实践中被频繁使用，例如MD5和SHA系列哈希函数。</p>
<p>假设已经存在压缩函数$(Gen,h)$，能接受长度大于2n的输入并输出长度为n的输出。那么我们可以通过下面的变换得到一个能处理任意长度输入的哈希函数<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/1.png?raw=true" alt="1"></p>
<p><strong>THEOREM 6.4</strong><br>如果$(Gen,h)$抗碰撞，那么构造的$(Gen,H)$也抗碰撞</p>
<p>证明如下：//TODO</p>
<h1 id="应用哈希函数进行消息认证"><a href="#应用哈希函数进行消息认证" class="headerlink" title="应用哈希函数进行消息认证"></a>应用哈希函数进行消息认证</h1><p>我们之前已经讨论了几种针对任意长度消息的消息认证码（MAC）的构造。在本节中，我们将看到另一种方法，该方法依赖于抗碰撞哈希函数。随后，我们会介绍一种被标准化并广泛使用的方案，称为 HMAC（哈希消息认证码），它可以看作是这种方法的具体实现。</p>
<h2 id="Hash-and-MAC"><a href="#Hash-and-MAC" class="headerlink" title="Hash-and-MAC"></a>Hash-and-MAC</h2><p>抗碰撞哈希函数可以自然地用于消息认证码（MAC）的域扩展。例如，假设我们有一个固定长度的 MAC，它可以处理长度为 l(n)-比特的消息，并且有一个输出长度为 l(n)-比特的抗碰撞哈希函数。那么我们可以通过对消息 m 进行哈希计算，然后使用 MAC 对哈希值进行认证，从而对任意长度的消息 m 进行认证。（参见构造 6.5。）</p>
<p>直观上，这种方法是安全的，因为：</p>
<ul>
<li>MAC 的安全性 确保攻击者无法认证任何新的哈希值。</li>
<li>抗碰撞性 确保攻击者无法找到与已使用哈希值相同的哈希的新消息。</li>
</ul>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/2.png?raw=true" alt="2"></p>
<p><strong>THEOREM 6.6</strong><br>如果$\prod$是一个secure的MAC，$\mathcal{H}$是一个抗碰撞的哈希函数，那么上述构造是一个secure MAC</p>
<p>证明如下：//TODO</p>
<h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p>在原则上，可以通过将任意抗碰撞哈希函数与第4.5节中的固定长度消息认证码（MAC）相结合，来实现上一节提到的“哈希并认证”（hash-and-MAC）方法。然而，这种方法在实际中有至少两个缺点：</p>
<ul>
<li>需要实现两种密码学原语</li>
<li>哈希函数输出长度与分组密码分组长度之间的不匹配</li>
</ul>
<p>HMAC 的设计克服了哈希函数和分组密码之间的不匹配问题，同时通过高效的构造支持任意长度的消息。具体地，HMAC 使用了两次调用哈希函数的过程，同时结合了内置的密钥与填充操作，以确保安全性。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/3.png?raw=true" alt="3"></p>
<p><strong>THEOREM 6.8</strong><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/hash/4.png?raw=true" alt="4"></p>
<p>证明如下：//TODO</p>
<h1 id="对哈希函数的攻击"><a href="#对哈希函数的攻击" class="headerlink" title="对哈希函数的攻击"></a>对哈希函数的攻击</h1><h2 id="Birthday-Attacks"><a href="#Birthday-Attacks" class="headerlink" title="Birthday Attacks"></a>Birthday Attacks</h2><p>最简单的攻击是在输入空间内穷举，但是复杂度高达$2^{n}$。</p>
<p>现在考虑一个问题，一个房间里有q个人，那么存在两个人生日相同的概率是多少。<br>我们不难发现，当$q\approx 2^{l/2}$时，碰撞的概率接近0.5。</p>
<p>所以，攻击者只需要尝试$2^{l/2}$次，就能显著提高找到碰撞对的概率。</p>
<p>所以，要达到相同的安全水平，哈希函数输出的长度应该是2n。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/CCA%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/CCA%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">【五】CCA安全和认证加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-16 13:00:28 / 修改时间：16:59:51" itemprop="dateCreated datePublished" datetime="2024-12-16T13:00:28+08:00">2024-12-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第五章CCA-Security and Authenticated Encryption</p>
<p>我们已经讨论过了两种攻击者，一种是监听信道，一种是纂改通信，对应的我们提出了保密性和完整性的目标。现在我们要讨论存在主动攻击者时的保密性问题，以及如何构建同时实现保密性和完整性的加密方案。</p>
<h1 id="选择密文攻击和CCA安全"><a href="#选择密文攻击和CCA安全" class="headerlink" title="选择密文攻击和CCA安全"></a>选择密文攻击和CCA安全</h1><p>我们上一章中考虑攻击者可以纂改信道，那么显然，攻击者可以有以下的手段，使通信接收方解密攻击者生成的密文，并且攻击者还能知道解密后的消息。</p>
<h2 id="Padding-Oracle-Attacks"><a href="#Padding-Oracle-Attacks" class="headerlink" title="Padding-Oracle Attacks"></a>Padding-Oracle Attacks</h2><p>现在考虑一种真实情况，客户端使用CBC模式加密向服务器发送消息，假设攻击者能够冒充客户端，向服务器发送其选择的密文，那么攻击者能获得服务器的相关反应来推断密文的有效性（比如服务器解密失败就会要求重传）。</p>
<p>在CBC加密模式下，我们要求消息长度为底层分组密码长度的整数倍，如果消息长度不满足，则需要进行填充。而填充也需要遵循一定的方案，服务器会解密并验证是否遵循正确的填充方案。</p>
<p>这意味着服务器会向攻击者提供一个填充查询机，来判断填充是否正确。并且攻击者是有方法根据这个信息来恢复密文对应的明文的。</p>
<h2 id="CCA-Security-的定义"><a href="#CCA-Security-的定义" class="headerlink" title="CCA-Security 的定义"></a>CCA-Security 的定义</h2><p>下面来形式化定义一下CCA安全。<br>我们仿照之前的实验方案，给出CCA不可区分实验：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/1.png?raw=true" alt="1"></p>
<p>注意这里，加密算法应该是概率性的，否则很容易通过加密查询来获取正确结果。</p>
<p><strong>DEFINITION 5.1</strong><br>一个加密方案是CCA安全的当且仅当</p>
<script type="math/tex; mode=display">Pr[PrivK^{cca}_{\mathcal{A},\prod}(n)=1]\leq 1/2+negl(n)</script><p>由此也可以引申出，如果一个方案是CCA安全的，在多密文不可区分实验中仍然是CCA安全的。</p>
<p>以上实验中给了攻击者很大的能力，比如能知道解密后的明文，但是现实中知道的信息不一定有这么多，我们这里在定义上希望攻击者足够强。</p>
<p>到目前为止，我们研究的大多数方案都不是CCA安全的。攻击者可以通过比特翻转等攻击方式来打破不可区分性。</p>
<h1 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h1><p>迄今为止，我们分别探讨了如何通过加密实现机密性，以及通过消息认证码实现完整性。下面定义的认证加密（Authenticated Encryption）旨在同时实现这两个目标。在对称密钥环境中，默认同时确保机密性和完整性是最佳实践。事实上，在许多需要机密性的应用中，完整性通常也是至关重要的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="不可伪造实验"><a href="#不可伪造实验" class="headerlink" title="不可伪造实验"></a>不可伪造实验</h3><p>考虑以下实验：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/2.png?raw=true" alt="2"><br>简单的说就是要求攻击者不能伪造一个有效的密文。</p>
<p><strong>DEFINITION 5.2</strong><br>一个方案是不可伪造的(unforgeble)，当且仅当对于任何多项式概率算法攻击者A，都有</p>
<script type="math/tex; mode=display">Pr[Enc-Forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)</script><h3 id="AE的定义"><a href="#AE的定义" class="headerlink" title="AE的定义"></a>AE的定义</h3><p><strong>DEFINITION 5.3</strong><br>一个方案是AE(authenticated encryption)当且仅当这个方案是CCA安全的并且是不可伪造的。</p>
<p>我们也可以通过一个单一的实验来定义AE加密方案。<br>假设现在攻击者可以遇到以下两种不同的情况：</p>
<ol>
<li>攻击者被提供了一个加密oracle和一个解密oracle的访问权限。</li>
<li>攻击者获得的是一个加密0字符串的oracle。一个始终返回错误符号$\perp $的解密oracle。</li>
</ol>
<p>如果攻击者不能区分这两种场景，这说明攻击者在真实世界中生成的新密文都将无效同时攻击者无法区分真实的加密。</p>
<p>该实验的定义如下：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/3.png?raw=true" alt="3"></p>
<p><strong>DEFINITION 5.4</strong><br>一个方案是AE-secure，当且仅当对于任何多项式概率算法攻击者A，都有<br>$Pr[PrivK^{ae}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)$</p>
<p><strong>THEROREM 5.5</strong><br>定义5.3和定义5.4是等价的。</p>
<p>带有关联数据的认证加密：在许多情况下，可能只有部分内容需要加密，部分内容只要保证完整性即可。虽然对整体消息进行AE方案加密可以满足要求，但是效率较低，现实中，支持关联数据的认证加密方案在文献中被称为带有关联数据的认证加密（Authenticated Encryption with Associated Data，简称 AEAD）。</p>
<h2 id="CCA安全-vs-认证加密"><a href="#CCA安全-vs-认证加密" class="headerlink" title="CCA安全 vs 认证加密"></a>CCA安全 vs 认证加密</h2><p>我们根据定义可以直接得出任何认证加密（AE）方案也都是选择密文攻击安全（CCA-secure）的。然而，反之则不成立。</p>
<p>在现实世界中，确实存在情景只需要CCA安全而不关注认证加密。尽管如此，在存在活跃攻击者的情况下，大多数对称密钥加密的应用确实需要完整性保护。幸运的是，大多数自然构造的 CCA 安全加密方案通常也满足更强的认证加密定义。从这个角度来看，没有理由使用那些既是 CCA 安全但不是认证加密的方案，因为没有任何此类方案在效率上比认证加密方案更优。</p>
<h1 id="认证加密方案"><a href="#认证加密方案" class="headerlink" title="认证加密方案"></a>认证加密方案</h1><h2 id="一般构造"><a href="#一般构造" class="headerlink" title="一般构造"></a>一般构造</h2><p>直觉上认为将一个CPA安全的加密方案和一个安全的MAC方案结合就能得到一个AE方案，但是事实上不是这样的。</p>
<p>假设：</p>
<ol>
<li>$\prod_{E}=(Enc,Dec)$是一个CPA安全的加密方案</li>
<li>$\prod_{M}=(MAC,Verify)$是一个安全的MAC方案</li>
<li>两种方案使用独立的密钥$k_E$和$k_M$</li>
</ol>
<p>下面是常见的三种构造方式。</p>
<h3 id="Encrypt-and-authenticate"><a href="#Encrypt-and-authenticate" class="headerlink" title="Encrypt-and-authenticate"></a>Encrypt-and-authenticate</h3><p>$c\leftarrow Enc(k_E,m),t\leftarrow MAC(k_M,m)$，密文为$&lt; c , t &gt;$<br>因为它未能将保密性和完整性紧密结合，导致标签可能泄露关于消息的信息，确定性MAC可能使攻击者意识到消息的重复发送等问题。</p>
<h3 id="Authenticate-then-encrypt"><a href="#Authenticate-then-encrypt" class="headerlink" title="Authenticate-then-encrypt"></a>Authenticate-then-encrypt</h3><p>$t\leftarrow MAC(k_M,m),c\leftarrow Enc(k_E,m||t)$，密文为$c$<br>一般会用CBC模式进行加密，那么填充部分就可以用来实现攻击，因为不同的错误类型会提供有效信息。一个很直接的解决方案是使错误信息都返回同一种。但是这在现实中并不有效，不利于调试等等问题。</p>
<h3 id="Encrypt-then-authenticate"><a href="#Encrypt-then-authenticate" class="headerlink" title="Encrypt-then-authenticate"></a>Encrypt-then-authenticate</h3><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>$c\leftarrow Enc(k_E,m),t\leftarrow MAC(k_M,c)$，密文为$&lt; c , t &gt;$<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/4.png?raw=true" alt="4"><br>直观上这样的构造很安全。</p>
<p>如果攻击者提交的密文$ ⟨ c ,t ⟩ $不来自加密 oracle，认证标签 t 将无法通过验证，解密 oracle 会返回错误。</p>
<p>如果攻击者提交的密文确实来自加密 oracle，那么攻击者已经知道该密文的解密结果。</p>
<p>这种设计使解密 oracle 对攻击者无用，从而避免了选择密文攻击（CCA）的潜在威胁。</p>
<p>在解密之前，首先验证标签 t。如果标签验证失败，解密算法立即返回错误，而不会尝试解密密文 c。</p>
<p>这种设计避免了与 Authenticate-then-Encrypt 方法类似的填充 Oracle 攻击，因为解密过程不会执行，攻击者无法通过错误信息获知关于明文的任何信息。</p>
<h4 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h4><p><strong>THEROREM 5.7</strong><br>以上构造是AE安全的。</p>
<p>我们的目标是证明这个方案不可伪造且CCA安全。令$\mathcal{A}$是一个PPT攻击者</p>
<p>我们令$VaildQuery$代表事件：攻击者成功向$Dec(\cdot)$提交了一个新的有效密文。我们要证明$Pr[ValidQuery]$是可忽略的。</p>
<p>如果事件$VaildQuery$发生，那么攻击者成功通过了$Mac-sforge$实验，令$q(\cdot)$代表攻击者向解密查询机查询次数的多项式上界。现在考虑对于$\prod_M$的攻击者$\mathcal{A}_M$:</p>
<ol>
<li>$\mathcal{A}<em>M$获得查询权限$Mac</em>{k_M}(\cdot)$</li>
<li>均匀选取$k_E\in \{0,1\}^n,i\in \{1,\cdots,q(n)\}$</li>
<li>运行$\mathcal{A}(1^n)$，当$\mathcal{A}$对消息$m$有加密查询时<ol>
<li>计算$c\leftarrow Enc_{k_E}(m)$</li>
<li>查询$t:=Mac_{k_M}(c)$，返回$&lt; c,t &gt;$给$\mathcal{A}$</li>
</ol>
</li>
<li>当$\mathcal{A}$对$&lt; c,t &gt;$有解密查询时，如果这是第$i$次加密查询，输$(c,t)$并停止，否则：<ol>
<li>如果$&lt; c,t &gt;$，是之前加密查询的结果，则返回对应的$m$</li>
<li>否则返回$\perp$</li>
</ol>
</li>
</ol>
<p>本质上，$\mathcal{A}<em>M$是在猜测$\mathcal{A}$的第$i$次加密查询是一次新的有效的查询。所以如果$\mathcal{A}_M$正确猜测了$VaildQuery$的第一个索引$i$，就可以成功通过$Mac-sforge</em>{\mathcal{A}_M,\prod_M}(n)$。这个成功猜测的概率是$\frac{1}{q(n)}$。</p>
<p>而根据$\prod_M$是一个强安全MAC，我们有：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/5.png?raw=true" alt="5"></p>
<p>综上我们证明了这是不可伪造的。下面我们继续证明该方案是CCA安全。</p>
<p>首先我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/6.png?raw=true" alt="6"></p>
<p>而不等式右边的第一项已经证明是可忽略的，现在我们的目标是证明</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/7.png?raw=true" alt="7"></p>
<p>现在我们构造$\mathcal{A}<em>E$来攻击$\prod_E$，其中$\mathcal{A}_E$有查询$Enc</em>{k_E}(\cdot)$的权限：</p>
<ol>
<li>均匀选取$k_E\in \{0,1\}^n$</li>
<li>运行$\mathcal{A}(1^n)$，当$\mathcal{A}$对消息$m$有加密查询时<ol>
<li>查询$c\leftarrow Enc_{k_E}(m)$</li>
<li>计算$t\leftarrow Mac_{k_M}(c)$，返回$&lt; c,t &gt;$给$\mathcal{A}$</li>
</ol>
</li>
<li>当$\mathcal{A}$对密文$&lt; c,t &gt;$有解密查询时，如果在之前的加密查询中出现过，则返回对应的$m$，否则返回$\perp$</li>
<li>当$\mathcal{A}$输出$(m<em>0,m_1)$，将这个结果输出并获得密文$c$，计算$t\leftarrow Mac</em>{k_M}(c)$，并将$&lt; c,t &gt;$返回给$\mathcal{A}$</li>
<li>输出$\mathcal{A}$的结果$b’$</li>
</ol>
<p>根据构造我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/8.png?raw=true" alt="8"></p>
<p>根据$\prod_E$是CPA安全的，综上我们可以证明这是CCA安全的。</p>
<p>到此得证。</p>
<h2 id="标准化方案"><a href="#标准化方案" class="headerlink" title="标准化方案"></a>标准化方案</h2><p>下面介绍实际中应用较广的三种AE方案。</p>
<h3 id="GCM-Galois-Counter-Mode"><a href="#GCM-Galois-Counter-Mode" class="headerlink" title="GCM(Galois/Counter Mode)"></a>GCM(Galois/Counter Mode)</h3><p>可以看作是一种encrypt-then-authenticate。使用CTR-mode进行加密，GMAC实现消息认证。</p>
<h3 id="CCM-Counter-with-CBC-MAC"><a href="#CCM-Counter-with-CBC-MAC" class="headerlink" title="CCM (Counter with CBC-MAC)"></a>CCM (Counter with CBC-MAC)</h3><p>其设计基于 Authenticate-then-Encrypt 范式，结合了 CTR 模式和 CBC-MAC。</p>
<h3 id="ChaCha20–Poly1305"><a href="#ChaCha20–Poly1305" class="headerlink" title="ChaCha20–Poly1305"></a>ChaCha20–Poly1305</h3><p>是一种基于 Encrypt-then-Authenticate 范式的高效认证加密（AE）方案，设计上适合软件实现，特别是在缺乏 GCM 硬件加速的情况下。</p>
<h1 id="安全通信会话"><a href="#安全通信会话" class="headerlink" title="安全通信会话"></a>安全通信会话</h1><p>这里简单介绍以下通信双方如何实现兼顾保密性和完整性的通信。<br>一般可能遭受的攻击有消息重排攻击，重放攻击，消息丢弃攻击，反射攻击等等。</p>
<p>可以使用计数器(counters)来维护双方发送接受信息的数量，使用方向比特(directionality bit)来设定消息的来源和方向。将这些信息加入消息中从而抵御这些攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/" class="post-title-link" itemprop="url">【四】消息认证码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-16 12:40:55 / 修改时间：15:42:25" itemprop="dateCreated datePublished" datetime="2024-12-16T12:40:55+08:00">2024-12-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第四章Message Authentication Codes</p>
<h1 id="消息完整性"><a href="#消息完整性" class="headerlink" title="消息完整性"></a>消息完整性</h1><h2 id="保密性vs完整性"><a href="#保密性vs完整性" class="headerlink" title="保密性vs完整性"></a>保密性vs完整性</h2><p>密码学的基本目标之一是让通信双方<strong>安全通信</strong>。我们已经讲过如何实现保密性，即通过加密明文防止窃听者能在开放信道上获取有关消息的任何信息。</p>
<p>但是，对于一些能够注入信息或者纂改信息的主动攻击者，实现<strong>消息认证</strong>（完整性）就更加重要。比如发送的消息是否是用户本人发出，消息在传输过程中是否被纂改过。这里要注意的是，常规的错误纠正技术只针对与传输过程中的随机错误，无法防御恶意攻击者对内容的精确修改。</p>
<p>以下是一个实际的例子。购物网站会将一些信息存储在Cookie中，包含了一些商品的价格折扣等等，而Cookie由用户进行保存。显然商家不希望用户对Cookie进行修改，而显然Cookie的内容对用户来说是明文，因为用户必须知道这些信息，所以这里的问题就是一个完整性问题。</p>
<p>所以这章的目标是用密码学技术实现消息的完整性(integrity)，以检测伪造的消息或在未受保护的通信信道上发送的被篡改的消息。需要注意的是，我们无法完全防止消息注入或篡改，因为这种攻击只能在物理层面加以防御。相反，我们的目标是确保任何此类行为都能被honest parties检测到。</p>
<h2 id="加密vs消息认证"><a href="#加密vs消息认证" class="headerlink" title="加密vs消息认证"></a>加密vs消息认证</h2><p>保密性和信息完整性是截然不同的目标。我们需要明确的是：除非加密是专门为完整性设计的，否则不会提供任何完整性保障。</p>
<p>可能很容易产生一个误解，既然密文完全隐藏了消息的内容，那么攻击者似乎不可能以任何有意义的方式篡改加密的消息。尽管这种推理直观上似乎合理，但它实际上是完全错误的。下面将举例说明这一点。</p>
<h3 id="流密码加密"><a href="#流密码加密" class="headerlink" title="流密码加密"></a>流密码加密</h3><p>假设一种异或处理的流密码，只需要在密文中任意翻转一位bit，那么解密后的明文就会也翻转一个bit，假如攻击方对加密密文有一定认识，很有可能翻转敏感重要的数字位来造成攻击。</p>
<h3 id="块密码加密"><a href="#块密码加密" class="headerlink" title="块密码加密"></a>块密码加密</h3><p>块密码一般来说单个位的比特变化会导致后续的变化，从而被发现。但是，如果是使用ECB模式时，翻转密文中第i个块的一个位只会影响明文中的第i个块——其他块保持不变。这样就可以构成有效的攻击。</p>
<p>最后需要注意的是，我们迄今为止讨论的所有加密方案都有一个共同的特性：任何长度合适的字符串都是有效的密文，因此都对应于某个有效的明文。基于这一特性，即使攻击者完全不知道密文对应的明文内容，也可以通过发送一条长度正确的任意字符串来“伪造”一方的消息。这使得攻击者能够轻松冒充通信方发送消息。</p>
<p>在消息完整性的语境中，即便是这种简单形式的攻击也应当被彻底排除。</p>
<h1 id="消息认证码的定义-MACs"><a href="#消息认证码的定义-MACs" class="headerlink" title="消息认证码的定义(MACs)"></a>消息认证码的定义(MACs)</h1><p>现在我们已经了解到，加密通常不能解决消息完整性的问题，所以我们引入<strong>消息认证码</strong>(Message Authentication Code, MAC)来让通信双方有能力判断消息是否被纂改。</p>
<p>想要实现这一点，通信双方必须要共享某个攻击者不知道的消息。这里我们继续讨论对称密钥的场景，即通信双方共享一个密钥。</p>
<p>MAC有两个典型应用场景：</p>
<ul>
<li>确保双方通信完整性：比如用户和银行之间的通信。</li>
<li>在时间跨度内保护单个用户的数据完整性，比如之前提到过的Cookie，或者用户硬盘。</li>
</ul>
<h2 id="MAC的定义"><a href="#MAC的定义" class="headerlink" title="MAC的定义"></a>MAC的定义</h2><p>首先先明确MAC是什么以及怎么使用。</p>
<p>首先，通信双方要生成一个共享密钥$key$。当一方想向另一方发送消息$m$时，会根据消息和密钥生成一个认证标签$t$，这个标签由标签生成算法Mac完成。接收方收到密文和标签后，会对其进行验证，验证消息在中途有没有收到纂改，验证由验证算法Vrfy完成。</p>
<p>形式化定义如下：</p>
<p><strong>DEFINITION 4.1</strong><br>一个消息验证码由三个概率多项式算法组成(Gen,Mac,Vrfy)。</p>
<ol>
<li>$Gen$：接受$1^n$作为输入，输出$k，|k|\ge n$。</li>
<li>$Mac$：接受$k,m$作为输入，输出$t$。因为这可能是一个概率算法，所以写作$t\leftarrow Mac_k(m)$</li>
<li>$Vrfy$：接受$k,m,t$作为输入，输出$1$或$0$。这是一个确定性算法，结果代表消息是否有效。</li>
</ol>
<p>$Vrfy(m,Mac_k(m),t)=1$</p>
<p>如果存在一个函数$l$，使得算法$Mac_k$仅对长度位$l(n)$的消息定义，那么该方案为固定长度MAC。</p>
<p>与对称密钥加密类似，一般Gen算法均匀选取key，所以一般省去对Gen的描述。</p>
<p><strong>标准认证(Canonical Verification)</strong>：对于确定性消息验证码，即MAC是确定性算法，只需再计算一遍tag比较是否相同即可验证。</p>
<h2 id="MAC的安全性"><a href="#MAC的安全性" class="headerlink" title="MAC的安全性"></a>MAC的安全性</h2><p>我们现在来定义一个MAC的安全性概念。该定义的核心思想是：任何有效的攻击者都无法为任何“新”消息生成有效的标签，其中“新”消息指的是此前未被通信方发送（并认证）的消息。</p>
<p>按照惯例，我们只考虑概率多项式时间的攻击者。在消息认证的场景中，攻击者观察通信方之间的交互可能能够看到所有发送的消息及其对应的标签。此外，攻击者可能通过直接或间接方式影响这些消息的内容（例如，攻击者的外部行为影响通信方发送的消息）。</p>
<p><strong>攻击者能力建模</strong>：我们允许攻击者请求任意合法消息的标签。即为供给者提供一个$Mac_k(\cdot)$的访问权限。</p>
<p><strong>攻击者的目标</strong>：生成一个新消息和一个对应的正确标签。如果在多项式时间内成功生成，则称破坏了方案的安全性。</p>
<p>如果消息认证码在以上情形下无法被攻破，那么称其为在自适应选择消息攻击下具有存在性不可伪造性（existentially unforgeable under an adaptive chosen-message attack, EUF-CMA）。该安全性要求确保，即便攻击者能够获取任意消息的标签，也无法伪造出新消息及其有效标签。</p>
<h3 id="安全性实验"><a href="#安全性实验" class="headerlink" title="安全性实验"></a>安全性实验</h3><ol>
<li>运行$Gen(1^n)$生成key</li>
<li>攻击者获得$Mac_k(\cdot)$的访问权限，可以多次查询，最终攻击者输出一对$(m,t)$。</li>
<li>当且仅当输出的m没有被查询过，且$Vrfy(m,t)=1$时，攻击成功。</li>
</ol>
<p><strong>DEFINIEION 4.2</strong><br>一个消息认证码是existentially unforgeable under an adaptive chosen-message attack，当且仅当，对于任意的多项式算法攻击者，都存在一个negl使：<br>$Pr[Mac-forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<p>这里的对安全性的定义看起来很严格：一方面攻击者可以自由选择信息并获得标签，另一方面只要伪造出任意的消息和标签就能成功攻破。这样的定义是为了保证方案的通用性和实用性。</p>
<p><strong>重放攻击</strong>：到目前位置没有考虑过以下情形，攻击者简单发送一条已经认证过的消息和其对应的有效标签。</p>
<p>MAC本身对重放攻击是无法防御的，因为其验证过程是无状态的。因此，会在更高层的应用中处理重放攻击，比如使用序列号和使用时间戳来防御。</p>
<h3 id="强安全性实验"><a href="#强安全性实验" class="headerlink" title="强安全性实验"></a>强安全性实验</h3><p><strong>强不可伪造性Strong unforgeability</strong>：<br>在标准定义中对安全性的保证是不能对<strong>新</strong>消息生成正确的标签，但是没有限制对已经认证过的消息生成一个新的有效标签。现在我们定义一个强不可伪造性实验Mac-sforge，要求目标是攻击者无法为已认证的消息生成有效的新标签。从而定义了一种更强的安全性。</p>
<p><strong>DEFINIEION 4.3</strong><br>一个消息认证码是strongly secure，当且仅当对于任意的多项式算法攻击者，都存在一个negl使：<br>$Pr[Mac-sforge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<p><strong>PROPOSITION 4.4</strong><br>如果一个消息认证码方案在标准验证下是安全的，那么这是strongly secure。</p>
<p><strong>验证查询(Verification queries)</strong>：定义4.2和定义4.3给了攻击者访问MAC的权限，即可以获得消息对应的标签。但是攻击者也可能获得验证的权限，即可以发送$(m,t)$给接收方并得知$Vrfy_k(m,t)$的结果。<br>攻击者引入验证查询后，对于使用标准验证的方案，不影响对安全性的定义，仍然是强安全的。但是对于一般的MAC方案，可能会影响定义的结果。这很好理解，因为如果是标准验证，标签是唯一的。<br>下面讨论的方案大多数都是强安全的，所以我们下面会忽略对验证查询的部分。</p>
<p><strong>潜在的时间攻击</strong>：<br>在现实生活中，攻击者不仅可以得知自己发送的$(m,t)$是否被接受，还能知道接收方判断所花费的时间，这也可能成为一种攻击的手段。</p>
<p>最简单的例子：假设接收方验证算法是逐字符比较，就可以知道正确的部分有多长。</p>
<p>所以验证算法应该使用和时间无关的算法。</p>
<h1 id="构造安全的消息认证码"><a href="#构造安全的消息认证码" class="headerlink" title="构造安全的消息认证码"></a>构造安全的消息认证码</h1><h2 id="固定长度的MAC"><a href="#固定长度的MAC" class="headerlink" title="固定长度的MAC"></a>固定长度的MAC</h2><p>伪随机函数可以构造一个安全的消息认证码方案。</p>
<p>直观上讲，如果标签是通过伪随机函数生成的，那么攻击者攻破该方案等价于猜测出为随机函数在一个点上的值，显然这个概率是很低的。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>以下是一个安全的定长的MAC构造方案：</p>
<ul>
<li>令$F$是一个伪随机函数。</li>
<li>Mac：$t:=F_k(m)$</li>
<li>Vrfy：标准验证</li>
</ul>
<h3 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>以上方案是一个安全的定长的MAC。</p>
<p>证明如下：<br>总体的证明思路是先将伪随机函数替换成真正的随机函数，证明对攻击者成功的概率的影响很有限，再去分析使用真随机函数的成功概率。</p>
<p>令$\tilde{\prod}$为原方案把伪随机函数换成真随机函数。下面要先证明<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/1.png?raw=true" alt="1"></p>
<p>证明如下<br>我们构造一个多项式时间区分器D，D对一个函数具有访问权，目标是区分这个函数是否是伪随机函数。该区分器操作方式如下：</p>
<ol>
<li>D模拟消息认证实验中的攻击者A，并观察A是否能输出一个新消息的有效标签。</li>
<li>每次D运行A，每当A查询消息m对应的标签时，D返回这个函数的运行结果作为t给A。</li>
<li>A输出$(m,t)$，D返回这个函数输入m之后的运行结果，如果这个结果等于t，那么输出1，否则输出0。</li>
</ol>
<p>显然当D的查询函数是$F_k$，那么D模拟的实验和A完全一致。有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/2.png?raw=true" alt="2"><br>同理有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/3.png?raw=true" alt="3"><br>而又因为伪随机函数，有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/4.png?raw=true" alt="4"><br>所以上式得证。</p>
<p>又因为在真随机函数中，攻击者只能通过猜测的方式，而概率非常低，所以有下式<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/5.png?raw=true" alt="5"></p>
<p>联立得<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/6.png?raw=true" alt="6"></p>
<p>我们到这里成功证明了构造出的方案很安全。</p>
<h2 id="非固定长度的MAC"><a href="#非固定长度的MAC" class="headerlink" title="非固定长度的MAC"></a>非固定长度的MAC</h2><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><p>上节介绍的构造是定长的，实际上限制很大，只能处理定长且较短的消息。<br>现在介绍如何构造出处理任意长度的MAC。</p>
<p>首先我们讨论一些自然的想法：</p>
<ol>
<li>逐块认证：攻击者可以删除块及其对应的标签。</li>
<li>认证长度：攻击者可以混合不同信息来攻击。</li>
<li>添加随机消息标识符：引出下列构造。（只对长度小于$2^{n/4}$的消息有效）</li>
</ol>
<p>假设我们已经有方案$\prod’=(Mac’,Vrfy’)$能处理定长的消息。构造新MAC如下：</p>
<ul>
<li>Mac：将消息m分为d个块$m_1,m_2,…,m_d$，最后一个块补0。随机生成一个消息标识符$r\in \{0,1\}^{n/4}$。计算$t_i\leftarrow Mac’_k(r||l||i||m_i)$。输出新标签$t:=<r,t_1,...,t_d>$。</li>
<li>Vrfy：标准验证。</li>
</ul>
<h3 id="安全性证明-1"><a href="#安全性证明-1" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>上述方案是安全的。</p>
<p>直觉上看，首先基础的定长MAC是安全的，再加上防御机制已经考虑了截断或者重排序等攻击手段，所以这是安全的。</p>
<p>证明如下：<br>令$\prod$是构造的新方案，有一个多项式时间算法攻击者$\mathcal{A}$，要证明$Pr[Mac-forge_{\mathcal{A},\prod}(n)=1]$是negl。</p>
<p>下面对一些事件做定义：</p>
<ul>
<li><strong>repeat</strong>：在Mac-forge实验中，MAC查询机使用了相同的随机标识符超过两次。</li>
<li><strong>NewBlock</strong>：攻击者给出的消息m中有一个块$r||l||i||m_i$没有被MAC’查询机查询过。即A尝试生成一个没有被定长MAC验证过的标签。</li>
</ul>
<p>所以有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/7.png?raw=true" alt="7"></p>
<p>我们将证明前两项是negl的，最后一项是0，从而使整体为negl。</p>
<p>第一项是个简单的概率问题，显然是negl的。即在有限次查询中出现两个相同的r的概率。</p>
<p>第三项也很简单，如果成功攻击并且没有重复的r，一定生成了新的有效块的标签。所以概率为0。</p>
<p>现在证明第二项：<br>首先重申几个定义</p>
<ul>
<li>q=q(n)是MAC查询次数</li>
<li>$r_i$是第i次MAC查询生成的标识符</li>
<li>r是攻击者输出的标识符</li>
<li>$m^{(j)}$是攻击者第j次查询的消息，$l_j$是这个消息的长度。</li>
</ul>
<p>出现了以下两种情况：</p>
<ol>
<li>$l\not =l_j$。那么显然NewBlock发生。</li>
<li>$l=l_j$，所以$m$和$m^{(j)}$长度相同，所以一定有一个索引i使得$m_i\not = m_i^{(j)}$。所以$r||l||i||m_i$一定没有被认证过。</li>
</ol>
<p>现在我们构造一个攻击者A’，目标是先证明<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/8.png?raw=true" alt="8"></p>
<p>构造如下：<br>A’运行A作为子程序，当A请求消息m的标签时，A’自己选择r并根据自己的查询机查询生成标签。当A输出后，A’很容易检查有没有NewBlock，如果有，则输出NewBlock，否则不输出。<br>由此构造很容易看出上式成立。</p>
<p>而又因为$\prod’$是安全的，所以第二项是negl。</p>
<p>到此得证全部。</p>
<h1 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h1><p>上面对于任意长度的MAC实际运行太过复杂，构造效率过低，我们现在来讨论一种更高效的方法。</p>
<h2 id="基本构造"><a href="#基本构造" class="headerlink" title="基本构造"></a>基本构造</h2><p>CBC-MAC 是最早被标准化的消息认证码之一。以下是一个基础版本构造。</p>
<p>首先令F是一个伪随机函数，并固定一个函数$l(n)$。</p>
<ul>
<li>$Mac$：接受一个key和一个message，其中消息的长度为$l(n)\cdot n$。将消息分为$l$个块，每个块的长度为$n$。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/9.png?raw=true" alt="9"><br>输出$t_l$作为标签。</li>
<li>$Vrfy$：先验证长度是否为$l(n)\cdot n$，再验证是否$t=Mac_k(m)$，即标准验证。</li>
</ul>
<p><strong>THEOREM 4.10</strong><br>上述构造的方案对于长度为$l(n)\cdot n$的消息是安全的。</p>
<p>关于这个定理的证明比较复杂，会在后面通过证明一个更一般的结论来获得。</p>
<p>尽管这个构造显然可以通过简单更改来适应不同长度，但该构造仅在认证的消息长度固定且已由发送方和接收方事先约定时是安全的。</p>
<p>和之前的两个构造相比，这个构造更加高效简洁。</p>
<h3 id="CBC-MAC-vs-CBA-mode加密"><a href="#CBC-MAC-vs-CBA-mode加密" class="headerlink" title="CBC-MAC vs CBA-mode加密"></a>CBC-MAC vs CBA-mode加密</h3><ol>
<li>初始化向量的使用<ul>
<li>CBC-mode 使用一个随机的初始化向量</li>
<li>CBC-MAC 使用固定的$0^n$，如果改用随机的，将不再安全。</li>
</ul>
</li>
<li>中间值的输出<ul>
<li>CBC-mode 会将所有中间值作为密文的一部分输出</li>
<li>CBA-MAC 只会输出最后一个块作为标签。如果全部输出，则不安全。</li>
</ul>
</li>
</ol>
<h3 id="对任意长度消息的CBC-MAC"><a href="#对任意长度消息的CBC-MAC" class="headerlink" title="对任意长度消息的CBC-MAC"></a>对任意长度消息的CBC-MAC</h3><p>为简单起见，我们假设所有被认证的消息长度均为n的倍数，且Vrfy对长度不是n倍数的消息直接拒绝。<br>下面介绍两个方法。</p>
<ol>
<li><p>将m的长度编码成n比特的字符串加到消息的开头，然后对结果使用基本CBC-MAC。</p>
<p>注意，如果添加到末尾则不再安全。</p>
</li>
<li><p>使用两个独立的密钥$k_1,k_2$，用$k_1$计算基本CBC-MAC得到t，再计算新标签$t’=F(k_2,t)$。</p>
<p>第二种方法因为在实际应用中使用两个密钥的代价过于昂贵，所以不太理想。</p>
</li>
</ol>
<h2 id="安全性证明-2"><a href="#安全性证明-2" class="headerlink" title="安全性证明"></a>安全性证明</h2><p>这里太过复杂，先略过。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/13/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/13/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">【三】私钥加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-13 16:13:19" itemprop="dateCreated datePublished" datetime="2024-12-13T16:13:19+08:00">2024-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-16 03:20:19" itemprop="dateModified" datetime="2024-12-16T03:20:19+08:00">2024-12-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第三章 Private-Key Encryption</p>
<p>在第二章中我们讨论了完美保密性，这要求密钥空间要大于等于明文空间。但是在现实中，这很难实现，我们需要能够使用较短的密钥来加密较长的信息。所以我们将放宽限制，研究计算保密性。</p>
<h1 id="计算保密性-Computational-Security"><a href="#计算保密性-Computational-Security" class="headerlink" title="计算保密性(Computational Security)"></a>计算保密性(Computational Security)</h1><p>相对于完美保密要求面对有无限计算能力的攻击者也不能泄露任何信息，计算保密放宽了以下两个限制：</p>
<ol>
<li>攻击者的计算能力（计算资源和时间）是有限的</li>
<li>攻击者被允许以很小的概率攻破，只要概率足够小，也被认为是安全的</li>
</ol>
<p>尽管放宽了限制，但是我们仍然要精准定义，所以我们有以下两种方法：</p>
<ol>
<li>具体方法(the Concrete Approach)</li>
<li>渐进方法(the Asymptotic Approach)</li>
</ol>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>形式化定义为：</p>
<p>如果任何攻击者在运行时间不超过$t$的情况下，破解方案成功的概率至多为$\epsilon$，则这个方案被称为$(t,\epsilon)$-安全的。</p>
<p>例如，一个方案可以保证，任何攻击者哪怕使用最强的计算机攻击200年，攻破的概率不超过$2^{-60}$。或者也可以使用计算机周期数来表示时间。</p>
<p>当然，这种方式的定义提供的信息非常有限。</p>
<h2 id="渐进方法"><a href="#渐进方法" class="headerlink" title="渐进方法"></a>渐进方法</h2><p>渐进方法以复杂度理论为基础，引入一个整数$n$作为安全参数(security parameter)，该参数用来描述加密方案的相关信息，比如密钥长度。同时，我们将攻击方的运行时间以及攻击成功概率定义为关于$n$的函数。</p>
<ol>
<li>我们将高效的攻击者定义为运行时间为多项式时间的随机算法(probabilistic polynomial-time, PPT)</li>
<li>我们将成功概率小定义为比任何多项式倒数都小的概率，这种概率被称为可忽略的(negligible)</li>
</ol>
<p>基于此，我们称一个加密方案是安全的当且仅当任意的PPT攻击者攻破的概率都不超可忽略概率。</p>
<p>当然，在最终部署一个加密方案的时候，我们也需要使用具体方法给出安全性定义，因为这是必然要挑选一个确定的$n$。</p>
<h3 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h3><h4 id="Efficient-algorithms"><a href="#Efficient-algorithms" class="headerlink" title="Efficient algorithms"></a>Efficient algorithms</h4><p>一个从自然数到非负实数的函数$f$被称为是<strong>多项式有界</strong>(polynomially bounded)，当且仅当存在一个常数$c$，使得对所有$n$都有$f(n)\leq n^c$。</p>
<p>如果一个算法$A$的运行时间是多项式时间的，那么存在一个多项式函数$p$，对于任意输入$x\in\{0,1\}^*$，那么算法$A(x)$的计算步数最多为$p(|x|)$。</p>
<p>我们将高效攻击者(efficient adversaries)定义为运行时间为安全参数$n$的多项式时间。</p>
<p>默认情况下，我们允许所有算法是<strong>概率的</strong>(probabilistic)，任何这样的算法都假设可以访问一个独立且无偏的随机<br>位序列。</p>
<h4 id="Negligible-success-probability"><a href="#Negligible-success-probability" class="headerlink" title="Negligible success probability"></a>Negligible success probability</h4><p>一个从自然数到非负实数的函数$f$被称为是<strong>可忽略的</strong>(negligible)，当且仅当对于任何一个多项式$p$，存在一个$N$，使得任何$n&gt;N$，都有$f(n)&lt;\frac{1}{p(n)}$。</p>
<p>我们用$negl$来表示这样的函数。</p>
<p>假设$negl_1$和$negl_2$都是可忽略的，那么有以下性质：</p>
<ol>
<li>$negl_1+negl_2$是可忽略的</li>
<li>$p(n)\cdot negl_1(n)$是可忽略的</li>
</ol>
<h1 id="定义计算安全加密"><a href="#定义计算安全加密" class="headerlink" title="定义计算安全加密"></a>定义计算安全加密</h1><p>首先我们稍微修改以下对于私钥加密的定义：</p>
<p>我们使用一个三元组$(Gen,Enc,Dec)$来定义一个私钥加密方案：</p>
<ul>
<li>$Gen$： 是一个概率算法，接受$1^n$作为输入，生成一个密钥$k$，其中不失一般性的假设$|k|\ge n$</li>
<li>$Enc$： 接受一个消息$m$和一个密钥$k$，返回一个密文$c$<ul>
<li>如果这是一个确定算法，我们写作$c:=Enc_k(m)$</li>
<li>如果这是一个概率算法，我们写作$c\leftarrow Enc_k(m)$</li>
</ul>
</li>
<li>$Dec$： 接受一个密文$c$和一个密钥$k$，返回一个消息$m$或者错误符号$\perp$</li>
</ul>
<h2 id="EVA-Security的定义"><a href="#EVA-Security的定义" class="headerlink" title="EVA-Security的定义"></a>EVA-Security的定义</h2><p>我们现在先只考虑仅密文攻击，也就是说攻击者只能观察到一个密文。</p>
<h3 id="不可区分性实验"><a href="#不可区分性实验" class="headerlink" title="不可区分性实验"></a>不可区分性实验</h3><p>现在定义这种情况下的不可区分性实验$PrivK^{eva}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>攻击者$\mathcal{A}$接受输入$1^n$，输出两个消息$m_0,m_1$，其中$|m_0|=|m_1|$</li>
<li>运行$Gen(1^n)$获得$k$，并随机选择$b\in \{0,1\}$，计算$c\leftarrow Enc_k(m_b)$并传输给$\mathcal{A}$</li>
<li>$\mathcal{A}$的输出$b’$，如果$b’=b$，实验结果定义为$1$，写作$Privk^{eva}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>一个私钥加密方案是<strong>EVA-Secure</strong>的，当且仅当对于任何可能的多项式时间攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使对于任意的$n$，有：<script type="math/tex">Pr[PrivK^{eva}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)</script></p>
<p>我们还可以给出一种等价的表达方式，我们定义$out<em>{\mathcal{A}}(PrivK^{eva}</em>{\mathcal{A},\prod}(n,b))$为在这次试验中$\mathcal{A}$的输出结果，则EVA-Secure等价于：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/1.png?raw=true" alt="1"></p>
<h3 id="关于明文长度"><a href="#关于明文长度" class="headerlink" title="关于明文长度"></a>关于明文长度</h3><p>正常情况下，我们不会要求机密方案隐藏明文的长度。</p>
<p>但是在以下的一些特殊情况下，需要隐藏明文长度，因为明文长度就隐含着一些信息：</p>
<ul>
<li>工资有几位数</li>
<li>压缩数据</li>
</ul>
<p>如果我们需要避免泄露明文长度，就需要事先把消息填充到某个预定长度。</p>
<h2 id="语义安全"><a href="#语义安全" class="headerlink" title="语义安全"></a>语义安全</h2><p>我们一开始说明了安全加密的定义意味着对手无法从密文中获取任何部分信息。但是上面的定义貌似没有考虑这一点，现在我们通过引入<strong>语义安全</strong>(dsemantic security)来说明这一点。</p>
<p>首先，我们可以证明以下理论：</p>
<p>对于一个固定长度的加密方案，这是EVA-Secure的，当且仅当对于任何PPT攻击者$\mathcal{A}$和$i$，存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/2.png?raw=true" alt="2"></p>
<p>这很好证明，只需要归约就行。</p>
<p>然后我们可以进一步证明以下理论：</p>
<p>对于一个固定长度的加密方案，这是EVA-Secure的，当且仅当对于任何PPT攻击者$\mathcal{A}$，都存在一个PPT算法$\mathcal{A}’$，使得对于任何在$\{0,1\}^l$上的分布$\mathcal{D}$和任意的函数$f:\{0,1\}^l\rightarrow\{0,1\}$，存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/3.png?raw=true" alt="3"></p>
<p>其中概率中的明文$m$依据$\mathcal{D}$分布。</p>
<p>现在，我们可以结合上面两个理论，来定义语义安全。</p>
<p>对于一个固定长度的加密方案，这是语义安全的，当且仅当对于任何PPT攻击者$\mathcal{A}$，都存在一个PPT算法$\mathcal{A}’$，使得对于任何PPT算法$Samp$和多项式时间可计算的函数$f,h$，都能使下式为可忽略的函数：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/4.png?raw=true" alt="4"></p>
<p>其中的明文是根据$Samp$分布的，而这里$h$表示任何攻击者可能获得的信息。</p>
<p>最终，我们给出结论：</p>
<p>语义安全和EVA安全是等价的。</p>
<h1 id="构造EVA安全的加密方案"><a href="#构造EVA安全的加密方案" class="headerlink" title="构造EVA安全的加密方案"></a>构造EVA安全的加密方案</h1><h2 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h2><p>伪随机数生成器$G$是一个高效的确定性算法，功能是将一个比较短的均匀字符串转换为一个较长的伪随机字符串。</p>
<p>有一些简单的统计方法用来判断伪随机数生成器是否良好，比如，测试伪随机数生成的第一个比特是否以$\frac{1}{2}$的概率为1，但是这样是不严谨的。</p>
<p>我们希望有更严格的测试方式，比如，面对任意的区分器$\mathcal{D}$，我们都希望接收到伪随机数生成器的输出返回1的概率等于一个真实的伪随机数，这意味着伪随机数生成器对于任何高效的观察者看起来都和真的随机生成的均匀的字符串差不多。</p>
<h3 id="形式化定义-1"><a href="#形式化定义-1" class="headerlink" title="形式化定义"></a>形式化定义</h3><p>令$G$是一个确定性的多项式时间算法，对于任意的$n$和输入$s\in\{0,1\}^n$，$G$返回一个长度为$l(n)$的伪随机字符串。$G$是一个伪随机数生成器当且仅当：</p>
<ol>
<li>$l(n)&gt;n$，这里$l(n)$被称为the expansion factor。</li>
<li>对于任何PPT算法$D$，都存在一个$negl$使：<script type="math/tex; mode=display">|Pr[D(G(s))=1]-Pr[D(r)=1]|\leq negl(n)</script>其中$s$在$\{0,1\}^n$中被均匀选取，$r$在$\{0,1\}^{l(n)}$中被均匀选取。</li>
</ol>
<h3 id="伪随机数生成器的相关讨论"><a href="#伪随机数生成器的相关讨论" class="headerlink" title="伪随机数生成器的相关讨论"></a>伪随机数生成器的相关讨论</h3><p>当然，我们不妨设想这样一个例子，当$l(n)=2n$，这使得能落入$G$生成范围的数占总数的$\frac{2^n}{2^{2n}}=\frac{1}{2^n}$。显然暴力攻击能轻松分辨出伪随机数生成器和真实的随机数，但是这并不能算高效的区分器。</p>
<p>关于伪随机数生成器种子的选取，种子的作用和加密方案的密钥其实是类似的，我们同样需要种子长度足够大来抵抗暴力攻击。</p>
<p>关于伪随机数生成器的存在性，显然直接想构造是很困难的，但是我们可以相信对于任何多项式扩展因子的伪随机数生成器都是存在的。在一个较弱的假设下，如果单向函数存在，伪随机数生成器是存在的，此外，我们还可以通过流密码等方式来构造伪随机数生成器，目前还没有发现针对性的高效区分器。</p>
<p>目前我们先假设伪随机数生成器存在。</p>
<h2 id="归约证明法"><a href="#归约证明法" class="headerlink" title="归约证明法"></a>归约证明法</h2><p>如果我们要证明一个加密方案$\prod$是安全的，通常我们会经过以下步骤：</p>
<ol>
<li>假设对于方案$\prod$，存在PPT攻击者$\mathcal{A}$，攻破方案的概率为$\epsilon(n)$</li>
<li>构造一个攻击者$\mathcal{A}’$，其试图攻破问题$X$并以$\mathcal{A}$为子进程。这里$\mathcal{A}’$并不需要知道$\mathcal{A}$具体怎么攻破。<ol>
<li>$\mathcal{A}’$要为$\mathcal{A}$模拟一个$\prod$的交互环境</li>
<li>当$\mathcal{A}$能成功破解$\prod$时，$\mathcal{A}’$要成功破解$X$以至少多项式倒数的概率($\frac{1}{p(n)}$)。</li>
</ol>
</li>
<li>综上分析，$\mathcal{A}’$攻破的成功概率为$\frac{\epsilon(n)}{p(n)}$，当$\epsilon(n)$是不可忽略的时候，整体也是不可忽略的。</li>
<li>基于我们对问题$X$的假设，$X$是难解的，这也就意味着如果$\mathcal{A}$能有较大概率攻破$\prod$，那么$\mathcal{A}’$也能攻破问题$X$，矛盾，因此该加密方案是安全的。</li>
</ol>
<h2 id="伪随机数生成器构造EVA-Security"><a href="#伪随机数生成器构造EVA-Security" class="headerlink" title="伪随机数生成器构造EVA-Security"></a>伪随机数生成器构造EVA-Security</h2><p>我们可以通过更改One-Time Pad的密钥生成方式来构造一个EVA-Secure的加密方案。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>令$G$是一个扩展因子为$l(n)$的伪随机数生成器。</p>
<ol>
<li>$Gen$：均匀选取$k\in \{0,1\}^n$</li>
<li>$Enc$：$c:=G(k)\oplus m$</li>
<li>$Dec$：$m:=c\oplus G(k)$</li>
</ol>
<p>注意，这个方案是定长的。</p>
<h3 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>首先直接给出结论，这个方案是EVA-secure的。</p>
<p>我们的目标是证明：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/5.png?raw=true" alt="5"></p>
<p>我们构造以下区分器$\mathcal{D}$，接受$\omega\in \{0,1\}^l$作为输入：</p>
<ol>
<li>运行$\mathcal{A}(1^n)$，获得两个输出$m_0,m_1$</li>
<li>均匀随机挑选$b\in \{0,1\}$，令$c:=\omega\oplus m_b$</li>
<li>将$c$返回给$\mathcal{A}$，获得输出$b’$，如果$b=b’$，则返回1，否则返回0。</li>
</ol>
<p>又因为$G$是一个伪随机数生成器，所以一定有：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/6.png?raw=true" alt="6"></p>
<p>而考虑$\omega$的来源：</p>
<ol>
<li>$\omega$是均匀选取的，则有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/7.png?raw=true" alt="7"></li>
<li>$\omega$是$G$生成的，则有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/8.png?raw=true" alt="8"></li>
</ol>
<p>结合上式我们可以得到：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/9.png?raw=true" alt="9"></p>
<p>完成了证明。</p>
<h1 id="更强的安全性概念"><a href="#更强的安全性概念" class="headerlink" title="更强的安全性概念"></a>更强的安全性概念</h1><p>到目前为止我们只讨论了当攻击者仅被允许窃听单个密文的情况，但是显然实际生活中攻击方可以更加强大。</p>
<h2 id="多重加密的安全性"><a href="#多重加密的安全性" class="headerlink" title="多重加密的安全性"></a>多重加密的安全性</h2><p>现在考虑攻击者可以监听到多个用同一个密钥加密的密文。</p>
<p>我们可以定义以下的安全性实验，多消息窃听实验$PrivK^{mult}_{\mathcal{A},\prod}(n)$:</p>
<ol>
<li>攻击者$\mathcal{A}$接受输入$1^n$，输出两个消息向量$\vec{M<em>0},\vec{M_1}$，其中$|m</em>{0,i}|=|m_{1,i}|$</li>
<li>运行$Gen(1^n)$获得$k$，并随机选择$b\in \{0,1\}$，计算$c<em>i \leftarrow Enc_k(m</em>{b,i})$并将$\vec{C}$传输给$\mathcal{A}$</li>
<li>$\mathcal{A}$的输出$b’$，如果$b’=b$，实验结果定义为$1$，写作$Privk^{eva}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>一个加密方案是多消息不可区分的，当且仅当对于任何可能的多项式时间攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使对于任意的$n$，有：</p>
<script type="math/tex; mode=display">Pr[PrivK^{mult}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)</script><p>很显然，对于单密文不可区分的加密方案，多密文下很可能是可区分的，比如当加密算法是确定性算法时，我们就很容易构造输入来进行区分。</p>
<p>甚至我们有以下定理，当一个加密方案的加密算法是确定性的，这个方案一定不是多消息不可区分的。</p>
<p>所以在这种情况下，我们必须要设计随机化加密方案，使同样的消息经过同一个密钥加密也可以生成不同的密文。</p>
<h2 id="选择明文攻击-Chosen-Plaintext-Attacks-和CPA-Security"><a href="#选择明文攻击-Chosen-Plaintext-Attacks-和CPA-Security" class="headerlink" title="选择明文攻击(Chosen-Plaintext Attacks)和CPA-Security"></a>选择明文攻击(Chosen-Plaintext Attacks)和CPA-Security</h2><p>我们现在考虑攻击者可以影响甚至控制明文，使得攻击者可以获取对应的密文。</p>
<h3 id="CPA不可区分性实验"><a href="#CPA不可区分性实验" class="headerlink" title="CPA不可区分性实验"></a>CPA不可区分性实验</h3><p>现在定义这种情况下的不可区分性实验$PrivK^{cpa}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>运行$Gen(1^n)$获得$k$</li>
<li>攻击者$\mathcal{A}$接受输入$1^n$，并获得一个查询$Enc_k(\cdot)$的权限(oracle)，输出两个消息$m_0,m_1$，其中$|m_0|=|m_1|$</li>
<li>，并随机选择$b\in \{0,1\}$，计算$c\leftarrow Enc_k(m_b)$并传输给$\mathcal{A}$</li>
<li>$\mathcal{A}$仍然有查询$Enc_k(\cdot)$的权限，最终输出$b’$</li>
<li>如果$b’=b$，实验结果定义为$1$，写作$Privk^{eva}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>一个加密方案是<strong>CPA-Secure</strong>的，当且仅当对于任何可能的多项式时间攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使对于任意的$n$，有：<script type="math/tex">Pr[PrivK^{cpa}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)</script></p>
<p>当然，任何CPA安全的私钥加密档案对于多消息加密仍然是CPA安全的。</p>
<h3 id="固定长度-vs-任意长度"><a href="#固定长度-vs-任意长度" class="headerlink" title="固定长度 vs 任意长度"></a>固定长度 vs 任意长度</h3><p>理论上，只要有固定长度的加密方案，我们就可以把它扩展到任意长度，只需要对消息进行切割或扩充，但是这样的方案会带来较大的开销，效率比较低。</p>
<h1 id="构造CPA安全的加密方案"><a href="#构造CPA安全的加密方案" class="headerlink" title="构造CPA安全的加密方案"></a>构造CPA安全的加密方案</h1><h2 id="伪随机函数-Pseudorandom-functions-PRFs-和伪随机置换-Permutations"><a href="#伪随机函数-Pseudorandom-functions-PRFs-和伪随机置换-Permutations" class="headerlink" title="伪随机函数(Pseudorandom functions, PRFs)和伪随机置换(Permutations)"></a>伪随机函数(Pseudorandom functions, PRFs)和伪随机置换(Permutations)</h2><h3 id="伪随机函数"><a href="#伪随机函数" class="headerlink" title="伪随机函数"></a>伪随机函数</h3><p>我们无法说某个固定函数$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$是随机的，这里，我们引入一个带密钥函数(keyed functions)。</p>
<p>带密钥函数(keyed functions)可以被看作有两个输入，即$F:\{0,1\}^<em> \times \{0,1\}^</em> \rightarrow \{0,1\}^*$。其中，第一个输入为密钥，第二个输入为函数的常规输入。我们只考虑能被在多项式时间内计算的函数。同时，我们先不妨假设密钥长度、输入长度和输出长度相等。</p>
<p>直观上，我们定义$Func_n$是n比特映射到n比特的函数的集合，令$f$是从中任意选取的一个函数，令$F_k(x)=F(k,x)$，我们希望无法区分$f$和$F_k$。</p>
<p>当然，假设这里有一个区分器来尝试区分，显然如果知道一个函数详细的描述，是很容易区分的，但是这并不高效，也就是不能在多项式时间内完成。所以我们不妨规定区分器不能接受函数的完整描述，但是能够有一个查询接口，可以对任意的输入$x$查询函数对应的值，当然，也只能进行多项式次数的查询。</p>
<h4 id="形式化定义-2"><a href="#形式化定义-2" class="headerlink" title="形式化定义"></a>形式化定义</h4><p>现在我们可以给出形式化定义，我们定义一个带密钥函数$F$为一个伪随机函数，当且仅当对于任何多项式时间区分器$D$，都存在一个可忽略函数$negl$，使：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/10.png?raw=true" alt="10"></p>
<h4 id="伪随机函数和伪随机数生成器"><a href="#伪随机函数和伪随机数生成器" class="headerlink" title="伪随机函数和伪随机数生成器"></a>伪随机函数和伪随机数生成器</h4><p>伪随机函数 (PRFs) 和伪随机生成器 (PRGs) 之间具有密切的关系。他们其实可以相互构造。</p>
<h3 id="伪随机置换"><a href="#伪随机置换" class="headerlink" title="伪随机置换"></a>伪随机置换</h3><p>伪随机置换要求在伪随机函数的基础上还要是双射，同时逆函数也要能在多项式时间内被计算。</p>
<p>显然，伪随机置换一定是一个伪随机函数。</p>
<p>形式化定义如下：<br>我们定义一个带密钥函数$F$为一个强伪随机置换(strong pseudorandom permutation)，当且仅当对于任何多项式时间区分器$D$，都存在一个可忽略函数$negl$，使：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/11.png?raw=true" alt="11"></p>
<h2 id="构造CPA安全的加密方案-1"><a href="#构造CPA安全的加密方案-1" class="headerlink" title="构造CPA安全的加密方案"></a>构造CPA安全的加密方案</h2><p>这里的目标是构造一个固定长度的CPA安全的加密方案。根据之前的结论，只要有固定长度的，我们可以扩展到任意长度。</p>
<h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><p>令$F$是一个伪随机数函数。</p>
<ol>
<li>$Gen$：均匀选取$k\in \{0,1\}^n$</li>
<li>$Enc$：均匀选取$r\in \{0,1\}^n$，$c:=&lt; r, F_k(r)\oplus m &gt;$</li>
<li>$Dec$：$m:=F_k(r)\oplus s$</li>
</ol>
<h3 id="安全性证明-1"><a href="#安全性证明-1" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>一般来说我们证明加密方案的CPA安全性会采用以下步骤：</p>
<ol>
<li>首先考虑用真随机函数来代替伪随机函数，通过归约证明这样修改不会显著提高攻击者的成功概率。</li>
<li>在假设方案中，通过概率计算来评估攻击成功的概率，这一部分一般不依赖于假设。</li>
</ol>
<p>上述方案安全性证明如下：<br>首先我们令方案$\tilde{\prod}$为将伪随机函数替换成真随机函数后的方案，我们将通过归约证明：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/12.png?raw=true" alt="12"></p>
<p>我们构造一个区分器$D$，其接受输入$1^n$并有一个未知函数的查询机$\mathcal{O}$。</p>
<ol>
<li>运行$\mathcal{A}(1^n)$，当$\mathcal{A}$查询时：<ol>
<li>$D$均匀选取$r\in \{0,1\}^n$</li>
<li>查询$y=\mathcal{O}(r)$</li>
<li>将$&lt; r,y \oplus m &gt;$返回给$\mathcal{A}$</li>
</ol>
</li>
<li>$\mathcal{A}$输出消息$m_0,m_1$，随机选取$b\in \{0,1\}$<ol>
<li>$D$均匀选取$r\in \{0,1\}^n$</li>
<li>查询$y=\mathcal{O}(r)$</li>
<li>将$&lt; r,y \oplus m_b &gt;$返回给$\mathcal{A}$</li>
</ol>
</li>
<li>接受$\mathcal{A}$的最终输出$b’$，如果$b’=b$，输出1，否则输出0。</li>
</ol>
<p>由构造我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/13.png?raw=true" alt="13"></p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/14.png?raw=true" alt="14"></p>
<p>在因为$F$是伪随机函数，根据定义我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/15.png?raw=true" alt="15"></p>
<p>到此我们已经证明了第一步。</p>
<p>第二部分我们将证明</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/16.png?raw=true" alt="16"></p>
<p>我们定义事件$repeat$为$r$已经被使用过，所以有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/17.png?raw=true" alt="17"></p>
<p>最后将两个部分结合，我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/18.png?raw=true" alt="18"></p>
<p>到此得证。</p>
<h1 id="加密模式与实践中的加密"><a href="#加密模式与实践中的加密" class="headerlink" title="加密模式与实践中的加密"></a>加密模式与实践中的加密</h1><p>上述的加密方案在实践中都存在一些缺点，比如效率差限制多等。我们接下来要提出一些实际操作上更优的加密方案。</p>
<p>首先我们会引入其中的核心部分</p>
<ul>
<li>使用<strong>流密码</strong>来实现伪随机数生成器</li>
<li>使用<strong>分组密码</strong>来实现伪随机函数</li>
</ul>
<h2 id="流密码-Stream-ciphers"><a href="#流密码-Stream-ciphers" class="headerlink" title="流密码(Stream ciphers)"></a>流密码(Stream ciphers)</h2><p>流密码是一组确定性算法：</p>
<ol>
<li><strong>Init</strong>：$st_0:=Init(s,[IV])$</li>
<li><strong>GetBits</strong>：$(y<em>i,st_i):=GetBits(st</em>{i-1})$</li>
</ol>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/23.png?raw=true" alt="23"></p>
<h2 id="分组密码-Block-ciphers"><a href="#分组密码-Block-ciphers" class="headerlink" title="分组密码(Block ciphers)"></a>分组密码(Block ciphers)</h2><h3 id="ECB-mode"><a href="#ECB-mode" class="headerlink" title="ECB mode"></a>ECB mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/19.png?raw=true" alt="19"></p>
<p>这是确定性算法，所以是不安全的。</p>
<h3 id="CBC-mode"><a href="#CBC-mode" class="headerlink" title="CBC mode"></a>CBC mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/20.png?raw=true" alt="20"></p>
<p>如果$F$是伪随机函数，则方案是CPA安全的。</p>
<p>缺点是不能并行化处理。</p>
<h3 id="OFP-mode"><a href="#OFP-mode" class="headerlink" title="OFP mode"></a>OFP mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/21.png?raw=true" alt="21"></p>
<p>如果$F$是伪随机函数，则方案是CPA安全的。</p>
<p>可以进行预计算。</p>
<h3 id="CTR-mode"><a href="#CTR-mode" class="headerlink" title="CTR mode"></a>CTR mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/22.png?raw=true" alt="22"></p>
<p>如果$F$是伪随机函数，则方案是CPA安全的。</p>
<p>加密和解密都可以并行化计算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/13/%E5%AE%8C%E7%BE%8E%E4%BF%9D%E5%AF%86%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/13/%E5%AE%8C%E7%BE%8E%E4%BF%9D%E5%AF%86%E6%80%A7/" class="post-title-link" itemprop="url">【二】完美保密性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-13 14:43:28 / 修改时间：16:19:30" itemprop="dateCreated datePublished" datetime="2024-12-13T14:43:28+08:00">2024-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第二章 Perfectly Secret Encryption</p>
<p>在本章中，我们将探讨另一个极端，即研究即使面对具有无限计算能力的攻击者也能被证明安全的加密方案。这类方案被称为完美安全(perfectly secret)。</p>
<p>为了简化讨论，我们假设可以各方都可以获得无限供应的独立无偏的随机位。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先回顾上一章介绍的加密语法，我们使用一个消息空间$\mathcal{M}$和一个三元组$(Gen,Enc,Dec)$来定义一个私钥加密方案：</p>
<ul>
<li>$Gen$： 是一个概率算法，依据某些分布生成一个密钥$k$，$\mathcal{K}$表示密钥空间。</li>
<li>$Enc$： 接受一个消息$m$和一个密钥$k$，返回一个密文$c$，$\mathcal{C}$表示密文集合<ul>
<li>如果这是一个确定性算法，我们写作$c:=Enc_k(m)$</li>
<li>如果这是一个概率性算法，我们写作$c\leftarrow Enc_k(m)$</li>
</ul>
</li>
<li>$Dec$： 接受一个密文$c$和一个密钥$k$，返回一个消息$m$，$\mathcal{M}$表示明文集合。显然这里解密算法是一个确定性算法</li>
</ul>
<h2 id="完美安全性-Perfectly-Secrecy"><a href="#完美安全性-Perfectly-Secrecy" class="headerlink" title="完美安全性(Perfectly Secrecy)"></a>完美安全性(Perfectly Secrecy)</h2><p>现在假设攻击者的能力是：</p>
<ol>
<li>知道加密方案</li>
<li>观察到密文</li>
</ol>
<p>一个完美安全的加密方案要求攻击者观察到密文对实际的发送明文的概率没有影响。换句话说，观察到密文对消息选择的先验概率和后验概率应当是相同的。</p>
<h3 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h3><p>一个加密方案是<strong>完美安全的</strong>，如果对于消息空间$\mathcal{M}$的任意概率分布，任意消息$m\in \mathcal{M}$，任意密文$c\in \mathcal{C}$（其中$Pr[C=c]&gt;0$），有：</p>
<script type="math/tex; mode=display">Pr[M=m|C=c]=Pr[M=m]</script><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>一个加密方案是完美安全的，当且仅当对于任意$m,m’\in \mathcal{M}$，任意$c\in \mathcal{C}$，有：</p>
<script type="math/tex; mode=display">Pr[C=c|M=m]=Pr[C=c|M=m']</script><h3 id="完美不可区分性"><a href="#完美不可区分性" class="headerlink" title="完美不可区分性"></a>完美不可区分性</h3><p>现在介绍一个实验：</p>
<ol>
<li>攻击者$\mathcal{A}$指定任意两个消息$m_0,m_1\in \mathcal{M}$</li>
<li>$Gen$生成一个密钥$k$</li>
<li>随机选择一个$b\in \{0,1\}$，计算密文$c\leftarrow Enc_k(m_b)$</li>
<li>将密文$c$返回给攻击者$\mathcal{A}$</li>
<li>攻击者给出一个猜测值$b’\in \{0,1\}$，如果$b’=b$，实验结果定义为$1$，写作$Privk^{eav}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>在攻击者完全随机猜测的情况下，实验结果为$1$的概率为$\frac{1}{2}$。完美保密性的目的就是希望攻击者任何选择的策略都不能优于随机猜测。</p>
<p>有定义如下：<br>一个方案是<strong>完美不可区分的</strong>当且仅当对于任何攻击者$\mathcal{A}$，都有：</p>
<script type="math/tex; mode=display">Pr[Privk^{eav}_{\mathcal{A},\prod}=1]=\frac{1}{2}</script><p>有引理如下：<br>完美保密性和完美不可区分性是等价的。</p>
<h1 id="One-Time-Pad"><a href="#One-Time-Pad" class="headerlink" title="One-Time Pad"></a>One-Time Pad</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>对于固定长度$l$，我们定义该方案的明文空间、密钥空间和密文空间都为$\{0,1\}^l$：</p>
<ul>
<li>$Gen$：从密钥空间中均匀随机选取一个密钥</li>
<li>$Enc$：$c:=m\oplus  k$</li>
<li>$Dec$：$m:=c\oplus k$</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>这个方案是完美安全的。</p>
<p>但是这个方案存在限制，密钥只能使用一次，如果多次使用就会变得不安全。这就要求每次加密都要重新生成密钥，这是很麻烦的。</p>
<h1 id="完美安全的限制"><a href="#完美安全的限制" class="headerlink" title="完美安全的限制"></a>完美安全的限制</h1><p>我们将证明：任何完美安全的加密方案的密钥空间大小必须至少与消息空间大小相等。</p>
<p>形式化的：</p>
<p>对于一个完美安全的加密方案，有$|\mathcal{K}|\ge |\mathcal{M}|$</p>
<p>证明如下：</p>
<p>假设$|\mathcal{K}|&lt;|\mathcal{M}|$，对于一个密文，其被不同密钥解密出的明文集合大小必然等于密钥空间大小，即小于明文空间大小。这就说明存在一个密文，有对应的明文无论什么密钥都无法加密称为该密文。即：</p>
<script type="math/tex; mode=display">\exists m',c,s.t. Pr[M=m'|C=c]=0\not =Pr[M=m']</script><p>违背了完美安全的定义。</p>
<h1 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h1><p>令$(Gen,Enc,Dec)$是一个明文空间为$\mathcal{M}$的加密方案，并且$|\mathcal{M}|=|\mathcal{C}|=|\mathcal{K}|$，这个方案是完美安全的当且仅当满足以下条件：</p>
<ol>
<li>任意密钥被$Gen$以$\frac{1}{\mathcal{K}}$的概率选择</li>
<li>对于任意$m\in\mathcal{M},c\in \mathcal{C}$，只存在一个唯一的$k\in \mathcal{K}$使得$c:=Enc_k(m)$</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BC%95%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BC%95%E5%85%A5/" class="post-title-link" itemprop="url">【一】密码学引入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-12 19:47:28" itemprop="dateCreated datePublished" datetime="2024-12-12T19:47:28+08:00">2024-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-13 14:44:16" itemprop="dateModified" datetime="2024-12-13T14:44:16+08:00">2024-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第一章 Introduction</p>
<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><p>在牛津词典中，密码学被定义为编写或破译密码的艺术。该定义只关注用来实现秘密通信的各类密码，但是现代密码学涵盖了更多更广的领域：确保数据完整性的机制、交换秘密密钥的技术、用户认证的协议、电子投票、加密货币等等。</p>
<h1 id="私钥加密的设定"><a href="#私钥加密的设定" class="headerlink" title="私钥加密的设定"></a>私钥加密的设定</h1><p>古典密码学关注的是设计和使用能够使两方在信息传递过程中保持消息机密的密码（或称密文）的方法。在现代密码学中，我们称之为加密方案(encryption scheme)，所有的古典加密方案都依赖于一个事先双方共享的密钥-私钥(private-key)。</p>
<p>在私钥加密的背景下，双方共享一把密钥，一方使用密钥进行加密获得密文，一方使用密钥进行解密获得明文。解密和加密使用相同的密钥，这被称为<strong>对称密钥</strong>(symmetric-key)。</p>
<p>私钥密码学有两个典型应用场景：</p>
<ul>
<li>同一时间下不同空间的通信</li>
<li>同一空间下不同时间的通信</li>
</ul>
<h2 id="加密的语法"><a href="#加密的语法" class="headerlink" title="加密的语法"></a>加密的语法</h2><p>形式化上，我们使用一个消息空间$\mathcal{M}$和一个三元组$(Gen,Enc,Dec)$来定义一个私钥加密方案：</p>
<ul>
<li>$Gen$： 是一个概率算法，依据某些分布生成一个密钥$k$</li>
<li>$Enc$： 接受一个消息$m$和一个密钥$k$，返回一个密文$c$</li>
<li>$Dec$： 接受一个密文$c$和一个密钥$k$，返回一个消息$m$</li>
</ul>
<p>对于$\forall m\in \mathcal{M},Dec_k(Enc_k(m))=m$</p>
<p>我们用$\mathcal{K}$来表示密钥空间，用$\mathcal{C}$来表示密文空间。</p>
<h2 id="克克霍夫原则（Kerckhoffs’-principle）"><a href="#克克霍夫原则（Kerckhoffs’-principle）" class="headerlink" title="克克霍夫原则（Kerckhoffs’ principle）"></a>克克霍夫原则（Kerckhoffs’ principle）</h2><p>密码方法不应依赖于保密，甚至在其落入敌手后也不应造成不便。</p>
<p>也就是说，即使对手知道方案的所有细节，只要对手不知道所用的密钥，加密方案仍应保持安全性。换句话说，安全性不应建立在加密方案本身的保密之上；克克霍夫原则要求安全性仅依赖于密钥的保密。</p>
<h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>经典的移位密码，把每个字母统一往后移动$k$位，只需要尝试最多25次就可以破解，所以这也暗示了一个安全的加密方案应该要能够抵抗暴力破解，至少密钥空间要足够大。</p>
<h2 id="单字母替换密码"><a href="#单字母替换密码" class="headerlink" title="单字母替换密码"></a>单字母替换密码</h2><p>这里使用一个字母表的双射来函数来实现加密，显然密钥空间很大(26!)。</p>
<p>可以通过词频分析来进行有效率的攻击。</p>
<h1 id="现代密码学原则"><a href="#现代密码学原则" class="headerlink" title="现代密码学原则"></a>现代密码学原则</h1><p>古典密码学依赖的更多是经验和直觉。如今，人们以更为系统化的方式设计和分析密码方案，最终目标是对给定构造是否安全给出严格的证明。为了实现这一点，我们首先需要形式化的定义，以精确界定“安全”的含义；这些定义本身就很有价值和趣味性。事实证明，大多数密码学证明都依赖于目前尚未证实的假设，即关于某些数学问题的算法求解难度的假设；因此我们必须明确并精确地陈述这些假设。</p>
<h2 id="原则1-形式化定义"><a href="#原则1-形式化定义" class="headerlink" title="原则1-形式化定义"></a>原则1-形式化定义</h2><p>明确的定义有助于指导密码学方案的设计。定义还为对具体构造进行评估和分析提供了途径。</p>
<h2 id="原则2-精确假设"><a href="#原则2-精确假设" class="headerlink" title="原则2-精确假设"></a>原则2-精确假设</h2><p>大多数现代密码学构造无法无条件地证明其安全性；要给出无条件的证明意味着要解决计算复杂性理论中当前仍远未能解答的问题。</p>
<p>现代密码学要求任何此类假设都必须明确、精确地加以阐述。最基本的原因是，安全性证明本身需要精确的假设。</p>
<p>人们通常倾向于使用“更简单”的假设——也就是对某个简洁明了的数学问题的难度假设，而非对一个复杂方案满足复杂安全定义的假设。</p>
<h2 id="原则3-安全性证明"><a href="#原则3-安全性证明" class="headerlink" title="原则3-安全性证明"></a>原则3-安全性证明</h2><p>借助前面讨论的两个原则（明确的定义与精确定义的假设），我们即可实现目标：在给定的假设条件下，严格证明某个构造满足相应的安全性定义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gisyxi7</p>
  <div class="site-description" itemprop="description">nju cs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gisyxi7</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
