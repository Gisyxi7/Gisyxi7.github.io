<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nju cs">
<meta property="og:type" content="website">
<meta property="og:title" content="Gisyxi7&#39;s blogs">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Gisyxi7&#39;s blogs">
<meta property="og:description" content="nju cs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gisyxi7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Gisyxi7's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Gisyxi7's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学不动了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/CCA%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/CCA%E5%AE%89%E5%85%A8%E5%92%8C%E8%AE%A4%E8%AF%81%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">【五】CCA安全和认证加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-16 13:00:28 / 修改时间：16:59:51" itemprop="dateCreated datePublished" datetime="2024-12-16T13:00:28+08:00">2024-12-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第五章CCA-Security and Authenticated Encryption</p>
<p>我们已经讨论过了两种攻击者，一种是监听信道，一种是纂改通信，对应的我们提出了保密性和完整性的目标。现在我们要讨论存在主动攻击者时的保密性问题，以及如何构建同时实现保密性和完整性的加密方案。</p>
<h1 id="选择密文攻击和CCA安全"><a href="#选择密文攻击和CCA安全" class="headerlink" title="选择密文攻击和CCA安全"></a>选择密文攻击和CCA安全</h1><p>我们上一章中考虑攻击者可以纂改信道，那么显然，攻击者可以有以下的手段，使通信接收方解密攻击者生成的密文，并且攻击者还能知道解密后的消息。</p>
<h2 id="Padding-Oracle-Attacks"><a href="#Padding-Oracle-Attacks" class="headerlink" title="Padding-Oracle Attacks"></a>Padding-Oracle Attacks</h2><p>现在考虑一种真实情况，客户端使用CBC模式加密向服务器发送消息，假设攻击者能够冒充客户端，向服务器发送其选择的密文，那么攻击者能获得服务器的相关反应来推断密文的有效性（比如服务器解密失败就会要求重传）。</p>
<p>在CBC加密模式下，我们要求消息长度为底层分组密码长度的整数倍，如果消息长度不满足，则需要进行填充。而填充也需要遵循一定的方案，服务器会解密并验证是否遵循正确的填充方案。</p>
<p>这意味着服务器会向攻击者提供一个填充查询机，来判断填充是否正确。并且攻击者是有方法根据这个信息来恢复密文对应的明文的。</p>
<h2 id="CCA-Security-的定义"><a href="#CCA-Security-的定义" class="headerlink" title="CCA-Security 的定义"></a>CCA-Security 的定义</h2><p>下面来形式化定义一下CCA安全。<br>我们仿照之前的实验方案，给出CCA不可区分实验：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/1.png?raw=true" alt="1"></p>
<p>注意这里，加密算法应该是概率性的，否则很容易通过加密查询来获取正确结果。</p>
<p><strong>DEFINITION 5.1</strong><br>一个加密方案是CCA安全的当且仅当</p>
<script type="math/tex; mode=display">Pr[PrivK^{cca}_{\mathcal{A},\prod}(n)=1]\leq 1/2+negl(n)</script><p>由此也可以引申出，如果一个方案是CCA安全的，在多密文不可区分实验中仍然是CCA安全的。</p>
<p>以上实验中给了攻击者很大的能力，比如能知道解密后的明文，但是现实中知道的信息不一定有这么多，我们这里在定义上希望攻击者足够强。</p>
<p>到目前为止，我们研究的大多数方案都不是CCA安全的。攻击者可以通过比特翻转等攻击方式来打破不可区分性。</p>
<h1 id="认证加密"><a href="#认证加密" class="headerlink" title="认证加密"></a>认证加密</h1><p>迄今为止，我们分别探讨了如何通过加密实现机密性，以及通过消息认证码实现完整性。下面定义的认证加密（Authenticated Encryption）旨在同时实现这两个目标。在对称密钥环境中，默认同时确保机密性和完整性是最佳实践。事实上，在许多需要机密性的应用中，完整性通常也是至关重要的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="不可伪造实验"><a href="#不可伪造实验" class="headerlink" title="不可伪造实验"></a>不可伪造实验</h3><p>考虑以下实验：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/2.png?raw=true" alt="2"><br>简单的说就是要求攻击者不能伪造一个有效的密文。</p>
<p><strong>DEFINITION 5.2</strong><br>一个方案是不可伪造的(unforgeble)，当且仅当对于任何多项式概率算法攻击者A，都有</p>
<script type="math/tex; mode=display">Pr[Enc-Forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)</script><h3 id="AE的定义"><a href="#AE的定义" class="headerlink" title="AE的定义"></a>AE的定义</h3><p><strong>DEFINITION 5.3</strong><br>一个方案是AE(authenticated encryption)当且仅当这个方案是CCA安全的并且是不可伪造的。</p>
<p>我们也可以通过一个单一的实验来定义AE加密方案。<br>假设现在攻击者可以遇到以下两种不同的情况：</p>
<ol>
<li>攻击者被提供了一个加密oracle和一个解密oracle的访问权限。</li>
<li>攻击者获得的是一个加密0字符串的oracle。一个始终返回错误符号$\perp $的解密oracle。</li>
</ol>
<p>如果攻击者不能区分这两种场景，这说明攻击者在真实世界中生成的新密文都将无效同时攻击者无法区分真实的加密。</p>
<p>该实验的定义如下：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/3.png?raw=true" alt="3"></p>
<p><strong>DEFINITION 5.4</strong><br>一个方案是AE-secure，当且仅当对于任何多项式概率算法攻击者A，都有<br>$Pr[PrivK^{ae}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)$</p>
<p><strong>THEROREM 5.5</strong><br>定义5.3和定义5.4是等价的。</p>
<p>带有关联数据的认证加密：在许多情况下，可能只有部分内容需要加密，部分内容只要保证完整性即可。虽然对整体消息进行AE方案加密可以满足要求，但是效率较低，现实中，支持关联数据的认证加密方案在文献中被称为带有关联数据的认证加密（Authenticated Encryption with Associated Data，简称 AEAD）。</p>
<h2 id="CCA安全-vs-认证加密"><a href="#CCA安全-vs-认证加密" class="headerlink" title="CCA安全 vs 认证加密"></a>CCA安全 vs 认证加密</h2><p>我们根据定义可以直接得出任何认证加密（AE）方案也都是选择密文攻击安全（CCA-secure）的。然而，反之则不成立。</p>
<p>在现实世界中，确实存在情景只需要CCA安全而不关注认证加密。尽管如此，在存在活跃攻击者的情况下，大多数对称密钥加密的应用确实需要完整性保护。幸运的是，大多数自然构造的 CCA 安全加密方案通常也满足更强的认证加密定义。从这个角度来看，没有理由使用那些既是 CCA 安全但不是认证加密的方案，因为没有任何此类方案在效率上比认证加密方案更优。</p>
<h1 id="认证加密方案"><a href="#认证加密方案" class="headerlink" title="认证加密方案"></a>认证加密方案</h1><h2 id="一般构造"><a href="#一般构造" class="headerlink" title="一般构造"></a>一般构造</h2><p>直觉上认为将一个CPA安全的加密方案和一个安全的MAC方案结合就能得到一个AE方案，但是事实上不是这样的。</p>
<p>假设：</p>
<ol>
<li>$\prod_{E}=(Enc,Dec)$是一个CPA安全的加密方案</li>
<li>$\prod_{M}=(MAC,Verify)$是一个安全的MAC方案</li>
<li>两种方案使用独立的密钥$k_E$和$k_M$</li>
</ol>
<p>下面是常见的三种构造方式。</p>
<h3 id="Encrypt-and-authenticate"><a href="#Encrypt-and-authenticate" class="headerlink" title="Encrypt-and-authenticate"></a>Encrypt-and-authenticate</h3><p>$c\leftarrow Enc(k_E,m),t\leftarrow MAC(k_M,m)$，密文为$&lt; c , t &gt;$<br>因为它未能将保密性和完整性紧密结合，导致标签可能泄露关于消息的信息，确定性MAC可能使攻击者意识到消息的重复发送等问题。</p>
<h3 id="Authenticate-then-encrypt"><a href="#Authenticate-then-encrypt" class="headerlink" title="Authenticate-then-encrypt"></a>Authenticate-then-encrypt</h3><p>$t\leftarrow MAC(k_M,m),c\leftarrow Enc(k_E,m||t)$，密文为$c$<br>一般会用CBC模式进行加密，那么填充部分就可以用来实现攻击，因为不同的错误类型会提供有效信息。一个很直接的解决方案是使错误信息都返回同一种。但是这在现实中并不有效，不利于调试等等问题。</p>
<h3 id="Encrypt-then-authenticate"><a href="#Encrypt-then-authenticate" class="headerlink" title="Encrypt-then-authenticate"></a>Encrypt-then-authenticate</h3><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><p>$c\leftarrow Enc(k_E,m),t\leftarrow MAC(k_M,c)$，密文为$&lt; c , t &gt;$<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/4.png?raw=true" alt="4"><br>直观上这样的构造很安全。</p>
<p>如果攻击者提交的密文$ ⟨ c ,t ⟩ $不来自加密 oracle，认证标签 t 将无法通过验证，解密 oracle 会返回错误。</p>
<p>如果攻击者提交的密文确实来自加密 oracle，那么攻击者已经知道该密文的解密结果。</p>
<p>这种设计使解密 oracle 对攻击者无用，从而避免了选择密文攻击（CCA）的潜在威胁。</p>
<p>在解密之前，首先验证标签 t。如果标签验证失败，解密算法立即返回错误，而不会尝试解密密文 c。</p>
<p>这种设计避免了与 Authenticate-then-Encrypt 方法类似的填充 Oracle 攻击，因为解密过程不会执行，攻击者无法通过错误信息获知关于明文的任何信息。</p>
<h4 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h4><p><strong>THEROREM 5.7</strong><br>以上构造是AE安全的。</p>
<p>我们的目标是证明这个方案不可伪造且CCA安全。令$\mathcal{A}$是一个PPT攻击者</p>
<p>我们令$VaildQuery$代表事件：攻击者成功向$Dec(\cdot)$提交了一个新的有效密文。我们要证明$Pr[ValidQuery]$是可忽略的。</p>
<p>如果事件$VaildQuery$发生，那么攻击者成功通过了$Mac-sforge$实验，令$q(\cdot)$代表攻击者向解密查询机查询次数的多项式上界。现在考虑对于$\prod_M$的攻击者$\mathcal{A}_M$:</p>
<ol>
<li>$\mathcal{A}<em>M$获得查询权限$Mac</em>{k_M}(\cdot)$</li>
<li>均匀选取$k_E\in \{0,1\}^n,i\in \{1,\cdots,q(n)\}$</li>
<li>运行$\mathcal{A}(1^n)$，当$\mathcal{A}$对消息$m$有加密查询时<ol>
<li>计算$c\leftarrow Enc_{k_E}(m)$</li>
<li>查询$t:=Mac_{k_M}(c)$，返回$&lt; c,t &gt;$给$\mathcal{A}$</li>
</ol>
</li>
<li>当$\mathcal{A}$对$&lt; c,t &gt;$有解密查询时，如果这是第$i$次加密查询，输$(c,t)$并停止，否则：<ol>
<li>如果$&lt; c,t &gt;$，是之前加密查询的结果，则返回对应的$m$</li>
<li>否则返回$\perp$</li>
</ol>
</li>
</ol>
<p>本质上，$\mathcal{A}<em>M$是在猜测$\mathcal{A}$的第$i$次加密查询是一次新的有效的查询。所以如果$\mathcal{A}_M$正确猜测了$VaildQuery$的第一个索引$i$，就可以成功通过$Mac-sforge</em>{\mathcal{A}_M,\prod_M}(n)$。这个成功猜测的概率是$\frac{1}{q(n)}$。</p>
<p>而根据$\prod_M$是一个强安全MAC，我们有：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/5.png?raw=true" alt="5"></p>
<p>综上我们证明了这是不可伪造的。下面我们继续证明该方案是CCA安全。</p>
<p>首先我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/6.png?raw=true" alt="6"></p>
<p>而不等式右边的第一项已经证明是可忽略的，现在我们的目标是证明</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/7.png?raw=true" alt="7"></p>
<p>现在我们构造$\mathcal{A}<em>E$来攻击$\prod_E$，其中$\mathcal{A}_E$有查询$Enc</em>{k_E}(\cdot)$的权限：</p>
<ol>
<li>均匀选取$k_E\in \{0,1\}^n$</li>
<li>运行$\mathcal{A}(1^n)$，当$\mathcal{A}$对消息$m$有加密查询时<ol>
<li>查询$c\leftarrow Enc_{k_E}(m)$</li>
<li>计算$t\leftarrow Mac_{k_M}(c)$，返回$&lt; c,t &gt;$给$\mathcal{A}$</li>
</ol>
</li>
<li>当$\mathcal{A}$对密文$&lt; c,t &gt;$有解密查询时，如果在之前的加密查询中出现过，则返回对应的$m$，否则返回$\perp$</li>
<li>当$\mathcal{A}$输出$(m<em>0,m_1)$，将这个结果输出并获得密文$c$，计算$t\leftarrow Mac</em>{k_M}(c)$，并将$&lt; c,t &gt;$返回给$\mathcal{A}$</li>
<li>输出$\mathcal{A}$的结果$b’$</li>
</ol>
<p>根据构造我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/CCA/8.png?raw=true" alt="8"></p>
<p>根据$\prod_E$是CPA安全的，综上我们可以证明这是CCA安全的。</p>
<p>到此得证。</p>
<h2 id="标准化方案"><a href="#标准化方案" class="headerlink" title="标准化方案"></a>标准化方案</h2><p>下面介绍实际中应用较广的三种AE方案。</p>
<h3 id="GCM-Galois-Counter-Mode"><a href="#GCM-Galois-Counter-Mode" class="headerlink" title="GCM(Galois/Counter Mode)"></a>GCM(Galois/Counter Mode)</h3><p>可以看作是一种encrypt-then-authenticate。使用CTR-mode进行加密，GMAC实现消息认证。</p>
<h3 id="CCM-Counter-with-CBC-MAC"><a href="#CCM-Counter-with-CBC-MAC" class="headerlink" title="CCM (Counter with CBC-MAC)"></a>CCM (Counter with CBC-MAC)</h3><p>其设计基于 Authenticate-then-Encrypt 范式，结合了 CTR 模式和 CBC-MAC。</p>
<h3 id="ChaCha20–Poly1305"><a href="#ChaCha20–Poly1305" class="headerlink" title="ChaCha20–Poly1305"></a>ChaCha20–Poly1305</h3><p>是一种基于 Encrypt-then-Authenticate 范式的高效认证加密（AE）方案，设计上适合软件实现，特别是在缺乏 GCM 硬件加速的情况下。</p>
<h1 id="安全通信会话"><a href="#安全通信会话" class="headerlink" title="安全通信会话"></a>安全通信会话</h1><p>这里简单介绍以下通信双方如何实现兼顾保密性和完整性的通信。<br>一般可能遭受的攻击有消息重排攻击，重放攻击，消息丢弃攻击，反射攻击等等。</p>
<p>可以使用计数器(counters)来维护双方发送接受信息的数量，使用方向比特(directionality bit)来设定消息的来源和方向。将这些信息加入消息中从而抵御这些攻击。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81/" class="post-title-link" itemprop="url">【四】消息认证码</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-16 12:40:55" itemprop="dateCreated datePublished" datetime="2024-12-16T12:40:55+08:00">2024-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-24 10:51:05" itemprop="dateModified" datetime="2024-12-24T10:51:05+08:00">2024-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第四章Message Authentication Codes</p>
<h1 id="消息完整性"><a href="#消息完整性" class="headerlink" title="消息完整性"></a>消息完整性</h1><h2 id="保密性vs完整性"><a href="#保密性vs完整性" class="headerlink" title="保密性vs完整性"></a>保密性vs完整性</h2><p>密码学的基本目标之一是让通信双方<strong>安全通信</strong>。我们已经讲过如何实现保密性，即通过加密明文防止窃听者能在开放信道上获取有关消息的任何信息。</p>
<p>但是，对于一些能够注入信息或者纂改信息的主动攻击者，实现<strong>消息认证</strong>（完整性）就更加重要。比如发送的消息是否是用户本人发出，消息在传输过程中是否被纂改过。这里要注意的是，常规的错误纠正技术只针对与传输过程中的随机错误，无法防御恶意攻击者对内容的精确修改。</p>
<p>以下是一个实际的例子。购物网站会将一些信息存储在Cookie中，包含了一些商品的价格折扣等等，而Cookie由用户进行保存。显然商家不希望用户对Cookie进行修改，而显然Cookie的内容对用户来说是明文，因为用户必须知道这些信息，所以这里的问题就是一个完整性问题。</p>
<p>所以这章的目标是用密码学技术实现消息的完整性(integrity)，以检测伪造的消息或在未受保护的通信信道上发送的被篡改的消息。需要注意的是，我们无法完全防止消息注入或篡改，因为这种攻击只能在物理层面加以防御。相反，我们的目标是确保任何此类行为都能被honest parties检测到。</p>
<h2 id="加密vs消息认证"><a href="#加密vs消息认证" class="headerlink" title="加密vs消息认证"></a>加密vs消息认证</h2><p>保密性和信息完整性是截然不同的目标。我们需要明确的是：除非加密是专门为完整性设计的，否则不会提供任何完整性保障。</p>
<p>可能很容易产生一个误解，既然密文完全隐藏了消息的内容，那么攻击者似乎不可能以任何有意义的方式篡改加密的消息。尽管这种推理直观上似乎合理，但它实际上是完全错误的。下面将举例说明这一点。</p>
<h3 id="流密码加密"><a href="#流密码加密" class="headerlink" title="流密码加密"></a>流密码加密</h3><p>假设一种异或处理的流密码，只需要在密文中任意翻转一位bit，那么解密后的明文就会也翻转一个bit，假如攻击方对加密密文有一定认识，很有可能翻转敏感重要的数字位来造成攻击。</p>
<h3 id="块密码加密"><a href="#块密码加密" class="headerlink" title="块密码加密"></a>块密码加密</h3><p>块密码一般来说单个位的比特变化会导致后续的变化，从而被发现。但是，如果是使用ECB模式时，翻转密文中第i个块的一个位只会影响明文中的第i个块——其他块保持不变。这样就可以构成有效的攻击。</p>
<p>最后需要注意的是，我们迄今为止讨论的所有加密方案都有一个共同的特性：任何长度合适的字符串都是有效的密文，因此都对应于某个有效的明文。基于这一特性，即使攻击者完全不知道密文对应的明文内容，也可以通过发送一条长度正确的任意字符串来“伪造”一方的消息。这使得攻击者能够轻松冒充通信方发送消息。</p>
<p>在消息完整性的语境中，即便是这种简单形式的攻击也应当被彻底排除。</p>
<h1 id="消息认证码的定义-MACs"><a href="#消息认证码的定义-MACs" class="headerlink" title="消息认证码的定义(MACs)"></a>消息认证码的定义(MACs)</h1><p>现在我们已经了解到，加密通常不能解决消息完整性的问题，所以我们引入<strong>消息认证码</strong>(Message Authentication Code, MAC)来让通信双方有能力判断消息是否被纂改。</p>
<p>想要实现这一点，通信双方必须要共享某个攻击者不知道的消息。这里我们继续讨论对称密钥的场景，即通信双方共享一个密钥。</p>
<p>MAC有两个典型应用场景：</p>
<ul>
<li>确保双方通信完整性：比如用户和银行之间的通信。</li>
<li>在时间跨度内保护单个用户的数据完整性，比如之前提到过的Cookie，或者用户硬盘。</li>
</ul>
<h2 id="MAC的定义"><a href="#MAC的定义" class="headerlink" title="MAC的定义"></a>MAC的定义</h2><p>首先先明确MAC是什么以及怎么使用。</p>
<p>首先，通信双方要生成一个共享密钥$key$。当一方想向另一方发送消息$m$时，会根据消息和密钥生成一个认证标签$t$，这个标签由标签生成算法Mac完成。接收方收到密文和标签后，会对其进行验证，验证消息在中途有没有收到纂改，验证由验证算法Vrfy完成。</p>
<p>形式化定义如下：</p>
<p><strong>DEFINITION 4.1</strong><br>一个消息验证码由三个概率多项式算法组成(Gen,Mac,Vrfy)。</p>
<ol>
<li>$Gen$：接受$1^n$作为输入，输出$k，|k|\ge n$。</li>
<li>$Mac$：接受$k,m$作为输入，输出$t$。因为这可能是一个概率算法，所以写作$t\leftarrow Mac_k(m)$</li>
<li>$Vrfy$：接受$k,m,t$作为输入，输出$1$或$0$。这是一个确定性算法，结果代表消息是否有效。</li>
</ol>
<p>$Vrfy_k(m,Mac_k(m))=1$</p>
<p>如果存在一个函数$l$，使得算法$Mac_k$仅对长度位$l(n)$的消息定义，那么该方案为固定长度MAC。</p>
<p>与对称密钥加密类似，一般Gen算法均匀选取key，所以一般省去对Gen的描述。</p>
<p><strong>标准认证(Canonical Verification)</strong>：对于确定性消息验证码，即MAC是确定性算法，只需再计算一遍tag比较是否相同即可验证。</p>
<h2 id="MAC的安全性"><a href="#MAC的安全性" class="headerlink" title="MAC的安全性"></a>MAC的安全性</h2><p>我们现在来定义一个MAC的安全性概念。该定义的核心思想是：任何有效的攻击者都无法为任何“新”消息生成有效的标签，其中“新”消息指的是此前未被通信方发送（并认证）的消息。</p>
<p>按照惯例，我们只考虑概率多项式时间的攻击者。在消息认证的场景中，攻击者观察通信方之间的交互可能能够看到所有发送的消息及其对应的标签。此外，攻击者可能通过直接或间接方式影响这些消息的内容（例如，攻击者的外部行为影响通信方发送的消息）。</p>
<p><strong>攻击者能力建模</strong>：我们允许攻击者请求任意合法消息的标签。即为供给者提供一个$Mac_k(\cdot)$的访问权限。</p>
<p><strong>攻击者的目标</strong>：生成一个新消息和一个对应的正确标签。如果在多项式时间内成功生成，则称破坏了方案的安全性。</p>
<p>如果消息认证码在以上情形下无法被攻破，那么称其为在自适应选择消息攻击下具有存在性不可伪造性（existentially unforgeable under an adaptive chosen-message attack, EUF-CMA）。该安全性要求确保，即便攻击者能够获取任意消息的标签，也无法伪造出新消息及其有效标签。</p>
<h3 id="安全性实验"><a href="#安全性实验" class="headerlink" title="安全性实验"></a>安全性实验</h3><ol>
<li>运行$Gen(1^n)$生成key</li>
<li>攻击者获得$Mac_k(\cdot)$的访问权限，可以多次查询，最终攻击者输出一对$(m,t)$。</li>
<li>当且仅当输出的m没有被查询过，且$Vrfy(m,t)=1$时，攻击成功。</li>
</ol>
<p><strong>DEFINIEION 4.2</strong><br>一个消息认证码是existentially unforgeable under an adaptive chosen-message attack，当且仅当，对于任意的多项式算法攻击者，都存在一个negl使：<br>$Pr[Mac-forge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<p>这里的对安全性的定义看起来很严格：一方面攻击者可以自由选择信息并获得标签，另一方面只要伪造出任意的消息和标签就能成功攻破。这样的定义是为了保证方案的通用性和实用性。</p>
<p><strong>重放攻击</strong>：到目前位置没有考虑过以下情形，攻击者简单发送一条已经认证过的消息和其对应的有效标签。</p>
<p>MAC本身对重放攻击是无法防御的，因为其验证过程是无状态的。因此，会在更高层的应用中处理重放攻击，比如使用序列号和使用时间戳来防御。</p>
<h3 id="强安全性实验"><a href="#强安全性实验" class="headerlink" title="强安全性实验"></a>强安全性实验</h3><p><strong>强不可伪造性Strong unforgeability</strong>：<br>在标准定义中对安全性的保证是不能对<strong>新</strong>消息生成正确的标签，但是没有限制对已经认证过的消息生成一个新的有效标签。现在我们定义一个强不可伪造性实验Mac-sforge，要求目标是攻击者无法为已认证的消息生成有效的新标签。从而定义了一种更强的安全性。</p>
<p><strong>DEFINIEION 4.3</strong><br>一个消息认证码是strongly secure，当且仅当对于任意的多项式算法攻击者，都存在一个negl使：<br>$Pr[Mac-sforge_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<p><strong>PROPOSITION 4.4</strong><br>如果一个消息认证码方案在标准验证下是安全的，那么这是strongly secure。</p>
<p><strong>验证查询(Verification queries)</strong>：定义4.2和定义4.3给了攻击者访问MAC的权限，即可以获得消息对应的标签。但是攻击者也可能获得验证的权限，即可以发送$(m,t)$给接收方并得知$Vrfy_k(m,t)$的结果。<br>攻击者引入验证查询后，对于使用标准验证的方案，不影响对安全性的定义，仍然是强安全的。但是对于一般的MAC方案，可能会影响定义的结果。这很好理解，因为如果是标准验证，标签是唯一的。<br>下面讨论的方案大多数都是强安全的，所以我们下面会忽略对验证查询的部分。</p>
<p><strong>潜在的时间攻击</strong>：<br>在现实生活中，攻击者不仅可以得知自己发送的$(m,t)$是否被接受，还能知道接收方判断所花费的时间，这也可能成为一种攻击的手段。</p>
<p>最简单的例子：假设接收方验证算法是逐字符比较，就可以知道正确的部分有多长。</p>
<p>所以验证算法应该使用和时间无关的算法。</p>
<h1 id="构造安全的消息认证码"><a href="#构造安全的消息认证码" class="headerlink" title="构造安全的消息认证码"></a>构造安全的消息认证码</h1><h2 id="固定长度的MAC"><a href="#固定长度的MAC" class="headerlink" title="固定长度的MAC"></a>固定长度的MAC</h2><p>伪随机函数可以构造一个安全的消息认证码方案。</p>
<p>直观上讲，如果标签是通过伪随机函数生成的，那么攻击者攻破该方案等价于猜测出为随机函数在一个点上的值，显然这个概率是很低的。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>以下是一个安全的定长的MAC构造方案：</p>
<ul>
<li>令$F$是一个伪随机函数。</li>
<li>Mac：$t:=F_k(m)$</li>
<li>Vrfy：标准验证</li>
</ul>
<h3 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>以上方案是一个安全的定长的MAC。</p>
<p>证明如下：<br>总体的证明思路是先将伪随机函数替换成真正的随机函数，证明对攻击者成功的概率的影响很有限，再去分析使用真随机函数的成功概率。</p>
<p>令$\tilde{\prod}$为原方案把伪随机函数换成真随机函数。下面要先证明<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/1.png?raw=true" alt="1"></p>
<p>证明如下<br>我们构造一个多项式时间区分器D，D对一个函数具有访问权，目标是区分这个函数是否是伪随机函数。该区分器操作方式如下：</p>
<ol>
<li>D模拟消息认证实验中的攻击者A，并观察A是否能输出一个新消息的有效标签。</li>
<li>每次D运行A，每当A查询消息m对应的标签时，D返回这个函数的运行结果作为t给A。</li>
<li>A输出$(m,t)$，D返回这个函数输入m之后的运行结果，如果这个结果等于t，那么输出1，否则输出0。</li>
</ol>
<p>显然当D的查询函数是$F_k$，那么D模拟的实验和A完全一致。有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/2.png?raw=true" alt="2"><br>同理有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/3.png?raw=true" alt="3"><br>而又因为伪随机函数，有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/4.png?raw=true" alt="4"><br>所以上式得证。</p>
<p>又因为在真随机函数中，攻击者只能通过猜测的方式，而概率非常低，所以有下式<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/5.png?raw=true" alt="5"></p>
<p>联立得<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/6.png?raw=true" alt="6"></p>
<p>我们到这里成功证明了构造出的方案很安全。</p>
<h2 id="非固定长度的MAC"><a href="#非固定长度的MAC" class="headerlink" title="非固定长度的MAC"></a>非固定长度的MAC</h2><h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><p>上节介绍的构造是定长的，实际上限制很大，只能处理定长且较短的消息。<br>现在介绍如何构造出处理任意长度的MAC。</p>
<p>首先我们讨论一些自然的想法：</p>
<ol>
<li>逐块认证：攻击者可以删除块及其对应的标签。</li>
<li>认证长度：攻击者可以混合不同信息来攻击。</li>
<li>添加随机消息标识符：引出下列构造。（只对长度小于$2^{n/4}$的消息有效）</li>
</ol>
<p>假设我们已经有方案$\prod’=(Mac’,Vrfy’)$能处理定长的消息。构造新MAC如下：</p>
<ul>
<li>Mac：将消息m分为d个块$m_1,m_2,…,m_d$，最后一个块补0。随机生成一个消息标识符$r\in \{0,1\}^{n/4}$。计算$t_i\leftarrow Mac’_k(r||l||i||m_i)$。输出新标签$t:=<r,t_1,...,t_d>$。</li>
<li>Vrfy：标准验证。</li>
</ul>
<h3 id="安全性证明-1"><a href="#安全性证明-1" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>上述方案是安全的。</p>
<p>直觉上看，首先基础的定长MAC是安全的，再加上防御机制已经考虑了截断或者重排序等攻击手段，所以这是安全的。</p>
<p>证明如下：<br>令$\prod$是构造的新方案，有一个多项式时间算法攻击者$\mathcal{A}$，要证明$Pr[Mac-forge_{\mathcal{A},\prod}(n)=1]$是negl。</p>
<p>下面对一些事件做定义：</p>
<ul>
<li><strong>repeat</strong>：在Mac-forge实验中，MAC查询机使用了相同的随机标识符超过两次。</li>
<li><strong>NewBlock</strong>：攻击者给出的消息m中有一个块$r||l||i||m_i$没有被MAC’查询机查询过。即A尝试生成一个没有被定长MAC验证过的标签。</li>
</ul>
<p>所以有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/7.png?raw=true" alt="7"></p>
<p>我们将证明前两项是negl的，最后一项是0，从而使整体为negl。</p>
<p>第一项是个简单的概率问题，显然是negl的。即在有限次查询中出现两个相同的r的概率。</p>
<p>第三项也很简单，如果成功攻击并且没有重复的r，一定生成了新的有效块的标签。所以概率为0。</p>
<p>现在证明第二项：<br>首先重申几个定义</p>
<ul>
<li>q=q(n)是MAC查询次数</li>
<li>$r_i$是第i次MAC查询生成的标识符</li>
<li>r是攻击者输出的标识符</li>
<li>$m^{(j)}$是攻击者第j次查询的消息，$l_j$是这个消息的长度。</li>
</ul>
<p>出现了以下两种情况：</p>
<ol>
<li>$l\not =l_j$。那么显然NewBlock发生。</li>
<li>$l=l_j$，所以$m$和$m^{(j)}$长度相同，所以一定有一个索引i使得$m_i\not = m_i^{(j)}$。所以$r||l||i||m_i$一定没有被认证过。</li>
</ol>
<p>现在我们构造一个攻击者A’，目标是先证明<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/8.png?raw=true" alt="8"></p>
<p>构造如下：<br>A’运行A作为子程序，当A请求消息m的标签时，A’自己选择r并根据自己的查询机查询生成标签。当A输出后，A’很容易检查有没有NewBlock，如果有，则输出NewBlock，否则不输出。<br>由此构造很容易看出上式成立。</p>
<p>而又因为$\prod’$是安全的，所以第二项是negl。</p>
<p>到此得证全部。</p>
<h1 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h1><p>上面对于任意长度的MAC实际运行太过复杂，构造效率过低，我们现在来讨论一种更高效的方法。</p>
<h2 id="基本构造"><a href="#基本构造" class="headerlink" title="基本构造"></a>基本构造</h2><p>CBC-MAC 是最早被标准化的消息认证码之一。以下是一个基础版本构造。</p>
<p>首先令F是一个伪随机函数，并固定一个函数$l(n)$。</p>
<ul>
<li>$Mac$：接受一个key和一个message，其中消息的长度为$l(n)\cdot n$。将消息分为$l$个块，每个块的长度为$n$。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2411/MAC/9.png?raw=true" alt="9"><br>输出$t_l$作为标签。</li>
<li>$Vrfy$：先验证长度是否为$l(n)\cdot n$，再验证是否$t=Mac_k(m)$，即标准验证。</li>
</ul>
<p><strong>THEOREM 4.10</strong><br>上述构造的方案对于长度为$l(n)\cdot n$的消息是安全的。</p>
<p>关于这个定理的证明比较复杂，会在后面通过证明一个更一般的结论来获得。</p>
<p>尽管这个构造显然可以通过简单更改来适应不同长度，但该构造仅在认证的消息长度固定且已由发送方和接收方事先约定时是安全的。</p>
<p>和之前的两个构造相比，这个构造更加高效简洁。</p>
<h3 id="CBC-MAC-vs-CBA-mode加密"><a href="#CBC-MAC-vs-CBA-mode加密" class="headerlink" title="CBC-MAC vs CBA-mode加密"></a>CBC-MAC vs CBA-mode加密</h3><ol>
<li>初始化向量的使用<ul>
<li>CBC-mode 使用一个随机的初始化向量</li>
<li>CBC-MAC 使用固定的$0^n$，如果改用随机的，将不再安全。</li>
</ul>
</li>
<li>中间值的输出<ul>
<li>CBC-mode 会将所有中间值作为密文的一部分输出</li>
<li>CBA-MAC 只会输出最后一个块作为标签。如果全部输出，则不安全。</li>
</ul>
</li>
</ol>
<h3 id="对任意长度消息的CBC-MAC"><a href="#对任意长度消息的CBC-MAC" class="headerlink" title="对任意长度消息的CBC-MAC"></a>对任意长度消息的CBC-MAC</h3><p>为简单起见，我们假设所有被认证的消息长度均为n的倍数，且Vrfy对长度不是n倍数的消息直接拒绝。<br>下面介绍两个方法。</p>
<ol>
<li><p>将m的长度编码成n比特的字符串加到消息的开头，然后对结果使用基本CBC-MAC。</p>
<p>注意，如果添加到末尾则不再安全。</p>
</li>
<li><p>使用两个独立的密钥$k_1,k_2$，用$k_1$计算基本CBC-MAC得到t，再计算新标签$t’=F(k_2,t)$。</p>
<p>第二种方法因为在实际应用中使用两个密钥的代价过于昂贵，所以不太理想。</p>
</li>
</ol>
<h2 id="安全性证明-2"><a href="#安全性证明-2" class="headerlink" title="安全性证明"></a>安全性证明</h2><p>这里太过复杂，先略过。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/13/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/13/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">【三】私钥加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-13 16:13:19" itemprop="dateCreated datePublished" datetime="2024-12-13T16:13:19+08:00">2024-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-16 03:20:19" itemprop="dateModified" datetime="2024-12-16T03:20:19+08:00">2024-12-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第三章 Private-Key Encryption</p>
<p>在第二章中我们讨论了完美保密性，这要求密钥空间要大于等于明文空间。但是在现实中，这很难实现，我们需要能够使用较短的密钥来加密较长的信息。所以我们将放宽限制，研究计算保密性。</p>
<h1 id="计算保密性-Computational-Security"><a href="#计算保密性-Computational-Security" class="headerlink" title="计算保密性(Computational Security)"></a>计算保密性(Computational Security)</h1><p>相对于完美保密要求面对有无限计算能力的攻击者也不能泄露任何信息，计算保密放宽了以下两个限制：</p>
<ol>
<li>攻击者的计算能力（计算资源和时间）是有限的</li>
<li>攻击者被允许以很小的概率攻破，只要概率足够小，也被认为是安全的</li>
</ol>
<p>尽管放宽了限制，但是我们仍然要精准定义，所以我们有以下两种方法：</p>
<ol>
<li>具体方法(the Concrete Approach)</li>
<li>渐进方法(the Asymptotic Approach)</li>
</ol>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>形式化定义为：</p>
<p>如果任何攻击者在运行时间不超过$t$的情况下，破解方案成功的概率至多为$\epsilon$，则这个方案被称为$(t,\epsilon)$-安全的。</p>
<p>例如，一个方案可以保证，任何攻击者哪怕使用最强的计算机攻击200年，攻破的概率不超过$2^{-60}$。或者也可以使用计算机周期数来表示时间。</p>
<p>当然，这种方式的定义提供的信息非常有限。</p>
<h2 id="渐进方法"><a href="#渐进方法" class="headerlink" title="渐进方法"></a>渐进方法</h2><p>渐进方法以复杂度理论为基础，引入一个整数$n$作为安全参数(security parameter)，该参数用来描述加密方案的相关信息，比如密钥长度。同时，我们将攻击方的运行时间以及攻击成功概率定义为关于$n$的函数。</p>
<ol>
<li>我们将高效的攻击者定义为运行时间为多项式时间的随机算法(probabilistic polynomial-time, PPT)</li>
<li>我们将成功概率小定义为比任何多项式倒数都小的概率，这种概率被称为可忽略的(negligible)</li>
</ol>
<p>基于此，我们称一个加密方案是安全的当且仅当任意的PPT攻击者攻破的概率都不超可忽略概率。</p>
<p>当然，在最终部署一个加密方案的时候，我们也需要使用具体方法给出安全性定义，因为这是必然要挑选一个确定的$n$。</p>
<h3 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h3><h4 id="Efficient-algorithms"><a href="#Efficient-algorithms" class="headerlink" title="Efficient algorithms"></a>Efficient algorithms</h4><p>一个从自然数到非负实数的函数$f$被称为是<strong>多项式有界</strong>(polynomially bounded)，当且仅当存在一个常数$c$，使得对所有$n$都有$f(n)\leq n^c$。</p>
<p>如果一个算法$A$的运行时间是多项式时间的，那么存在一个多项式函数$p$，对于任意输入$x\in\{0,1\}^*$，那么算法$A(x)$的计算步数最多为$p(|x|)$。</p>
<p>我们将高效攻击者(efficient adversaries)定义为运行时间为安全参数$n$的多项式时间。</p>
<p>默认情况下，我们允许所有算法是<strong>概率的</strong>(probabilistic)，任何这样的算法都假设可以访问一个独立且无偏的随机<br>位序列。</p>
<h4 id="Negligible-success-probability"><a href="#Negligible-success-probability" class="headerlink" title="Negligible success probability"></a>Negligible success probability</h4><p>一个从自然数到非负实数的函数$f$被称为是<strong>可忽略的</strong>(negligible)，当且仅当对于任何一个多项式$p$，存在一个$N$，使得任何$n&gt;N$，都有$f(n)&lt;\frac{1}{p(n)}$。</p>
<p>我们用$negl$来表示这样的函数。</p>
<p>假设$negl_1$和$negl_2$都是可忽略的，那么有以下性质：</p>
<ol>
<li>$negl_1+negl_2$是可忽略的</li>
<li>$p(n)\cdot negl_1(n)$是可忽略的</li>
</ol>
<h1 id="定义计算安全加密"><a href="#定义计算安全加密" class="headerlink" title="定义计算安全加密"></a>定义计算安全加密</h1><p>首先我们稍微修改以下对于私钥加密的定义：</p>
<p>我们使用一个三元组$(Gen,Enc,Dec)$来定义一个私钥加密方案：</p>
<ul>
<li>$Gen$： 是一个概率算法，接受$1^n$作为输入，生成一个密钥$k$，其中不失一般性的假设$|k|\ge n$</li>
<li>$Enc$： 接受一个消息$m$和一个密钥$k$，返回一个密文$c$<ul>
<li>如果这是一个确定算法，我们写作$c:=Enc_k(m)$</li>
<li>如果这是一个概率算法，我们写作$c\leftarrow Enc_k(m)$</li>
</ul>
</li>
<li>$Dec$： 接受一个密文$c$和一个密钥$k$，返回一个消息$m$或者错误符号$\perp$</li>
</ul>
<h2 id="EVA-Security的定义"><a href="#EVA-Security的定义" class="headerlink" title="EVA-Security的定义"></a>EVA-Security的定义</h2><p>我们现在先只考虑仅密文攻击，也就是说攻击者只能观察到一个密文。</p>
<h3 id="不可区分性实验"><a href="#不可区分性实验" class="headerlink" title="不可区分性实验"></a>不可区分性实验</h3><p>现在定义这种情况下的不可区分性实验$PrivK^{eva}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>攻击者$\mathcal{A}$接受输入$1^n$，输出两个消息$m_0,m_1$，其中$|m_0|=|m_1|$</li>
<li>运行$Gen(1^n)$获得$k$，并随机选择$b\in \{0,1\}$，计算$c\leftarrow Enc_k(m_b)$并传输给$\mathcal{A}$</li>
<li>$\mathcal{A}$的输出$b’$，如果$b’=b$，实验结果定义为$1$，写作$Privk^{eva}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>一个私钥加密方案是<strong>EVA-Secure</strong>的，当且仅当对于任何可能的多项式时间攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使对于任意的$n$，有：<script type="math/tex">Pr[PrivK^{eva}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)</script></p>
<p>我们还可以给出一种等价的表达方式，我们定义$out<em>{\mathcal{A}}(PrivK^{eva}</em>{\mathcal{A},\prod}(n,b))$为在这次试验中$\mathcal{A}$的输出结果，则EVA-Secure等价于：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/1.png?raw=true" alt="1"></p>
<h3 id="关于明文长度"><a href="#关于明文长度" class="headerlink" title="关于明文长度"></a>关于明文长度</h3><p>正常情况下，我们不会要求机密方案隐藏明文的长度。</p>
<p>但是在以下的一些特殊情况下，需要隐藏明文长度，因为明文长度就隐含着一些信息：</p>
<ul>
<li>工资有几位数</li>
<li>压缩数据</li>
</ul>
<p>如果我们需要避免泄露明文长度，就需要事先把消息填充到某个预定长度。</p>
<h2 id="语义安全"><a href="#语义安全" class="headerlink" title="语义安全"></a>语义安全</h2><p>我们一开始说明了安全加密的定义意味着对手无法从密文中获取任何部分信息。但是上面的定义貌似没有考虑这一点，现在我们通过引入<strong>语义安全</strong>(dsemantic security)来说明这一点。</p>
<p>首先，我们可以证明以下理论：</p>
<p>对于一个固定长度的加密方案，这是EVA-Secure的，当且仅当对于任何PPT攻击者$\mathcal{A}$和$i$，存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/2.png?raw=true" alt="2"></p>
<p>这很好证明，只需要归约就行。</p>
<p>然后我们可以进一步证明以下理论：</p>
<p>对于一个固定长度的加密方案，这是EVA-Secure的，当且仅当对于任何PPT攻击者$\mathcal{A}$，都存在一个PPT算法$\mathcal{A}’$，使得对于任何在$\{0,1\}^l$上的分布$\mathcal{D}$和任意的函数$f:\{0,1\}^l\rightarrow\{0,1\}$，存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/3.png?raw=true" alt="3"></p>
<p>其中概率中的明文$m$依据$\mathcal{D}$分布。</p>
<p>现在，我们可以结合上面两个理论，来定义语义安全。</p>
<p>对于一个固定长度的加密方案，这是语义安全的，当且仅当对于任何PPT攻击者$\mathcal{A}$，都存在一个PPT算法$\mathcal{A}’$，使得对于任何PPT算法$Samp$和多项式时间可计算的函数$f,h$，都能使下式为可忽略的函数：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/4.png?raw=true" alt="4"></p>
<p>其中的明文是根据$Samp$分布的，而这里$h$表示任何攻击者可能获得的信息。</p>
<p>最终，我们给出结论：</p>
<p>语义安全和EVA安全是等价的。</p>
<h1 id="构造EVA安全的加密方案"><a href="#构造EVA安全的加密方案" class="headerlink" title="构造EVA安全的加密方案"></a>构造EVA安全的加密方案</h1><h2 id="伪随机数生成器"><a href="#伪随机数生成器" class="headerlink" title="伪随机数生成器"></a>伪随机数生成器</h2><p>伪随机数生成器$G$是一个高效的确定性算法，功能是将一个比较短的均匀字符串转换为一个较长的伪随机字符串。</p>
<p>有一些简单的统计方法用来判断伪随机数生成器是否良好，比如，测试伪随机数生成的第一个比特是否以$\frac{1}{2}$的概率为1，但是这样是不严谨的。</p>
<p>我们希望有更严格的测试方式，比如，面对任意的区分器$\mathcal{D}$，我们都希望接收到伪随机数生成器的输出返回1的概率等于一个真实的伪随机数，这意味着伪随机数生成器对于任何高效的观察者看起来都和真的随机生成的均匀的字符串差不多。</p>
<h3 id="形式化定义-1"><a href="#形式化定义-1" class="headerlink" title="形式化定义"></a>形式化定义</h3><p>令$G$是一个确定性的多项式时间算法，对于任意的$n$和输入$s\in\{0,1\}^n$，$G$返回一个长度为$l(n)$的伪随机字符串。$G$是一个伪随机数生成器当且仅当：</p>
<ol>
<li>$l(n)&gt;n$，这里$l(n)$被称为the expansion factor。</li>
<li>对于任何PPT算法$D$，都存在一个$negl$使：<script type="math/tex; mode=display">|Pr[D(G(s))=1]-Pr[D(r)=1]|\leq negl(n)</script>其中$s$在$\{0,1\}^n$中被均匀选取，$r$在$\{0,1\}^{l(n)}$中被均匀选取。</li>
</ol>
<h3 id="伪随机数生成器的相关讨论"><a href="#伪随机数生成器的相关讨论" class="headerlink" title="伪随机数生成器的相关讨论"></a>伪随机数生成器的相关讨论</h3><p>当然，我们不妨设想这样一个例子，当$l(n)=2n$，这使得能落入$G$生成范围的数占总数的$\frac{2^n}{2^{2n}}=\frac{1}{2^n}$。显然暴力攻击能轻松分辨出伪随机数生成器和真实的随机数，但是这并不能算高效的区分器。</p>
<p>关于伪随机数生成器种子的选取，种子的作用和加密方案的密钥其实是类似的，我们同样需要种子长度足够大来抵抗暴力攻击。</p>
<p>关于伪随机数生成器的存在性，显然直接想构造是很困难的，但是我们可以相信对于任何多项式扩展因子的伪随机数生成器都是存在的。在一个较弱的假设下，如果单向函数存在，伪随机数生成器是存在的，此外，我们还可以通过流密码等方式来构造伪随机数生成器，目前还没有发现针对性的高效区分器。</p>
<p>目前我们先假设伪随机数生成器存在。</p>
<h2 id="归约证明法"><a href="#归约证明法" class="headerlink" title="归约证明法"></a>归约证明法</h2><p>如果我们要证明一个加密方案$\prod$是安全的，通常我们会经过以下步骤：</p>
<ol>
<li>假设对于方案$\prod$，存在PPT攻击者$\mathcal{A}$，攻破方案的概率为$\epsilon(n)$</li>
<li>构造一个攻击者$\mathcal{A}’$，其试图攻破问题$X$并以$\mathcal{A}$为子进程。这里$\mathcal{A}’$并不需要知道$\mathcal{A}$具体怎么攻破。<ol>
<li>$\mathcal{A}’$要为$\mathcal{A}$模拟一个$\prod$的交互环境</li>
<li>当$\mathcal{A}$能成功破解$\prod$时，$\mathcal{A}’$要成功破解$X$以至少多项式倒数的概率($\frac{1}{p(n)}$)。</li>
</ol>
</li>
<li>综上分析，$\mathcal{A}’$攻破的成功概率为$\frac{\epsilon(n)}{p(n)}$，当$\epsilon(n)$是不可忽略的时候，整体也是不可忽略的。</li>
<li>基于我们对问题$X$的假设，$X$是难解的，这也就意味着如果$\mathcal{A}$能有较大概率攻破$\prod$，那么$\mathcal{A}’$也能攻破问题$X$，矛盾，因此该加密方案是安全的。</li>
</ol>
<h2 id="伪随机数生成器构造EVA-Security"><a href="#伪随机数生成器构造EVA-Security" class="headerlink" title="伪随机数生成器构造EVA-Security"></a>伪随机数生成器构造EVA-Security</h2><p>我们可以通过更改One-Time Pad的密钥生成方式来构造一个EVA-Secure的加密方案。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><p>令$G$是一个扩展因子为$l(n)$的伪随机数生成器。</p>
<ol>
<li>$Gen$：均匀选取$k\in \{0,1\}^n$</li>
<li>$Enc$：$c:=G(k)\oplus m$</li>
<li>$Dec$：$m:=c\oplus G(k)$</li>
</ol>
<p>注意，这个方案是定长的。</p>
<h3 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>首先直接给出结论，这个方案是EVA-secure的。</p>
<p>我们的目标是证明：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/5.png?raw=true" alt="5"></p>
<p>我们构造以下区分器$\mathcal{D}$，接受$\omega\in \{0,1\}^l$作为输入：</p>
<ol>
<li>运行$\mathcal{A}(1^n)$，获得两个输出$m_0,m_1$</li>
<li>均匀随机挑选$b\in \{0,1\}$，令$c:=\omega\oplus m_b$</li>
<li>将$c$返回给$\mathcal{A}$，获得输出$b’$，如果$b=b’$，则返回1，否则返回0。</li>
</ol>
<p>又因为$G$是一个伪随机数生成器，所以一定有：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/6.png?raw=true" alt="6"></p>
<p>而考虑$\omega$的来源：</p>
<ol>
<li>$\omega$是均匀选取的，则有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/7.png?raw=true" alt="7"></li>
<li>$\omega$是$G$生成的，则有<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/8.png?raw=true" alt="8"></li>
</ol>
<p>结合上式我们可以得到：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/9.png?raw=true" alt="9"></p>
<p>完成了证明。</p>
<h1 id="更强的安全性概念"><a href="#更强的安全性概念" class="headerlink" title="更强的安全性概念"></a>更强的安全性概念</h1><p>到目前为止我们只讨论了当攻击者仅被允许窃听单个密文的情况，但是显然实际生活中攻击方可以更加强大。</p>
<h2 id="多重加密的安全性"><a href="#多重加密的安全性" class="headerlink" title="多重加密的安全性"></a>多重加密的安全性</h2><p>现在考虑攻击者可以监听到多个用同一个密钥加密的密文。</p>
<p>我们可以定义以下的安全性实验，多消息窃听实验$PrivK^{mult}_{\mathcal{A},\prod}(n)$:</p>
<ol>
<li>攻击者$\mathcal{A}$接受输入$1^n$，输出两个消息向量$\vec{M<em>0},\vec{M_1}$，其中$|m</em>{0,i}|=|m_{1,i}|$</li>
<li>运行$Gen(1^n)$获得$k$，并随机选择$b\in \{0,1\}$，计算$c<em>i \leftarrow Enc_k(m</em>{b,i})$并将$\vec{C}$传输给$\mathcal{A}$</li>
<li>$\mathcal{A}$的输出$b’$，如果$b’=b$，实验结果定义为$1$，写作$Privk^{eva}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>一个加密方案是多消息不可区分的，当且仅当对于任何可能的多项式时间攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使对于任意的$n$，有：</p>
<script type="math/tex; mode=display">Pr[PrivK^{mult}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)</script><p>很显然，对于单密文不可区分的加密方案，多密文下很可能是可区分的，比如当加密算法是确定性算法时，我们就很容易构造输入来进行区分。</p>
<p>甚至我们有以下定理，当一个加密方案的加密算法是确定性的，这个方案一定不是多消息不可区分的。</p>
<p>所以在这种情况下，我们必须要设计随机化加密方案，使同样的消息经过同一个密钥加密也可以生成不同的密文。</p>
<h2 id="选择明文攻击-Chosen-Plaintext-Attacks-和CPA-Security"><a href="#选择明文攻击-Chosen-Plaintext-Attacks-和CPA-Security" class="headerlink" title="选择明文攻击(Chosen-Plaintext Attacks)和CPA-Security"></a>选择明文攻击(Chosen-Plaintext Attacks)和CPA-Security</h2><p>我们现在考虑攻击者可以影响甚至控制明文，使得攻击者可以获取对应的密文。</p>
<h3 id="CPA不可区分性实验"><a href="#CPA不可区分性实验" class="headerlink" title="CPA不可区分性实验"></a>CPA不可区分性实验</h3><p>现在定义这种情况下的不可区分性实验$PrivK^{cpa}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>运行$Gen(1^n)$获得$k$</li>
<li>攻击者$\mathcal{A}$接受输入$1^n$，并获得一个查询$Enc_k(\cdot)$的权限(oracle)，输出两个消息$m_0,m_1$，其中$|m_0|=|m_1|$</li>
<li>，并随机选择$b\in \{0,1\}$，计算$c\leftarrow Enc_k(m_b)$并传输给$\mathcal{A}$</li>
<li>$\mathcal{A}$仍然有查询$Enc_k(\cdot)$的权限，最终输出$b’$</li>
<li>如果$b’=b$，实验结果定义为$1$，写作$Privk^{eva}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>一个加密方案是<strong>CPA-Secure</strong>的，当且仅当对于任何可能的多项式时间攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使对于任意的$n$，有：<script type="math/tex">Pr[PrivK^{cpa}_{\mathcal{A},\prod}(n)=1]\leq \frac{1}{2}+negl(n)</script></p>
<p>当然，任何CPA安全的私钥加密档案对于多消息加密仍然是CPA安全的。</p>
<h3 id="固定长度-vs-任意长度"><a href="#固定长度-vs-任意长度" class="headerlink" title="固定长度 vs 任意长度"></a>固定长度 vs 任意长度</h3><p>理论上，只要有固定长度的加密方案，我们就可以把它扩展到任意长度，只需要对消息进行切割或扩充，但是这样的方案会带来较大的开销，效率比较低。</p>
<h1 id="构造CPA安全的加密方案"><a href="#构造CPA安全的加密方案" class="headerlink" title="构造CPA安全的加密方案"></a>构造CPA安全的加密方案</h1><h2 id="伪随机函数-Pseudorandom-functions-PRFs-和伪随机置换-Permutations"><a href="#伪随机函数-Pseudorandom-functions-PRFs-和伪随机置换-Permutations" class="headerlink" title="伪随机函数(Pseudorandom functions, PRFs)和伪随机置换(Permutations)"></a>伪随机函数(Pseudorandom functions, PRFs)和伪随机置换(Permutations)</h2><h3 id="伪随机函数"><a href="#伪随机函数" class="headerlink" title="伪随机函数"></a>伪随机函数</h3><p>我们无法说某个固定函数$f:\{0,1\}^<em>\rightarrow\{0,1\}^</em>$是随机的，这里，我们引入一个带密钥函数(keyed functions)。</p>
<p>带密钥函数(keyed functions)可以被看作有两个输入，即$F:\{0,1\}^<em> \times \{0,1\}^</em> \rightarrow \{0,1\}^*$。其中，第一个输入为密钥，第二个输入为函数的常规输入。我们只考虑能被在多项式时间内计算的函数。同时，我们先不妨假设密钥长度、输入长度和输出长度相等。</p>
<p>直观上，我们定义$Func_n$是n比特映射到n比特的函数的集合，令$f$是从中任意选取的一个函数，令$F_k(x)=F(k,x)$，我们希望无法区分$f$和$F_k$。</p>
<p>当然，假设这里有一个区分器来尝试区分，显然如果知道一个函数详细的描述，是很容易区分的，但是这并不高效，也就是不能在多项式时间内完成。所以我们不妨规定区分器不能接受函数的完整描述，但是能够有一个查询接口，可以对任意的输入$x$查询函数对应的值，当然，也只能进行多项式次数的查询。</p>
<h4 id="形式化定义-2"><a href="#形式化定义-2" class="headerlink" title="形式化定义"></a>形式化定义</h4><p>现在我们可以给出形式化定义，我们定义一个带密钥函数$F$为一个伪随机函数，当且仅当对于任何多项式时间区分器$D$，都存在一个可忽略函数$negl$，使：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/10.png?raw=true" alt="10"></p>
<h4 id="伪随机函数和伪随机数生成器"><a href="#伪随机函数和伪随机数生成器" class="headerlink" title="伪随机函数和伪随机数生成器"></a>伪随机函数和伪随机数生成器</h4><p>伪随机函数 (PRFs) 和伪随机生成器 (PRGs) 之间具有密切的关系。他们其实可以相互构造。</p>
<h3 id="伪随机置换"><a href="#伪随机置换" class="headerlink" title="伪随机置换"></a>伪随机置换</h3><p>伪随机置换要求在伪随机函数的基础上还要是双射，同时逆函数也要能在多项式时间内被计算。</p>
<p>显然，伪随机置换一定是一个伪随机函数。</p>
<p>形式化定义如下：<br>我们定义一个带密钥函数$F$为一个强伪随机置换(strong pseudorandom permutation)，当且仅当对于任何多项式时间区分器$D$，都存在一个可忽略函数$negl$，使：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/11.png?raw=true" alt="11"></p>
<h2 id="构造CPA安全的加密方案-1"><a href="#构造CPA安全的加密方案-1" class="headerlink" title="构造CPA安全的加密方案"></a>构造CPA安全的加密方案</h2><p>这里的目标是构造一个固定长度的CPA安全的加密方案。根据之前的结论，只要有固定长度的，我们可以扩展到任意长度。</p>
<h3 id="方案-1"><a href="#方案-1" class="headerlink" title="方案"></a>方案</h3><p>令$F$是一个伪随机数函数。</p>
<ol>
<li>$Gen$：均匀选取$k\in \{0,1\}^n$</li>
<li>$Enc$：均匀选取$r\in \{0,1\}^n$，$c:=&lt; r, F_k(r)\oplus m &gt;$</li>
<li>$Dec$：$m:=F_k(r)\oplus s$</li>
</ol>
<h3 id="安全性证明-1"><a href="#安全性证明-1" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>一般来说我们证明加密方案的CPA安全性会采用以下步骤：</p>
<ol>
<li>首先考虑用真随机函数来代替伪随机函数，通过归约证明这样修改不会显著提高攻击者的成功概率。</li>
<li>在假设方案中，通过概率计算来评估攻击成功的概率，这一部分一般不依赖于假设。</li>
</ol>
<p>上述方案安全性证明如下：<br>首先我们令方案$\tilde{\prod}$为将伪随机函数替换成真随机函数后的方案，我们将通过归约证明：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/12.png?raw=true" alt="12"></p>
<p>我们构造一个区分器$D$，其接受输入$1^n$并有一个未知函数的查询机$\mathcal{O}$。</p>
<ol>
<li>运行$\mathcal{A}(1^n)$，当$\mathcal{A}$查询时：<ol>
<li>$D$均匀选取$r\in \{0,1\}^n$</li>
<li>查询$y=\mathcal{O}(r)$</li>
<li>将$&lt; r,y \oplus m &gt;$返回给$\mathcal{A}$</li>
</ol>
</li>
<li>$\mathcal{A}$输出消息$m_0,m_1$，随机选取$b\in \{0,1\}$<ol>
<li>$D$均匀选取$r\in \{0,1\}^n$</li>
<li>查询$y=\mathcal{O}(r)$</li>
<li>将$&lt; r,y \oplus m_b &gt;$返回给$\mathcal{A}$</li>
</ol>
</li>
<li>接受$\mathcal{A}$的最终输出$b’$，如果$b’=b$，输出1，否则输出0。</li>
</ol>
<p>由构造我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/13.png?raw=true" alt="13"></p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/14.png?raw=true" alt="14"></p>
<p>在因为$F$是伪随机函数，根据定义我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/15.png?raw=true" alt="15"></p>
<p>到此我们已经证明了第一步。</p>
<p>第二部分我们将证明</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/16.png?raw=true" alt="16"></p>
<p>我们定义事件$repeat$为$r$已经被使用过，所以有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/17.png?raw=true" alt="17"></p>
<p>最后将两个部分结合，我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/18.png?raw=true" alt="18"></p>
<p>到此得证。</p>
<h1 id="加密模式与实践中的加密"><a href="#加密模式与实践中的加密" class="headerlink" title="加密模式与实践中的加密"></a>加密模式与实践中的加密</h1><p>上述的加密方案在实践中都存在一些缺点，比如效率差限制多等。我们接下来要提出一些实际操作上更优的加密方案。</p>
<p>首先我们会引入其中的核心部分</p>
<ul>
<li>使用<strong>流密码</strong>来实现伪随机数生成器</li>
<li>使用<strong>分组密码</strong>来实现伪随机函数</li>
</ul>
<h2 id="流密码-Stream-ciphers"><a href="#流密码-Stream-ciphers" class="headerlink" title="流密码(Stream ciphers)"></a>流密码(Stream ciphers)</h2><p>流密码是一组确定性算法：</p>
<ol>
<li><strong>Init</strong>：$st_0:=Init(s,[IV])$</li>
<li><strong>GetBits</strong>：$(y<em>i,st_i):=GetBits(st</em>{i-1})$</li>
</ol>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/23.png?raw=true" alt="23"></p>
<h2 id="分组密码-Block-ciphers"><a href="#分组密码-Block-ciphers" class="headerlink" title="分组密码(Block ciphers)"></a>分组密码(Block ciphers)</h2><h3 id="ECB-mode"><a href="#ECB-mode" class="headerlink" title="ECB mode"></a>ECB mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/19.png?raw=true" alt="19"></p>
<p>这是确定性算法，所以是不安全的。</p>
<h3 id="CBC-mode"><a href="#CBC-mode" class="headerlink" title="CBC mode"></a>CBC mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/20.png?raw=true" alt="20"></p>
<p>如果$F$是伪随机函数，则方案是CPA安全的。</p>
<p>缺点是不能并行化处理。</p>
<h3 id="OFP-mode"><a href="#OFP-mode" class="headerlink" title="OFP mode"></a>OFP mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/21.png?raw=true" alt="21"></p>
<p>如果$F$是伪随机函数，则方案是CPA安全的。</p>
<p>可以进行预计算。</p>
<h3 id="CTR-mode"><a href="#CTR-mode" class="headerlink" title="CTR mode"></a>CTR mode</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E7%A7%81%E9%92%A5%E5%8A%A0%E5%AF%86/22.png?raw=true" alt="22"></p>
<p>如果$F$是伪随机函数，则方案是CPA安全的。</p>
<p>加密和解密都可以并行化计算。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/13/%E5%AE%8C%E7%BE%8E%E4%BF%9D%E5%AF%86%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/13/%E5%AE%8C%E7%BE%8E%E4%BF%9D%E5%AF%86%E6%80%A7/" class="post-title-link" itemprop="url">【二】完美保密性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-13 14:43:28 / 修改时间：16:19:30" itemprop="dateCreated datePublished" datetime="2024-12-13T14:43:28+08:00">2024-12-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第二章 Perfectly Secret Encryption</p>
<p>在本章中，我们将探讨另一个极端，即研究即使面对具有无限计算能力的攻击者也能被证明安全的加密方案。这类方案被称为完美安全(perfectly secret)。</p>
<p>为了简化讨论，我们假设可以各方都可以获得无限供应的独立无偏的随机位。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先回顾上一章介绍的加密语法，我们使用一个消息空间$\mathcal{M}$和一个三元组$(Gen,Enc,Dec)$来定义一个私钥加密方案：</p>
<ul>
<li>$Gen$： 是一个概率算法，依据某些分布生成一个密钥$k$，$\mathcal{K}$表示密钥空间。</li>
<li>$Enc$： 接受一个消息$m$和一个密钥$k$，返回一个密文$c$，$\mathcal{C}$表示密文集合<ul>
<li>如果这是一个确定性算法，我们写作$c:=Enc_k(m)$</li>
<li>如果这是一个概率性算法，我们写作$c\leftarrow Enc_k(m)$</li>
</ul>
</li>
<li>$Dec$： 接受一个密文$c$和一个密钥$k$，返回一个消息$m$，$\mathcal{M}$表示明文集合。显然这里解密算法是一个确定性算法</li>
</ul>
<h2 id="完美安全性-Perfectly-Secrecy"><a href="#完美安全性-Perfectly-Secrecy" class="headerlink" title="完美安全性(Perfectly Secrecy)"></a>完美安全性(Perfectly Secrecy)</h2><p>现在假设攻击者的能力是：</p>
<ol>
<li>知道加密方案</li>
<li>观察到密文</li>
</ol>
<p>一个完美安全的加密方案要求攻击者观察到密文对实际的发送明文的概率没有影响。换句话说，观察到密文对消息选择的先验概率和后验概率应当是相同的。</p>
<h3 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h3><p>一个加密方案是<strong>完美安全的</strong>，如果对于消息空间$\mathcal{M}$的任意概率分布，任意消息$m\in \mathcal{M}$，任意密文$c\in \mathcal{C}$（其中$Pr[C=c]&gt;0$），有：</p>
<script type="math/tex; mode=display">Pr[M=m|C=c]=Pr[M=m]</script><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>一个加密方案是完美安全的，当且仅当对于任意$m,m’\in \mathcal{M}$，任意$c\in \mathcal{C}$，有：</p>
<script type="math/tex; mode=display">Pr[C=c|M=m]=Pr[C=c|M=m']</script><h3 id="完美不可区分性"><a href="#完美不可区分性" class="headerlink" title="完美不可区分性"></a>完美不可区分性</h3><p>现在介绍一个实验：</p>
<ol>
<li>攻击者$\mathcal{A}$指定任意两个消息$m_0,m_1\in \mathcal{M}$</li>
<li>$Gen$生成一个密钥$k$</li>
<li>随机选择一个$b\in \{0,1\}$，计算密文$c\leftarrow Enc_k(m_b)$</li>
<li>将密文$c$返回给攻击者$\mathcal{A}$</li>
<li>攻击者给出一个猜测值$b’\in \{0,1\}$，如果$b’=b$，实验结果定义为$1$，写作$Privk^{eav}_{\mathcal{A},\prod}=1$，反之实验结果为$0$</li>
</ol>
<p>在攻击者完全随机猜测的情况下，实验结果为$1$的概率为$\frac{1}{2}$。完美保密性的目的就是希望攻击者任何选择的策略都不能优于随机猜测。</p>
<p>有定义如下：<br>一个方案是<strong>完美不可区分的</strong>当且仅当对于任何攻击者$\mathcal{A}$，都有：</p>
<script type="math/tex; mode=display">Pr[Privk^{eav}_{\mathcal{A},\prod}=1]=\frac{1}{2}</script><p>有引理如下：<br>完美保密性和完美不可区分性是等价的。</p>
<h1 id="One-Time-Pad"><a href="#One-Time-Pad" class="headerlink" title="One-Time Pad"></a>One-Time Pad</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>对于固定长度$l$，我们定义该方案的明文空间、密钥空间和密文空间都为$\{0,1\}^l$：</p>
<ul>
<li>$Gen$：从密钥空间中均匀随机选取一个密钥</li>
<li>$Enc$：$c:=m\oplus  k$</li>
<li>$Dec$：$m:=c\oplus k$</li>
</ul>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>这个方案是完美安全的。</p>
<p>但是这个方案存在限制，密钥只能使用一次，如果多次使用就会变得不安全。这就要求每次加密都要重新生成密钥，这是很麻烦的。</p>
<h1 id="完美安全的限制"><a href="#完美安全的限制" class="headerlink" title="完美安全的限制"></a>完美安全的限制</h1><p>我们将证明：任何完美安全的加密方案的密钥空间大小必须至少与消息空间大小相等。</p>
<p>形式化的：</p>
<p>对于一个完美安全的加密方案，有$|\mathcal{K}|\ge |\mathcal{M}|$</p>
<p>证明如下：</p>
<p>假设$|\mathcal{K}|&lt;|\mathcal{M}|$，对于一个密文，其被不同密钥解密出的明文集合大小必然等于密钥空间大小，即小于明文空间大小。这就说明存在一个密文，有对应的明文无论什么密钥都无法加密称为该密文。即：</p>
<script type="math/tex; mode=display">\exists m',c,s.t. Pr[M=m'|C=c]=0\not =Pr[M=m']</script><p>违背了完美安全的定义。</p>
<h1 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h1><p>令$(Gen,Enc,Dec)$是一个明文空间为$\mathcal{M}$的加密方案，并且$|\mathcal{M}|=|\mathcal{C}|=|\mathcal{K}|$，这个方案是完美安全的当且仅当满足以下条件：</p>
<ol>
<li>任意密钥被$Gen$以$\frac{1}{\mathcal{K}}$的概率选择</li>
<li>对于任意$m\in\mathcal{M},c\in \mathcal{C}$，只存在一个唯一的$k\in \mathcal{K}$使得$c:=Enc_k(m)$</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BC%95%E5%85%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/12/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%BC%95%E5%85%A5/" class="post-title-link" itemprop="url">【一】密码学引入</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-12 19:47:28" itemprop="dateCreated datePublished" datetime="2024-12-12T19:47:28+08:00">2024-12-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-13 14:44:16" itemprop="dateModified" datetime="2024-12-13T14:44:16+08:00">2024-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第一章 Introduction</p>
<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><p>在牛津词典中，密码学被定义为编写或破译密码的艺术。该定义只关注用来实现秘密通信的各类密码，但是现代密码学涵盖了更多更广的领域：确保数据完整性的机制、交换秘密密钥的技术、用户认证的协议、电子投票、加密货币等等。</p>
<h1 id="私钥加密的设定"><a href="#私钥加密的设定" class="headerlink" title="私钥加密的设定"></a>私钥加密的设定</h1><p>古典密码学关注的是设计和使用能够使两方在信息传递过程中保持消息机密的密码（或称密文）的方法。在现代密码学中，我们称之为加密方案(encryption scheme)，所有的古典加密方案都依赖于一个事先双方共享的密钥-私钥(private-key)。</p>
<p>在私钥加密的背景下，双方共享一把密钥，一方使用密钥进行加密获得密文，一方使用密钥进行解密获得明文。解密和加密使用相同的密钥，这被称为<strong>对称密钥</strong>(symmetric-key)。</p>
<p>私钥密码学有两个典型应用场景：</p>
<ul>
<li>同一时间下不同空间的通信</li>
<li>同一空间下不同时间的通信</li>
</ul>
<h2 id="加密的语法"><a href="#加密的语法" class="headerlink" title="加密的语法"></a>加密的语法</h2><p>形式化上，我们使用一个消息空间$\mathcal{M}$和一个三元组$(Gen,Enc,Dec)$来定义一个私钥加密方案：</p>
<ul>
<li>$Gen$： 是一个概率算法，依据某些分布生成一个密钥$k$</li>
<li>$Enc$： 接受一个消息$m$和一个密钥$k$，返回一个密文$c$</li>
<li>$Dec$： 接受一个密文$c$和一个密钥$k$，返回一个消息$m$</li>
</ul>
<p>对于$\forall m\in \mathcal{M},Dec_k(Enc_k(m))=m$</p>
<p>我们用$\mathcal{K}$来表示密钥空间，用$\mathcal{C}$来表示密文空间。</p>
<h2 id="克克霍夫原则（Kerckhoffs’-principle）"><a href="#克克霍夫原则（Kerckhoffs’-principle）" class="headerlink" title="克克霍夫原则（Kerckhoffs’ principle）"></a>克克霍夫原则（Kerckhoffs’ principle）</h2><p>密码方法不应依赖于保密，甚至在其落入敌手后也不应造成不便。</p>
<p>也就是说，即使对手知道方案的所有细节，只要对手不知道所用的密钥，加密方案仍应保持安全性。换句话说，安全性不应建立在加密方案本身的保密之上；克克霍夫原则要求安全性仅依赖于密钥的保密。</p>
<h1 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h1><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><p>经典的移位密码，把每个字母统一往后移动$k$位，只需要尝试最多25次就可以破解，所以这也暗示了一个安全的加密方案应该要能够抵抗暴力破解，至少密钥空间要足够大。</p>
<h2 id="单字母替换密码"><a href="#单字母替换密码" class="headerlink" title="单字母替换密码"></a>单字母替换密码</h2><p>这里使用一个字母表的双射来函数来实现加密，显然密钥空间很大(26!)。</p>
<p>可以通过词频分析来进行有效率的攻击。</p>
<h1 id="现代密码学原则"><a href="#现代密码学原则" class="headerlink" title="现代密码学原则"></a>现代密码学原则</h1><p>古典密码学依赖的更多是经验和直觉。如今，人们以更为系统化的方式设计和分析密码方案，最终目标是对给定构造是否安全给出严格的证明。为了实现这一点，我们首先需要形式化的定义，以精确界定“安全”的含义；这些定义本身就很有价值和趣味性。事实证明，大多数密码学证明都依赖于目前尚未证实的假设，即关于某些数学问题的算法求解难度的假设；因此我们必须明确并精确地陈述这些假设。</p>
<h2 id="原则1-形式化定义"><a href="#原则1-形式化定义" class="headerlink" title="原则1-形式化定义"></a>原则1-形式化定义</h2><p>明确的定义有助于指导密码学方案的设计。定义还为对具体构造进行评估和分析提供了途径。</p>
<h2 id="原则2-精确假设"><a href="#原则2-精确假设" class="headerlink" title="原则2-精确假设"></a>原则2-精确假设</h2><p>大多数现代密码学构造无法无条件地证明其安全性；要给出无条件的证明意味着要解决计算复杂性理论中当前仍远未能解答的问题。</p>
<p>现代密码学要求任何此类假设都必须明确、精确地加以阐述。最基本的原因是，安全性证明本身需要精确的假设。</p>
<p>人们通常倾向于使用“更简单”的假设——也就是对某个简洁明了的数学问题的难度假设，而非对一个复杂方案满足复杂安全定义的假设。</p>
<h2 id="原则3-安全性证明"><a href="#原则3-安全性证明" class="headerlink" title="原则3-安全性证明"></a>原则3-安全性证明</h2><p>借助前面讨论的两个原则（明确的定义与精确定义的假设），我们即可实现目标：在给定的假设条件下，严格证明某个构造满足相应的安全性定义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/11/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">【四】下推自动机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-11 19:25:50" itemprop="dateCreated datePublished" datetime="2024-12-11T19:25:50+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-18 18:53:27" itemprop="dateModified" datetime="2024-12-18T18:53:27+08:00">2024-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h1><p><strong>下推自动机(Pushdown Automata, PDA)</strong> 是一种在语言的定义能力上和 CFG 等价的自动机。不过只有非确定性下推自动机才能定义所有的上下文无关语言。但是确定性下推自动机可以为解析器建模，并且大多数的程序设计语言都有确定性的下推自动机，因为确定的才是可实现的。</p>
<p>直观上看，PDA就是一个$\epsilon-$NFA具有额外颠倒操作一个栈的能力。其移动不仅依靠当前状态和输入符号，还依赖于栈顶元素。</p>
<h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p><strong>下推自动机</strong>(Pushdown Automata)为一个七元组$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$：</p>
<ul>
<li>$Q$为有限状态集合</li>
<li>$\Sigma$为输入字母表</li>
<li>$\Gamma$为栈字母表</li>
<li>$\delta$是转移函数<ul>
<li>接受三个参数：当前状态、当前输入符号、栈顶元素</li>
<li>$\delta(q,a,Z)=(p,\alpha)$，其中$p\in Q,\alpha\in\Gamma^*$，即转移到新状态并将栈顶符号替换为$\alpha$</li>
</ul>
</li>
<li>$q_0\in Q$为初始状态</li>
<li>$Z_0\in\Gamma$为初始栈顶元素</li>
<li>$F\subseteq Q$为终止状态集合</li>
</ul>
<p>一些字母上的约定：</p>
<ul>
<li>用$a,b,c\cdots,\epsilon$表示输入符号</li>
<li>用$\cdots,X,Y,Z$表示栈符号</li>
<li>用$w,x,y,z$表示输入符号形成的字符串</li>
<li>用$\alpha,\beta,\cdots$来表示栈符号形成的字符串</li>
</ul>
<h2 id="PDA的运行"><a href="#PDA的运行" class="headerlink" title="PDA的运行"></a>PDA的运行</h2><p>定义一个<strong>即时描述</strong>(Instantaneous Description, ID)是一个三元组$(q,w,\alpha)$：</p>
<ul>
<li>$q$是当前状态</li>
<li>$w$是剩余未处理的输入符号</li>
<li>$\alpha$是栈的内容，规定左侧为栈顶，右侧为栈底</li>
</ul>
<p>定义即时描述之间的转移为<strong>走向(Goes-To)</strong>，用$\vdash $表示。</p>
<h2 id="PDA的语言"><a href="#PDA的语言" class="headerlink" title="PDA的语言"></a>PDA的语言</h2><p>我们有两种方式来定义PDA的语言。</p>
<h3 id="根据终止状态"><a href="#根据终止状态" class="headerlink" title="根据终止状态"></a>根据终止状态</h3><p>接受所有能让PDA走到终止状态的字符串，定义为$L(P)$。</p>
<h3 id="根据空栈"><a href="#根据空栈" class="headerlink" title="根据空栈"></a>根据空栈</h3><p>接受所有能让PDA的栈为空的字符串，定义为$N(P)$。</p>
<h3 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h3><p>$L(P)$和$N(P)$在定义语言的能力上是等价的。</p>
<p>若$L=L(P)$，则存在另一个PDA $P’$使 $L=N(P’)$</p>
<p>只需要到终止状态再清除栈即可。</p>
<p>若$L=N(P)$，则存在另一个PDA $P’’$使 $L=L(P’’)$</p>
<p>只需要发现栈被清空之后转移到终止状态即可。</p>
<h2 id="确定性下推自动机与非确定性下推自动机"><a href="#确定性下推自动机与非确定性下推自动机" class="headerlink" title="确定性下推自动机与非确定性下推自动机"></a>确定性下推自动机与非确定性下推自动机</h2><p>我们上面讨论的下推自动机都是<strong>非确定性下推自动机(Nondeterminstic Pushdown Automata, NPDA)</strong>。一般来说，没有特别说明，PDA都指NPDA。</p>
<p>现在来关注一下<strong>确定性下推自动机(Determinstic Pushdown Automata, DPDA)</strong>，即对于确定的状态、输入符号和栈顶符号，最多只有一种移动的选择。</p>
<p>我们直到NFA和DFA是等价的，但是在这里，NPDA的表达能力比DPDA要强。</p>
<h1 id="下推自动机与上下文无关文法的等价性"><a href="#下推自动机与上下文无关文法的等价性" class="headerlink" title="下推自动机与上下文无关文法的等价性"></a>下推自动机与上下文无关文法的等价性</h1><p><strong>定理</strong>：<br>CFG和PDA在定义语言的表达能力上是等价的。</p>
<h2 id="CFG转变为PDA"><a href="#CFG转变为PDA" class="headerlink" title="CFG转变为PDA"></a>CFG转变为PDA</h2><p>对于CFG $G$，令$L=L(G)$，我们可以构造一个PDA $P$，使$N(P)=L$。</p>
<p>思路就是$P$的每一步代表最左推导中的一步。</p>
<h2 id="PDA转变为CFG"><a href="#PDA转变为CFG" class="headerlink" title="PDA转变为CFG"></a>PDA转变为CFG</h2><p>对于PDA $P$，令$L=N(G)$，我们可以构造一个CGL $G$，使$L=L(G)$。</p>
<p>思路是$G$中的每一个符号都形如$[pXq]$，对应一个输入使$P$从$p$转移到$q$，并且弹出栈顶符号$X$。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/11/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/11/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/" class="post-title-link" itemprop="url">【三】上下文无关文法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-11 18:06:39" itemprop="dateCreated datePublished" datetime="2024-12-11T18:06:39+08:00">2024-12-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-18 19:02:55" itemprop="dateModified" datetime="2024-12-18T19:02:55+08:00">2024-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h1><p>正则语言的表达能力存在局限性，比如正则语言并不能表达回文串。现在我们介绍一种表达能力更强的语言，上下文无关文法。</p>
<h2 id="直观描述"><a href="#直观描述" class="headerlink" title="直观描述"></a>直观描述</h2><p><strong>上下文无关文法</strong>(context-free grammar)是一种描述语言的记号，对于描述嵌套结构是很有用的。</p>
<h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>定义<strong>上下文无关文法</strong>(context-free grammar,CFG)是一个四元组$G=(V,T,P,S)$:</p>
<ul>
<li>$T$为CFG要定义语言的字母表，称为<strong>终结符</strong>(Terminals)。</li>
<li>$V$为一个有限的其他符号的集合，每个符号代表了一个语言，称为<strong>变量</strong>(Variables)或者<strong>非终结符</strong>(Nonterminals)。</li>
<li>$S$为CFG要定义的语言变量，称为<strong>起始符号(Start Symbol)</strong>。</li>
<li>$P$为CFG的<strong>产生式</strong>(productions)集合，形如$head\rightarrow body$。<ul>
<li><strong>头</strong>(header)是一个变量</li>
<li><strong>体</strong>(body)是变量和终结符组成的字符串，可以是空串</li>
</ul>
</li>
</ul>
<p>一般来说，我们在字母使用下有以下约定</p>
<ul>
<li>用$A,B,C\cdots,S$表示变量</li>
<li>用$a,b,c\cdots$表示终结符</li>
<li>用$\cdots,X,Y,Z$表示非终结符或变量</li>
<li>用$w,x,y,z$表示只含有终结符的字符串</li>
<li>用$\alpha,\beta,\gamma,\cdots$来表示有终结符或变量的字符串</li>
</ul>
<p>根据上述定义，想要定义一个语言$\{0^n1^n|n\ge 1\}$:</p>
<script type="math/tex; mode=display">G=(\{S\},\{0,1\},\{S\rightarrow 01,S\rightarrow 0S1\},S)</script><p>定义：</p>
<p>称$\alpha A\beta$可以<strong>推导</strong>出$\alpha \gamma \beta$，记为$\alpha A\beta\Rightarrow \alpha \gamma \beta$。如果$A\rightarrow \gamma$是一个产生式。</p>
<p>称零步或多步推导为<strong>迭代推导</strong>，记为$\Rightarrow^*$</p>
<p>令$G$是一个上下文无关文法，则记$G$的语言为$L(G)$，称上下文无关文法定义的语言为<strong>上下文无关语言(Context-Free Language, CFL)</strong>。</p>
<h2 id="最左推导和最右推导"><a href="#最左推导和最右推导" class="headerlink" title="最左推导和最右推导"></a>最左推导和最右推导</h2><p>每一次推导我们都可以替换一个任意位置的变量，但是这个任意会带来很多的不确定性，为了避免不确定性，我们规定每次替换的变量为一个固定位置（最左或最右）的变量。</p>
<p>我们使用$\Rightarrow_l$表示最左推导，$\Rightarrow_r$ 表示最右推导。</p>
<h1 id="解析树"><a href="#解析树" class="headerlink" title="解析树"></a>解析树</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>解析树(Parse Tree)</strong>是一棵用某个特定的上下文无关文法中的符号对每个结点做标记的树。如图所示：</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/1.png?raw=true" alt="1"></p>
<h2 id="解析树，最左推导，最右推导"><a href="#解析树，最左推导，最右推导" class="headerlink" title="解析树，最左推导，最右推导"></a>解析树，最左推导，最右推导</h2><p>解析树、最左推导和最右推导是可以相互转化的，它们的表达能力是等价的。</p>
<p>由归纳法可以轻松证明。</p>
<h2 id="文法歧义"><a href="#文法歧义" class="headerlink" title="文法歧义"></a>文法歧义</h2><p>我们称一个文法是<strong>有歧义的(ambiguous)</strong>，如果在这个文法定义的语言中，存在一个字符串可以被两个及以上个解析树产出。</p>
<p>如果这个字符串存在多个对应的解析树，那么就意味着存在多种推导方式。</p>
<p>当然，也存在文法，在这个文法定义的语言中，所有的字符串都只有唯一的解析树，我们称之为<strong>LL(1)文法</strong>。</p>
<p>一般来说，LL(1)文法具有以下的特征：从左往右扫描字符串，且只看下一个符号。</p>
<h2 id="固有歧义"><a href="#固有歧义" class="headerlink" title="固有歧义"></a>固有歧义</h2><p>有的有歧义的文法可以修改成没有歧义的文法，但是存在一些上下文无关语言本身是具有<strong>固有的歧义性(inherently ambiguous)</strong>的，意思是这个语言的所有的文法都是有歧义的。</p>
<h1 id="上下文无关文法的范式"><a href="#上下文无关文法的范式" class="headerlink" title="上下文无关文法的范式"></a>上下文无关文法的范式</h1><h2 id="去除无用变量"><a href="#去除无用变量" class="headerlink" title="去除无用变量"></a>去除无用变量</h2><ul>
<li>无法推导的变量：无法推导出任何终结字符串。</li>
<li>不可达的符号：有一些变量或者终结符无论如何从起始符号推导都不会出现。</li>
</ul>
<p>以上的符号我们称为<strong>无用符号(unused symbols)</strong>。我们通过以下方法去除无用符号：</p>
<ol>
<li>删除不能导出终结字符串的符号</li>
<li>删除所有从起始符号不可达的字符串</li>
</ol>
<p><strong>这个顺序不能颠倒！！！</strong></p>
<h2 id="去除空串"><a href="#去除空串" class="headerlink" title="去除空串"></a>去除空串</h2><p>我们需要考虑不含$\epsilon$的语言，所以我们需要一个算法能够去除空串：</p>
<ul>
<li>找到所有空产生式：递归的找出所有能推导出空串的符号</li>
<li>去除空产生式：<ul>
<li>对于每一个产生式，如果产生式右边存在能推导出空串的符号，则每一个由可空的符号组成的子集，存在一个产生式，是将右边产生式的某个为空部分去掉得到的。</li>
<li>最后去掉所有的空产生式</li>
</ul>
</li>
</ul>
<h2 id="去除单元产生式"><a href="#去除单元产生式" class="headerlink" title="去除单元产生式"></a>去除单元产生式</h2><p><strong>单元产生式</strong>(unit production)指的是体只有一个变量的产生式。这些产生式也是可以去除的。</p>
<p>算法如下：</p>
<ul>
<li>发现单元产生式：归纳的找到所有有序对$(A,B)$使$A\Rightarrow^* B$为单元产生式<ul>
<li>基础情况：$(A,A)$一定是满足要求的有序对</li>
<li>如果已经发现了$(A,B)$，且$B\rightarrow C$是一个单元产生式，则$(B,C)$也一定满足要求。</li>
</ul>
</li>
<li>去除单元产生式：一系列的单元产生式加上一个非单元产生式形成的推导在新文法中可以塌缩折叠成一个产生式。</li>
</ul>
<h2 id="乔姆斯基范式"><a href="#乔姆斯基范式" class="headerlink" title="乔姆斯基范式"></a>乔姆斯基范式</h2><p>如果$L$是一个上下文无关语言，那么对于$L-\{\epsilon\}$一定存在一个上下文无关文法：</p>
<ul>
<li>没有无用符号</li>
<li>没有$\epsilon-$产生式</li>
<li>没有单元产生式</li>
</ul>
<p>要找到这样的文法，一定<strong>遵循以下顺序操作</strong>：</p>
<ol>
<li>去除$\epsilon-$产生式</li>
<li>去除单元产生式</li>
<li>去除无用符号<ol>
<li>去除无法推导出终结字符串的变量</li>
<li>去除从起始符号不可达的变量</li>
</ol>
</li>
</ol>
<p>定义<strong>乔姆斯基范式(Chomsky Normal Form, CNF)</strong>：</p>
<p>称一个上下文无关文法符合 乔姆斯基范式(Chomsky Normal Form, CNF) ，如果每个产生式都满足下面两种形式的其中一种：</p>
<ol>
<li>$A\rightarrow BC$</li>
<li>$A\rightarrow a$，其中$a$是终结符。</li>
</ol>
<p>下面介绍一个算法将一个上下文无关文法修改成符合乔姆斯基范式。</p>
<ol>
<li>清理文法：去除无用符号，去除空产生式，去除单元产生式。</li>
<li>对于所有不是单个终结符的体，让右侧变成全部是变量的形式。</li>
<li>将体长度超过2的产生式分解成若干个体长度等于2的产生式</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/FLA%E5%A4%8D%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/FLA%E5%A4%8D%E4%B9%A0/" class="post-title-link" itemprop="url">FLA复习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-09 22:06:54" itemprop="dateCreated datePublished" datetime="2024-12-09T22:06:54+08:00">2024-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-30 17:24:40" itemprop="dateModified" datetime="2024-12-30T17:24:40+08:00">2024-12-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h1 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h1><h2 id="确定性有穷自动机"><a href="#确定性有穷自动机" class="headerlink" title="确定性有穷自动机"></a>确定性有穷自动机</h2><p>五元组$(Q, \Sigma, \delta, q_0, F)$</p>
<ul>
<li>$Q$ 是一个有限状态集合</li>
<li>$\Sigma$ 是一个输入字母表</li>
<li>$\delta$ 是一个状态转换函数，它将一个状态和输入符号映射到下一个状态</li>
<li>$q_0$ 是初始状态，$q_0\in Q$</li>
<li>$F$ 是一个终止状态集合，$F\subseteq Q$</li>
</ul>
<p>$\delta$是一个全函数，对于一个状态$q$和输入符号$a$，$\delta(q,a)$一定有对应的转移，如果没有，我们额外定义一个<strong>死状态</strong>。</p>
<p>对于一个自动机来说，它的语言是从初始状态走到终止状态的所有路径的标签字符串的集合。</p>
<h2 id="判断DFA的语言和一个自然描述的语言集合"><a href="#判断DFA的语言和一个自然描述的语言集合" class="headerlink" title="判断DFA的语言和一个自然描述的语言集合"></a>判断DFA的语言和一个自然描述的语言集合</h2><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/FLA%E5%A4%8D%E4%B9%A0/1.png?raw=true" alt="1"></p>
<p>先证$S\subseteq T$，使用归纳假设：</p>
<ul>
<li>如果$\delta(A,\omega)=A$，那么$\omega$没有连续的两个$1$并且不以$1$结尾</li>
<li>如果$\delta(A,\omega)=B$，那么$\omega$没有连续的两个$1$并且以单个$1$结尾</li>
</ul>
<p>再证$T\subseteq S$，使用反证法：</p>
<ul>
<li>假设$\omega\in T$没有被DFA接受</li>
</ul>
<h2 id="正则语言"><a href="#正则语言" class="headerlink" title="正则语言"></a>正则语言</h2><ul>
<li>证明一个语言不是正则语言（不使用泵引理）：反证法找矛盾</li>
</ul>
<h1 id="非确定性有穷自动机"><a href="#非确定性有穷自动机" class="headerlink" title="非确定性有穷自动机"></a>非确定性有穷自动机</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>五元组$(Q, \Sigma, \delta, q_0, F)$</p>
<ul>
<li>$Q$ 是一个有限状态集合</li>
<li>$\Sigma$ 是一个输入字母表</li>
<li>$\delta$ 是一个状态转换函数，它将一个状态和输入符号映射到下一个状态<strong>集合</strong></li>
<li>$q_0$ 是初始状态，$q_0\in Q$</li>
<li>$F$ 是一个终止状态集合，$F\subseteq Q$</li>
</ul>
<h2 id="NFA和DFA的等价性"><a href="#NFA和DFA的等价性" class="headerlink" title="NFA和DFA的等价性"></a>NFA和DFA的等价性</h2><ul>
<li>DFA-&gt;NFA 显而易见</li>
<li>NFA-&gt;DFA <strong>子集构造法</strong></li>
</ul>
<h1 id="带空转移的NFA"><a href="#带空转移的NFA" class="headerlink" title="带空转移的NFA"></a>带空转移的NFA</h1><p>在NFA的基础上再允许某个状态在没有输入字符的时候就转移到另一个状态，即接受$\epsilon$输入。</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>引入<strong>状态闭包</strong>的概念，即可以通过任意个空转移到达的状态集合。</p>
<h2 id="NFA和-epsilon-NFA的等价性"><a href="#NFA和-epsilon-NFA的等价性" class="headerlink" title="NFA和$\epsilon$-NFA的等价性"></a>NFA和$\epsilon$-NFA的等价性</h2><ul>
<li>NFA-&gt;$\epsilon$-NFA 显而易见</li>
<li>$\epsilon$-NFA-&gt;NFA 先取闭包，后转移，最后再次取闭包</li>
</ul>
<h2 id="有穷自动机总结"><a href="#有穷自动机总结" class="headerlink" title="有穷自动机总结"></a>有穷自动机总结</h2><p>DFA，NFA和$\epsilon$-NFA是等价的，都只表示正则语言。<br>只有DFA能被真正实现。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li><strong>并(union)</strong>：就是集合的并操作</li>
<li><strong>拼接(concatenation)</strong>：LM</li>
<li><strong>星闭包(Kleene closure)</strong>：L*</li>
</ul>
<h2 id="正则表达式与有穷自动机的等价性"><a href="#正则表达式与有穷自动机的等价性" class="headerlink" title="正则表达式与有穷自动机的等价性"></a>正则表达式与有穷自动机的等价性</h2><h3 id="正则表达式转换为-epsilon-NFA"><a href="#正则表达式转换为-epsilon-NFA" class="headerlink" title="正则表达式转换为$\epsilon$-NFA"></a>正则表达式转换为$\epsilon$-NFA</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.png?raw=true" alt="1"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.png?raw=true" alt="2"></p>
<h3 id="DFA转换为正则表达式"><a href="#DFA转换为正则表达式" class="headerlink" title="DFA转换为正则表达式"></a>DFA转换为正则表达式</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.png?raw=true" alt="3"></p>
<h3 id="正则表达式的代数运算法则"><a href="#正则表达式的代数运算法则" class="headerlink" title="正则表达式的代数运算法则"></a>正则表达式的代数运算法则</h3><ul>
<li>$R+\emptyset=R$</li>
<li>$R\emptyset=\emptyset R=\emptyset$</li>
<li>$\epsilon R=R\epsilon =R$</li>
<li>$(\epsilon+R)<em>=R</em>$</li>
<li>$R+SR=(\epsilon+S)R$</li>
<li>$\epsilon+RR<em>=R</em>$</li>
<li>$(R+S)<em>=(R</em>S)<em>R</em>$</li>
</ul>
<h2 id="正则表达式的判定性质"><a href="#正则表达式的判定性质" class="headerlink" title="正则表达式的判定性质"></a>正则表达式的判定性质</h2><ul>
<li>成员资格问题：模拟运行</li>
<li>空问题：是否有一个终止状态可达</li>
<li>无限性问题：是否有环</li>
<li>等价性：构造乘积DFA</li>
<li>包含关系：构造乘积DFA</li>
</ul>
<h3 id="泵引理"><a href="#泵引理" class="headerlink" title="泵引理"></a>泵引理</h3><p>对于一个正则语言$L$来说，存在一个整数$n$，使得对于$L$中的每一个长度大于等于$n$的字符串$w$，都可以写作$w=xyz$，满足：</p>
<ol>
<li>$|xy|\leq n$</li>
<li>$|y| &gt;0$</li>
<li>$\forall i \ge 0,xy^iz\in L$<br>判断一个语言不是正则表达式时使用泵引理，还可以利用正则语言的闭包性说明不是。还可以<strong>构造DFA</strong>来说明是正则语言。</li>
</ol>
<h3 id="正则语言的最小状态DFA"><a href="#正则语言的最小状态DFA" class="headerlink" title="正则语言的最小状态DFA"></a>正则语言的最小状态DFA</h3><p><strong>状态最小化(efficient state minimization)</strong> 操作。</p>
<p>这是一个递归算法：<br>基础情况：标记所有的只有一个终止状态的对，即区分字符串长度为0。<br>递归情况：如果对于某个输入符号$a$，$[\delta(q,a),\delta(r,a)]$被标记了，那么标记$[q,r]$。在没有更多的对可以被标记的时候，剩下的没有标记的对就是等价的了，并且可以合并成一个状态。</p>
<h2 id="正则语言的闭包性质"><a href="#正则语言的闭包性质" class="headerlink" title="正则语言的闭包性质"></a>正则语言的闭包性质</h2><ul>
<li>并操作、拼接操作以及星闭包操作下的闭包</li>
<li>交集、差集、补集下的闭包</li>
<li>逆运算下的闭包</li>
<li>同态运算下的闭包</li>
<li>逆同态运算下的闭包</li>
</ul>
<h1 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>定义<strong>上下文无关文法</strong>(context-free grammar,CFG)是一个四元组$G=(V,T,P,S)$:</p>
<ul>
<li>$T$为CFG要定义语言的字母表，称为<strong>终结符</strong>(Terminals)。</li>
<li>$V$为一个有限的其他符号的集合，每个符号代表了一个语言，称为<strong>变量</strong>(Variables)或者<strong>非终结符</strong>(Nonterminals)。</li>
<li>$S$为CFG要定义的语言变量，称为<strong>起始符号(Start Symbol)</strong>。</li>
<li>$P$为CFG的<strong>产生式</strong>(productions)集合，形如$head\rightarrow body$。<ul>
<li><strong>头</strong>(header)是一个变量</li>
<li><strong>体</strong>(body)是变量和终结符组成的字符串，可以是空串</li>
</ul>
</li>
</ul>
<h2 id="最左推导最右推导，解析树，等价性"><a href="#最左推导最右推导，解析树，等价性" class="headerlink" title="最左推导最右推导，解析树，等价性"></a>最左推导最右推导，解析树，等价性</h2><p>解析树、最左推导和最右推导是可以相互转化的，它们的表达能力是等价的。</p>
<h2 id="文法歧义，固有歧义"><a href="#文法歧义，固有歧义" class="headerlink" title="文法歧义，固有歧义"></a>文法歧义，固有歧义</h2><h2 id="上下文无关变量范式"><a href="#上下文无关变量范式" class="headerlink" title="上下文无关变量范式"></a>上下文无关变量范式</h2><p>定义<strong>乔姆斯基范式(Chomsky Normal Form, CNF)</strong>：</p>
<p>称一个上下文无关文法符合 乔姆斯基范式(Chomsky Normal Form, CNF) ，如果每个产生式都满足下面两种形式的其中一种：</p>
<ol>
<li>$A\rightarrow BC$</li>
<li>$A\rightarrow a$，其中$a$是终结符。</li>
</ol>
<p>下面介绍一个算法将一个上下文无关文法修改成符合乔姆斯基范式。</p>
<ol>
<li>清理文法。<ol>
<li>去除无用符号：<ol>
<li>删除不能导出终结字符串的符号</li>
<li>删除所有从起始符号不可达的字符串</li>
</ol>
</li>
<li>去除空产生式：<ol>
<li>对于每一个产生式，如果产生式右边存在能推导出空串的符号，则每一个由可空的符号组成的子集，存在一个产生式，是将右边产生式的某个为空部分去掉得到的。</li>
<li>最后去掉所有的空产生式</li>
</ol>
</li>
<li>去除单元产生式：<ol>
<li>发现单元产生式：归纳的找到所有有序对$(A,B)$使$A\Rightarrow^* B$为单元产生式<ul>
<li>基础情况：$(A,A)一定是满足要求的有序对</li>
<li>如果已经发现了$(A,B)$，且$B\rightarrow C$是一个单元产生式，则$(B,C)$也一定满足要求。</li>
</ul>
</li>
<li>去除单元产生式：一系列的单元产生式加上一个非单元产生式形成的推导在新文法中可以塌缩折叠成一个产生式。</li>
</ol>
</li>
</ol>
</li>
<li>对于所有不是单个终结符的体，让右侧变成全部是变量的形式。</li>
<li>将体长度超过2的产生式分解成若干个体长度等于2的产生式</li>
</ol>
<h1 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p><strong>下推自动机</strong>(Pushdown Automata)为一个七元组$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$：</p>
<ul>
<li>$Q$为有限状态集合</li>
<li>$\Sigma$为输入字母表</li>
<li>$\Gamma$为栈字母表</li>
<li>$\delta$是转移函数<ul>
<li>接受三个参数：当前状态、当前输入符号、栈顶元素</li>
<li>$\delta(q,a,Z)=(p,\alpha)$，其中$p\in Q,\alpha\in\Gamma^*$，即转移到新状态并将栈顶符号替换为$\alpha$</li>
</ul>
</li>
<li>$q_0\in Q$为初始状态</li>
<li>$Z_0\in\Gamma$为初始栈顶元素</li>
<li>$F\subseteq Q$为终止状态集合</li>
</ul>
<p>一些字母上的约定：</p>
<ul>
<li>用$a,b,c\cdots,\epsilon$表示输入符号</li>
<li>用$\cdots,X,Y,Z$表示栈符号</li>
<li>用$w,x,y,z$表示输入符号形成的字符串</li>
<li>用$\alpha,\beta,\cdots$来表示栈符号形成的字符串<h2 id="下推自动机的语言"><a href="#下推自动机的语言" class="headerlink" title="下推自动机的语言"></a>下推自动机的语言</h2></li>
<li>根据终止状态$L(P)$</li>
<li>根据空栈$N(P)$</li>
</ul>
<p>两者在定义语言的能力上等价，意味着可以通过修改相互转换。</p>
<h2 id="确定性下推自动机与非确定性下推自动机"><a href="#确定性下推自动机与非确定性下推自动机" class="headerlink" title="确定性下推自动机与非确定性下推自动机"></a>确定性下推自动机与非确定性下推自动机</h2><p>NPDA的表达能力比DPDA要强。</p>
<h2 id="CFG转变为PDA"><a href="#CFG转变为PDA" class="headerlink" title="CFG转变为PDA"></a>CFG转变为PDA</h2><p>对于CFG $G$，令$L=L(G)$，我们可以构造一个PDA $P$，使$N(P)=L$。</p>
<p>思路就是$P$的每一步代表最左推导中的一步。</p>
<h2 id="PDA转变为CFG"><a href="#PDA转变为CFG" class="headerlink" title="PDA转变为CFG"></a>PDA转变为CFG</h2><p>对于PDA $P$，令$L=N(G)$，我们可以构造一个CGL $G$，使$L=L(G)$。</p>
<p>思路是$G$中的每一个符号都形如$[pXq]$，对应一个输入使$P$从$p$转移到$q$，并且弹出栈顶符号$X$。</p>
<h1 id="上下文无关语言"><a href="#上下文无关语言" class="headerlink" title="上下文无关语言"></a>上下文无关语言</h1><h1 id="时间自动机"><a href="#时间自动机" class="headerlink" title="时间自动机"></a>时间自动机</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>令$X$是一个时钟变量的集合，那么时钟约束(time constraints)的集合$C(X)$由以下文法定义：</p>
<script type="math/tex; mode=display">\empty=x\leq k\mid k\leq x\mid x<k\mid k<x\mid\empty\wedge \empty</script><p>其中$x\in X,k\in\mathbb{N}$</p>
<p>定义<strong>时间自动机</strong>(time automata)是一个四元组$(L,X,I_0,E)$：</p>
<ul>
<li>$L$是一个有限地点(location)集合</li>
<li>$X$是一个有限时钟变量集合</li>
<li>$I_0\in L$是一个初始地点</li>
<li>$E\subseteq L\times C(X)\times 2^X\times L$是一个边的集合，四元组的含义为(源地点，时钟约束，重置时钟集，目标地点)</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>货车在车间待机，装货完成后以平均速度 1km/min 开到距离 3km 的卸货点，卸货时间 2-4min，卸货完后返回车间待机。对其进行建模。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">【八】迁移系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-09 14:08:40" itemprop="dateCreated datePublished" datetime="2024-12-09T14:08:40+08:00">2024-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-18 18:53:27" itemprop="dateModified" datetime="2024-12-18T18:53:27+08:00">2024-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>迁移系统</strong>(transition system, TS) 是一个反应式的系统，直觉上它由一个所有可能状态的集合以及一些迁移(transition)——或者说状态转换(state change)——的集合组成。</p>
<p>我们可以用有向图来表示一个迁移系统，图中的结点表示状态，边表示迁移行为。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迁移系统是一个五元组$(S,S_0,T,\alpha,\beta)$:</p>
<ul>
<li>$S$ 是一个有限或无限的状态集合</li>
<li>$S_0$ 是一个初始状态集合，$S_0 \subseteq S$</li>
<li>$T$ 是一个迁移集合，$T \subseteq S \times S$</li>
<li>$\alpha$和$\beta$是两个从$T$到$S$的映射，对于任意的$t\in T$，有$\alpha(t)$表示迁移的<strong>源状态</strong>和$\beta(t)$表示迁移的<strong>目标状态</strong>。</li>
</ul>
<p>若$S$和$T$是有限的，则整个迁移系统也是有限的。</p>
<p>定义一个迁移系统$\mathcal{A}$的路径是一个迁移的序列$t_1,t_2,\dots,t_n$。</p>
<p>如果一个状态可以由初始状态经过一条路径达到，则称这个状态是<strong>可达</strong>的。<br>如果一个状态不可以到达任何其他状态，则称这个状态是<strong>终结状态</strong>。<br>如果一个状态是可达的同时又是一个终结状态，则称这个状态是<strong>死锁状态</strong>。</p>
<p>当然，这里$\alpha$和$\beta$的定义可以拓展到对一个路径取源和目标。</p>
<h2 id="带标签的迁移系统"><a href="#带标签的迁移系统" class="headerlink" title="带标签的迁移系统"></a>带标签的迁移系统</h2><p>一个被字母表$A$标记的，带标签的迁移系统(labeled transition system) 是一个 6 元组$\mathcal{A} = (S,S_0,T,\alpha,\beta,\lambda)$:</p>
<ul>
<li>前五元组是一个迁移系统</li>
<li>$\lambda$是一个从$T$到$A$的映射，对于任意的$t\in T$，有$\lambda(t)$表示迁移的<strong>标签</strong>。</li>
</ul>
<p>直觉上，一个迁移的标签意味着触发这个迁移的行为或者事件。</p>
<p>定义一条如果$c=t_1,t_2,\cdots$是一条路径，那么触发这些迁移的行为的序列$trace(c)=\lambda(t_1),\lambda(t_2),\cdots$被称为这个路径的<strong>踪迹</strong>。</p>
<h1 id="迁移系统的等价性"><a href="#迁移系统的等价性" class="headerlink" title="迁移系统的等价性"></a>迁移系统的等价性</h1><p>想要证明两个建模语言是等价的，我们可以用迁移系统来刻画它们的行为，然后通过证明迁移系统的等价性来证明建模语言行为的等价性。</p>
<h2 id="强同构等价"><a href="#强同构等价" class="headerlink" title="强同构等价"></a>强同构等价</h2><p>唯一的区别就只能是状态和迁移的命名不同</p>
<h2 id="弱同构等价"><a href="#弱同构等价" class="headerlink" title="弱同构等价"></a>弱同构等价</h2><p>如果这两个可达子迁移系统是同构的，我们称原来的两个迁移系统是 弱同构(weak isomorphic) 的。</p>
<h2 id="双模拟等价"><a href="#双模拟等价" class="headerlink" title="双模拟等价"></a>双模拟等价</h2><p>迁移系统具有相同的行为，并在同一时刻做选择。</p>
<h1 id="迁移系统的运算"><a href="#迁移系统的运算" class="headerlink" title="迁移系统的运算"></a>迁移系统的运算</h1><h2 id="自由积"><a href="#自由积" class="headerlink" title="自由积"></a>自由积</h2><p>将多个迁移系统的定义做一个笛卡尔积。</p>
<p>直观上理解，各个子系统的定义不变，加入了时钟来统一驱动多个系统。使之走相同的步数。</p>
<h2 id="同步积"><a href="#同步积" class="headerlink" title="同步积"></a>同步积</h2><p>当进程之间进行交互的时候，并不是所有可能的全局行为都是有用的，因为这些交互会受到进程通信和同步的限制。</p>
<p>因此，描述多进程系统的迁移系统一定是各个进程对应的各自迁移系统的自由积的一个子系统，我们可以用同步积来表达这种受到通信和同步约束的全局系统。</p>
<p>本质上就是加入了一个集合来判断自由积中哪些迁移是被允许的。换句话说，同步积只允许标签向量在同步约束中的全局迁移发生。</p>
<h2 id="tau-迁移和共享标签"><a href="#tau-迁移和共享标签" class="headerlink" title="$\tau $迁移和共享标签"></a>$\tau $迁移和共享标签</h2><p>自由积有时钟的限制，要求所有子迁移系统必须同进退，要想消除这个限制，只需要每个状态引入一个自环转移($\tau$ transition)就行了。</p>
<p>我们也可以使用共享标签来表示两个迁移必须同时发生，这样在表达上面会更加简洁。不过这并没有拓展同步积的表达能力就是了，只是换了一种更简便的表达方式而已。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="post-title-link" itemprop="url">【二】正则表达式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-09 13:21:51" itemprop="dateCreated datePublished" datetime="2024-12-09T13:21:51+08:00">2024-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-18 18:53:27" itemprop="dateModified" datetime="2024-12-18T18:53:27+08:00">2024-12-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>正则表达式(regular expression, RE) 通过代数式的方式来描述语言。</p>
<p>如果$E$是一个正则表达式，记它定义的语言为$L(E)$。</p>
<p>首先回顾一下语言的操作：</p>
<ul>
<li><strong>并(union)</strong>：就是集合的并操作</li>
<li><strong>拼接(concatenation)</strong>：LM</li>
<li><strong>星闭包(Kleene closure)</strong>：L*</li>
</ul>
<p><strong>定义</strong>：<br>递归地定义正则表达式如下：<br>基础情况：</p>
<ol>
<li>一个符号是正则表达式</li>
<li>$\epsilon$是正则表达式</li>
<li>$\emptyset$是正则表达式<br>递归情况：</li>
<li>两个正则表达式的并是正则表达式，$E_1+E_2$</li>
<li>两个正则表达式的拼接是正则表达式，$E_1E_2$</li>
<li>一个正则表达式的星闭包是正则表达式，$E*$</li>
</ol>
<h2 id="操作符号优先级"><a href="#操作符号优先级" class="headerlink" title="操作符号优先级"></a>操作符号优先级</h2><p>星闭包&gt;拼接&gt;并 </p>
<h2 id="正则表达式和有穷自动机的等价性"><a href="#正则表达式和有穷自动机的等价性" class="headerlink" title="正则表达式和有穷自动机的等价性"></a>正则表达式和有穷自动机的等价性</h2><h3 id="将正则表达式转换成-epsilon-NFA"><a href="#将正则表达式转换成-epsilon-NFA" class="headerlink" title="将正则表达式转换成$\epsilon$-NFA"></a>将正则表达式转换成$\epsilon$-NFA</h3><p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.png?raw=true" alt="1"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.png?raw=true" alt="2"></p>
<h3 id="将DFA转化为正则表达式"><a href="#将DFA转化为正则表达式" class="headerlink" title="将DFA转化为正则表达式"></a>将DFA转化为正则表达式</h3><p>定义<strong>k-路径</strong>：<br>k-路径指的是DFA状态转换图上的某一条路径，其中，这条路径经过的所有状态的标号不超过k。</p>
<p>令$R^{k}_{ij}$表示从状态$i$走到状态$j$的k路径。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.png?raw=true" alt="3"></p>
<h2 id="正则表达式的代数运算法则"><a href="#正则表达式的代数运算法则" class="headerlink" title="正则表达式的代数运算法则"></a>正则表达式的代数运算法则</h2><ul>
<li>$R+\emptyset=R$</li>
<li>$R\emptyset=\emptyset R=\emptyset$</li>
<li>$\epsilon R=R\epsilon =R$</li>
<li>$(\epsilon+R)<em>=R</em>$</li>
<li>$R+SR=(\epsilon+S)R$</li>
<li>$\epsilon+RR<em>=R</em>$</li>
<li>$(R+S)<em>=(R</em>S)<em>R</em>$</li>
</ul>
<h1 id="正则语言的判定性质"><a href="#正则语言的判定性质" class="headerlink" title="正则语言的判定性质"></a>正则语言的判定性质</h1><p>语言类有两类重要的性质：</p>
<ul>
<li>判定性质<br>一类语言的<strong>判定性质(decision property)</strong>对应于一个算法，这个算法以某个语言的形式化描述(比如说一个DFA)为输入，然后告诉我们这个语言是否满足某些性质（比如说这个语言是否为空之类的）。语言的表示可以是形式化(formal)的（比如说RE，FA等等），也可以是非形式化(informal)的（比如说自然语言描述，集合描述等等）。</li>
<li>闭包性质<br>一类语言的<strong>闭包性质(closure property)</strong>说的是给定这个语言类的一些语言，对于这些语言进行某个操作得到的另一个语言依旧在同一个语言类中。</li>
</ul>
<p>下面讨论一些常见的判定性质。</p>
<h2 id="成员资格问题"><a href="#成员资格问题" class="headerlink" title="成员资格问题"></a>成员资格问题</h2><p>一个给定字符串是否属于一个给定正则语言。</p>
<p>转换成DFA模拟运行即可。</p>
<h2 id="空问题"><a href="#空问题" class="headerlink" title="空问题"></a>空问题</h2><p>判断一个给定的正则语言是否为空。</p>
<p>假设语言的表示为DFA，从初始状态开始，计算所有的可达状态的集合，如果至少有一个终止状态可达，那么这个语言就非空，否则为空。</p>
<h2 id="无限性问题"><a href="#无限性问题" class="headerlink" title="无限性问题"></a>无限性问题</h2><p>判断一个给定的正则语言的语言集合是否为无限大。</p>
<p>只要找DFA是否出现环。</p>
<h2 id="泵引理"><a href="#泵引理" class="headerlink" title="泵引理"></a>泵引理</h2><p>判断某个语言是不是正则语言。</p>
<p>使用<strong>泵引理</strong>：<br>对于一个正则语言$L$来说，存在一个整数$n$，使得对于$L$中的每一个长度大于等于$n$的字符串$w$，都可以写作$w=wxy$，满足：</p>
<ol>
<li>$|xy|\leq n$</li>
<li>$|y| &gt;0$</li>
<li>$\forall i \ge 0,xy^iz\in L$</li>
</ol>
<p>泵引理被用来判断一个语言不是正则语言。而不是用来判断是正则语言。</p>
<h2 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h2><p>判断两个正则语言是否等价。</p>
<p>构造<strong>乘积DFA</strong>：</p>
<ul>
<li>状态集：$Q\times R$</li>
<li>初始状态：$[q_0,r_0]$</li>
<li>转移函数：$\delta([q,r],a)=[\delta_L(q,a),\delta_R(r,a)]$</li>
<li><strong>终止状态</strong>：$[q,r]$，其中只有一个是原来DFA的终止状态。</li>
</ul>
<p>如果这个自动机是接受的语言是空集，则说明两个正则语言等价。</p>
<h2 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h2><p>判断两个正则语言是否包含。</p>
<p>仍然构造乘积DFA，但是终止状态定义为$[q,r]$，其中$q$是原来DFA的终止状态，而$r$不是$M$的终止状态。</p>
<p>这样乘积DFA是空集等价于$L\subseteq M$</p>
<h2 id="一个正则语言的最小状态DFA"><a href="#一个正则语言的最小状态DFA" class="headerlink" title="一个正则语言的最小状态DFA"></a>一个正则语言的最小状态DFA</h2><p>现在考虑如何将一个DFA找到其等价的最小状态DFA。下面我们介绍一种高效的 <strong>状态最小化(efficient state minimization)</strong> 操作。</p>
<p>这是一个递归算法：<br>基础情况：标记所有的只有一个终止状态的对，即区分字符串长度为0。<br>递归情况：如果对于某个输入符号$a$，$[\delta(q,a),\delta(r,a)]$被标记了，那么标记$[q,r]$。在没有更多的对可以被标记的时候，剩下的没有标记的对就是等价的了，并且可以合并成一个状态。</p>
<h1 id="正则语言的闭包性质"><a href="#正则语言的闭包性质" class="headerlink" title="正则语言的闭包性质"></a>正则语言的闭包性质</h1><h2 id="并操作、拼接操作以及星闭包操作下的闭包"><a href="#并操作、拼接操作以及星闭包操作下的闭包" class="headerlink" title="并操作、拼接操作以及星闭包操作下的闭包"></a>并操作、拼接操作以及星闭包操作下的闭包</h2><p>如果$L$和$M$是正则语言，那么$L\cup M$，$LM$，$L*$都是正则语言。</p>
<h2 id="交集、差集、补集下的闭包"><a href="#交集、差集、补集下的闭包" class="headerlink" title="交集、差集、补集下的闭包"></a>交集、差集、补集下的闭包</h2><ul>
<li>交集<br>  在交集下闭包，构造一个乘积DFA，令终止状态是两个共同的终止状态。</li>
<li>差集<br>  在差集下闭包，构造一个乘积DFA，终止状态是包含A的但不包含B的终止状态的状态对。</li>
<li>补集<br>  在补集下闭包。</li>
</ul>
<h2 id="逆运算下的闭包"><a href="#逆运算下的闭包" class="headerlink" title="逆运算下的闭包"></a>逆运算下的闭包</h2><p>递归的进行逆操作即可。</p>
<h2 id="同态运算和逆同态运算下的闭包"><a href="#同态运算和逆同态运算下的闭包" class="headerlink" title="同态运算和逆同态运算下的闭包"></a>同态运算和逆同态运算下的闭包</h2><p>对于一个字母表的<strong>同态(homomorphism)</strong>指的是一个函数，这个函数对于字母表中的每一个字符给出了一个字符串。</p>
<p>正则语言在同态和逆同态下是闭包的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gisyxi7</p>
  <div class="site-description" itemprop="description">nju cs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">30</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gisyxi7</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
