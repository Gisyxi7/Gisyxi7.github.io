<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="nju cs">
<meta property="og:type" content="website">
<meta property="og:title" content="Gisyxi7&#39;s blogs">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Gisyxi7&#39;s blogs">
<meta property="og:description" content="nju cs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Gisyxi7">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Gisyxi7's blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Gisyxi7's blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学不动了</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/02/%E3%80%900-2%E3%80%91OpenGL%E4%B8%89%E8%A7%92%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/02/%E3%80%900-2%E3%80%91OpenGL%E4%B8%89%E8%A7%92%E5%BD%A2/" class="post-title-link" itemprop="url">【0.2】OpenGL三角形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-02 14:44:23" itemprop="dateCreated datePublished" datetime="2025-02-02T14:44:23+08:00">2025-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-03 17:28:51" itemprop="dateModified" datetime="2025-02-03T17:28:51+08:00">2025-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="OpenGL的渲染管线"><a href="#OpenGL的渲染管线" class="headerlink" title="OpenGL的渲染管线"></a>OpenGL的渲染管线</h1><p>直观上理解，OpenGL是将3D空间下的事物渲染到窗口屏幕的2D像素数组中。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>
<p>图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。正是由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据。这些小程序叫做着色器(Shader)。</p>
<p>一个图形渲染管线分为六个阶段：</p>
<ol>
<li>顶点着色器（可自定义）</li>
<li>几何着色器（可自定义）</li>
<li>形状（图元）装配</li>
<li>光栅化</li>
<li>片段着色器（可自定义）</li>
<li>测试与混合</li>
</ol>
<p>下面会对这些进行详细说明。在现代OpenGL中，我们必须定义至少一个顶点着色器和一个片段着色器（因为GPU中没有默认的顶点/片段着色器）。</p>
<h2 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h2><p>顶点着色器是渲染管线中第一个可编程阶段，它对每个输入的顶点单独进行处理，主要任务是将顶点从局部坐标（模型坐标）转换到裁剪空间，并计算与光照、纹理等相关的属性。</p>
<h2 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h2><p>几何着色器是一个可选的可编程阶段，位于顶点着色器之后。它接受一个完整的图元（如点、线、三角形）作为输入，并可以对这个图元进行操作，比如生成新顶点或改变图元的形状。</p>
<h2 id="形状（图元）装配"><a href="#形状（图元）装配" class="headerlink" title="形状（图元）装配"></a>形状（图元）装配</h2><p>形状装配阶段是固定功能（不可编程）的，它负责将经过顶点着色器（或几何着色器）的顶点按照指定的图元类型（如点、线、三角形等）进行组合，构成完整的图元。</p>
<p>该阶段不涉及任何自定义代码，而是由图形 API（如 OpenGL）自动完成。</p>
<h2 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h2><p>光栅化阶段将组装好的几何图元转换为屏幕上的片段（Fragments），这些片段对应最终要绘制的像素区域。</p>
<h2 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h2><p>片段着色器是最后一个可编程阶段，它对每个由光栅化阶段生成的片段进行处理，决定最终写入帧缓冲区的颜色及其它属性（如深度、透明度等）。结合光照、材质、纹理等信息计算出片段的最终颜色。</p>
<h2 id="测试与混合"><a href="#测试与混合" class="headerlink" title="测试与混合"></a>测试与混合</h2><p>这是渲染管线的最后阶段，主要负责对片段进行各种测试，并决定哪些片段最终写入到帧缓冲区，从而构成最终的图像。</p>
<hr>
<h1 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h1><p>首先，我们需要输入一些顶点数据，值得注意的是，我们需要坐标在<strong>标准化设备坐标</strong>范围内，即-1.0到1.0。不在该坐标范围内的坐标都会被丢弃。</p>
<p>我们先关注如何输入顶点信息。定义顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p>
<p>我们通过顶点缓冲对象(Vertex Buffer Objects, VBO)管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。</p>
<p>所以我们可以使用glGenBuffers函数生成一个带有缓冲ID的VBO对象。</p>
<hr>
<h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="顶点缓冲对象-VBO"><a href="#顶点缓冲对象-VBO" class="headerlink" title="顶点缓冲对象(VBO)"></a>顶点缓冲对象(VBO)</h2><p>顶点缓冲对象（Vertex Buffer Object，VBO）是一个 OpenGL 对象，专门用来存储顶点数据（如顶点位置、颜色、纹理坐标等）。<br>VBO 的创建与使用：</p>
<ol>
<li>使用 glGenBuffers() 创建一个 VBO。</li>
<li>使用 glBindBuffer() 绑定该 VBO。</li>
<li>使用 glBufferData() 将数据传输到 GPU。</li>
<li>使用 glVertexAttribPointer() 设置顶点属性指针，告诉 OpenGL 如何解析 VBO 中的数据。</li>
</ol>
<h2 id="顶点数组对象-VAO"><a href="#顶点数组对象-VAO" class="headerlink" title="顶点数组对象(VAO)"></a>顶点数组对象(VAO)</h2><p>顶点数组对象（Vertex Array Object，VAO）是一个 OpenGL 对象，用于记录与顶点数据相关的状态。它保存了绑定的顶点缓冲对象（VBO）、顶点属性指针和其他状态。VAO 保存了对顶点缓冲区对象的引用和顶点属性的配置，这样在执行渲染时，不需要每次都重新绑定顶点缓冲区，只需要绑定 VAO 即可。</p>
<h2 id="元素缓冲对象-EBO-索引缓冲对象-IBO"><a href="#元素缓冲对象-EBO-索引缓冲对象-IBO" class="headerlink" title="元素缓冲对象(EBO)/索引缓冲对象(IBO)"></a>元素缓冲对象(EBO)/索引缓冲对象(IBO)</h2><p>如果有顶点被重复使用，我们可以通过记录编号来避免额外开销。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a target="_blank" rel="noopener" href="https://github.com/Gisyxi7/LearnOpenGL/blob/main/HelloTriangle.cpp">传送门</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/01/%E3%80%900-1%E3%80%91OpenGL%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/01/%E3%80%900-1%E3%80%91OpenGL%E5%88%9B%E5%BB%BA%E7%AA%97%E5%8F%A3/" class="post-title-link" itemprop="url">【0.1】OpenGL创建窗口</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-02-01 22:25:43" itemprop="dateCreated datePublished" datetime="2025-02-01T22:25:43+08:00">2025-02-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-02-03 15:43:08" itemprop="dateModified" datetime="2025-02-03T15:43:08+08:00">2025-02-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="配置OpenGL"><a href="#配置OpenGL" class="headerlink" title="配置OpenGL"></a>配置OpenGL</h1><p>本节的目标是配置好OpenGL的运行环境。我使用CLION进行配置。</p>
<h2 id="下载GLAD"><a href="#下载GLAD" class="headerlink" title="下载GLAD"></a>下载GLAD</h2><p>因为OpenGL只是一个标准/规范，具体的实现是由驱动开发商针对特定显卡实现的。由于OpenGL驱动版本众多，它大多数函数的位置都无法在编译时确定下来，需要在运行时查询。所以任务就落在了开发者身上，开发者需要在运行时获取函数地址并将其保存在一个函数指针中供以后使用。取得地址的方法因平台而异。幸运的是，有些库能简化此过程，其中GLAD是目前最新，也是最流行的库。</p>
<p><a target="_blank" rel="noopener" href="https://glad.dav1d.de/">Download GLAD</a>，选择最新版本，点击GENERATE，再下载压缩包解压即可。</p>
<p>压缩包中应包含：</p>
<ul>
<li>\include<ul>
<li>\glad<ul>
<li>glad.h</li>
</ul>
</li>
<li>\KHR<ul>
<li>khrplatform.h</li>
</ul>
</li>
</ul>
</li>
<li>\src<ul>
<li>glad.c</li>
</ul>
</li>
</ul>
<h2 id="下载GLFW"><a href="#下载GLFW" class="headerlink" title="下载GLFW"></a>下载GLFW</h2><p>GLFW是一个专门针对OpenGL的C语言库，它提供了一些渲染物体所需的最低限度的接口。它允许用户创建OpenGL上下文、定义窗口参数以及处理用户输入。</p>
<p><a target="_blank" rel="noopener" href="https://www.glfw.org/download.html">Download GLFW</a>，选择预编译好的版本，<strong>根据自己系统以及MinGW</strong>情况选择32位或者64位。最简单的方法可以命令行查询gcc -v来查看。</p>
<p>下载解压之后里面应该要包含以下需要使用的内容：</p>
<ul>
<li>\include<ul>
<li>\GLFW<ul>
<li>glfw3.h</li>
<li>glfw3native.h</li>
</ul>
</li>
</ul>
</li>
<li>\lib-mingw-w64<ul>
<li>glfw.dll</li>
</ul>
</li>
</ul>
<h2 id="配置Clion"><a href="#配置Clion" class="headerlink" title="配置Clion"></a>配置Clion</h2><p>打开Clion，新建一个项目，建立文件夹:</p>
<ul>
<li>\include</li>
<li>\lib</li>
<li>\src</li>
<li>\bin</li>
</ul>
<p>将刚才下载的文件复制到相应位置。使新建项目目录为：</p>
<ul>
<li>\bin<ul>
<li>glfw3.dll</li>
</ul>
</li>
<li>\include<ul>
<li>\glad</li>
<li>\GLFW</li>
<li>\KHR</li>
</ul>
</li>
<li>\lib<ul>
<li>glfw3.dll</li>
</ul>
</li>
<li>\src<ul>
<li>glad.c</li>
</ul>
</li>
</ul>
<p>最后修改CMakeList.txt：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_RUNTIME_OUTPUT_DIRECTORY $&#123;PROJECT_SOURCE_DIR&#125;/bin)</span><br><span class="line"></span><br><span class="line">add_executable(OpenGL main.cpp src/glad.c)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line">target_link_libraries(OpenGL $&#123;PROJECT_SOURCE_DIR&#125;/lib/glfw3.dll)</span><br></pre></td></tr></table></figure></p>
<p>这样就配置好啦。我们可以通过以下示例程序运行测试：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;glad/glad.h&gt;</span><br><span class="line">#include &lt;GLFW/glfw3.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">void framebuffer_size_callback(GLFWwindow* window, int width, int height);</span><br><span class="line">void processInput(GLFWwindow *window);</span><br><span class="line"></span><br><span class="line">// settings</span><br><span class="line">const unsigned int SCR_WIDTH = 800;</span><br><span class="line">const unsigned int SCR_HEIGHT = 600;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // glfw: initialize and configure</span><br><span class="line">    // ------------------------------</span><br><span class="line">    glfwInit();</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">#ifdef __APPLE__</span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    // glfw window creation</span><br><span class="line">    // --------------------</span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &quot;LearnOpenGL&quot;, NULL, NULL);</span><br><span class="line">    if (window == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed to create GLFW window&quot; &lt;&lt; std::endl;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    // glad: load all OpenGL function pointers</span><br><span class="line">    // ---------------------------------------</span><br><span class="line">    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed to initialize GLAD&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    // render loop</span><br><span class="line">    // -----------</span><br><span class="line">    while (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        // input</span><br><span class="line">        // -----</span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        // render</span><br><span class="line">        // ------</span><br><span class="line">        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)</span><br><span class="line">        // -------------------------------------------------------------------------------</span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // glfw: terminate, clearing all previously allocated GLFW resources.</span><br><span class="line">    // ------------------------------------------------------------------</span><br><span class="line">    glfwTerminate();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly</span><br><span class="line">// ---------------------------------------------------------------------------------------------------------</span><br><span class="line">void processInput(GLFWwindow *window)</span><br><span class="line">&#123;</span><br><span class="line">    if(glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)</span><br><span class="line">        glfwSetWindowShouldClose(window, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// glfw: whenever the window size changed (by OS or user resize) this callback function executes</span><br><span class="line">// ---------------------------------------------------------------------------------------------</span><br><span class="line">void framebuffer_size_callback(GLFWwindow* window, int width, int height)</span><br><span class="line">&#123;</span><br><span class="line">    // make sure the viewport matches the new window dimensions; note that width and </span><br><span class="line">    // height will be significantly larger than specified on retina displays.</span><br><span class="line">    glViewport(0, 0, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果能编译运行，那就是配置成功了。会出现一个绿色的窗口。</p>
<h1 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h1><h2 id="CMakeList"><a href="#CMakeList" class="headerlink" title="CMakeList"></a>CMakeList</h2><p>为了方便增加可执行文件，我做了一些小修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;/include)</span><br><span class="line">link_directories($&#123;PROJECT_SOURCE_DIR&#125;/lib)</span><br><span class="line"></span><br><span class="line">function(My_add_executable target_name file_name)</span><br><span class="line">    add_executable($&#123;target_name&#125; $&#123;file_name&#125;.cpp src/glad.c)</span><br><span class="line">    target_link_libraries($&#123;target_name&#125; $&#123;PROJECT_SOURCE_DIR&#125;/lib/glfw3.dll)</span><br><span class="line">endfunction()</span><br><span class="line"></span><br><span class="line">My_add_executable(OpenGL main)</span><br></pre></td></tr></table></figure>
<p>像这样就可以方便配置了。只需要新建cpp之后加一行代码重新make即可。</p>
<h2 id="创建一个窗口"><a href="#创建一个窗口" class="headerlink" title="创建一个窗口"></a>创建一个窗口</h2><p>值得注意的部分都在<a target="_blank" rel="noopener" href="https://github.com/Gisyxi7/LearnOpenGL/blob/main/HelloWindow.cpp">代码注释中</a></p>
<p>流程如下：</p>
<ol>
<li>初始化GLFW库</li>
<li>指定 OpenGL 的版本和上下文属性</li>
<li>创建窗口对象</li>
<li>将窗口的上下文设置为当前线程的上下文</li>
<li>初始化 GLAD，加载 OpenGL 函数指针</li>
<li>渲染循环</li>
<li>清理资源，关闭程序</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/02/01/%E3%80%900%E3%80%91OpenGL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/01/%E3%80%900%E3%80%91OpenGL/" class="post-title-link" itemprop="url">【0】OpenGL</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-02-01 22:08:00 / 修改时间：22:25:10" itemprop="dateCreated datePublished" datetime="2025-02-01T22:08:00+08:00">2025-02-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本系列参考自<a target="_blank" rel="noopener" href="https://learnopengl-cn.github.io/">LearnOpenGL CN</a></p>
<h1 id="什么是OpenGL"><a href="#什么是OpenGL" class="headerlink" title="什么是OpenGL"></a>什么是OpenGL</h1><p>OpenGL本身是一个由Khronos组织制定并维护的规范(Specification)。其严格规定了每个函数该如何执行，以及它们的输出值。至于内部具体每个函数是如何实现(Implement)的，将由OpenGL库的开发者自行决定。实际的OpenGL库的开发者通常是显卡的生产商。</p>
<h1 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h1><p>早期的OpenGL使用立即渲染模式，但是灵活性比较差。因此从OpenGL3.2开始，规范文档开始废弃立即渲染模式，并鼓励开发者在OpenGL的核心模式(Core-profile)下进行开发，这个分支的规范完全移除了旧的特性。</p>
<h1 id="怎么理解OpenGL"><a href="#怎么理解OpenGL" class="headerlink" title="怎么理解OpenGL"></a>怎么理解OpenGL</h1><p>OpenGL自身是一个巨大的状态机(State Machine)：一系列的变量描述OpenGL此刻应当如何运行。OpenGL的状态通常被称为OpenGL上下文(Context)。我们通常使用如下途径去更改OpenGL状态：设置选项，操作缓冲。最后，我们使用当前OpenGL上下文来渲染。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/29/%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/29/%E6%97%B6%E9%97%B4%E8%87%AA%E5%8A%A8%E6%9C%BA/" class="post-title-link" itemprop="url">【十】时间自动机</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-12-29 17:00:09 / 修改时间：17:41:12" itemprop="dateCreated datePublished" datetime="2024-12-29T17:00:09+08:00">2024-12-29</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>到现在为止，我们接触的很多建模工具都是触发式的，状态变化必须由某个外部事件的产生而触发。但是现实生活中，存在系统会随着时间推移而自动改变状态，即在自动机的基础上加上了时间的维度。</p>
<h2 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Process 0:</span><br><span class="line">while (true) &#123;</span><br><span class="line">    &lt;noncritical section&gt;;</span><br><span class="line">    flag[0] = true;</span><br><span class="line">    turn = 1;</span><br><span class="line">    while flag[1] and turn = 1 do &#123; &#125;;</span><br><span class="line">    &lt;critical section&gt;;</span><br><span class="line">    flag[0] = false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Process 1:</span><br><span class="line">while (true) &#123;</span><br><span class="line">    &lt;noncritical section&gt;;</span><br><span class="line">    flag[1] = true;</span><br><span class="line">    turn = 0;</span><br><span class="line">    while flag[0] and turn = 0 do &#123; &#125;;</span><br><span class="line">    &lt;critical section&gt;;</span><br><span class="line">    flag[1] = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的思路是：如果进程 i 想要进入临界区，则先举起自己的小旗子，然后用 turn 变量讲机会谦让给另一个进程；当另一个进程想要进入临界区，且自己已经谦让机会的时候，就一直等待另一个进程使用临界区结束，否则自己就可以直接进入临界区。</p>
<p>Peterson 算法的关键在于 turn 变量，哪个进程更快地谦让，则 turn 变量会被另一个进程的谦让行为给覆盖，从而使得更快谦让的进程先获得进入临界区的资格。因此 Peterson 算法制造了一种看似双方争先恐后地谦让机会，但实际上都是自私行为的现象。</p>
<p>当然，此时该协议的行为还是离散的，我们可以通过一般的自动机进行建模。</p>
<h2 id="Fischer协议"><a href="#Fischer协议" class="headerlink" title="Fischer协议"></a>Fischer协议</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Process i:</span><br><span class="line">while (true) &#123;</span><br><span class="line">    &lt;noncritical section&gt;</span><br><span class="line">    while id != 0 do &#123;&#125;</span><br><span class="line">    delay K1;</span><br><span class="line">    id = i;</span><br><span class="line">    delay K2;</span><br><span class="line">    if (id = i) &#123;</span><br><span class="line">        &lt;critical section&gt;</span><br><span class="line">        id = 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 id 是一个共享变量，每个进程有自己的时钟用于延迟，上述算法的正确性需要 K2 &gt; K1。</p>
<p>该算法的思路是，如果一开始有人想要用或者已经用了临界区，我就死等，否则等待 K1 的时间，再宣告自己想要用这个临界区。再等待 K2 的时间，如果没有人提出异议，即 id = i，则进入临界区。</p>
<p>由于 K2 &gt; K1，所以如果进入了临界区就说嘛没有人提出异议，从而这个并发控制是安全的。</p>
<p>对这个算法进行建模就需要时间自动机。</p>
<h2 id="建模实时系统"><a href="#建模实时系统" class="headerlink" title="建模实时系统"></a>建模实时系统</h2><p>我们对于时间有两种模型：</p>
<ul>
<li>离散时间域(discrete time domain)</li>
<li>连续时间域(continuous time domain)</li>
</ul>
<h3 id="离散时间域"><a href="#离散时间域" class="headerlink" title="离散时间域"></a>离散时间域</h3><p>时间被分割为固定的间隔。</p>
<p>本质上来说，这仍然是一个离散系统，只需要将原本的状态加上一个整数参数来表示时间。</p>
<p>时间间隔的大小选择也很关键，如果时间间隔太小，则状态空间会非常大，而如果时间间隔太大，则无法精细刻画系统的行为。</p>
<h3 id="连续时间域"><a href="#连续时间域" class="headerlink" title="连续时间域"></a>连续时间域</h3><p>当通过一条边，时钟可以被重置，但是只允许将时钟重置到为$0$。</p>
<p>状态上也可以加入不变式(invariants)进行约束，从而禁止系统在一个状态停留时间过长。</p>
<h2 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h2><p>令$X$是一个时钟变量的集合，那么时钟约束(time constraints)的集合$C(X)$由以下文法定义：</p>
<script type="math/tex; mode=display">\empty=x\leq k\mid k\leq x\mid x<k\mid k<x\mid\empty\wedge \empty</script><p>其中$x\in X,k\in\mathbb{N}$</p>
<p>定义<strong>时间自动机</strong>(time automata)是一个四元组$(L,X,I_0,E)$：</p>
<ul>
<li>$L$是一个有限地点(location)集合</li>
<li>$X$是一个有限时钟变量集合</li>
<li>$I_0\in L$是一个初始地点</li>
<li>$E\subseteq L\times C(X)\times 2^X\times L$是一个边的集合，四元组的含义为(源地点，时钟约束，重置时钟集，目标地点)</li>
</ul>
<p>时间自动机的状态是由位置和时钟值组成的二元组，时间自动机的状态转移有两种:</p>
<ul>
<li>等待：只有时钟值变化</li>
<li>行动：位置变化</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/29/Petri%E7%BD%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/29/Petri%E7%BD%91/" class="post-title-link" itemprop="url">【九】Petri网</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-29 16:59:59" itemprop="dateCreated datePublished" datetime="2024-12-29T16:59:59+08:00">2024-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-30 19:38:35" itemprop="dateModified" datetime="2024-12-30T19:38:35+08:00">2024-12-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="哲学家吃面问题"><a href="#哲学家吃面问题" class="headerlink" title="哲学家吃面问题"></a>哲学家吃面问题</h2><p>哲学家吃面问题指的是有若干哲学家和若干叉子交替摆放在一个圆桌上，每个哲学家必须拿起手边的两个叉子才能够吃面，吃完面后可以放下叉子。</p>
<p>我们尝试使用迁移系统来对该问题进行建模，可以发现，当哲学家数量变多，状态的总数呈现指数级增长。使得我们建模变得复杂困难。</p>
<h2 id="从自动机到Petri网"><a href="#从自动机到Petri网" class="headerlink" title="从自动机到Petri网"></a>从自动机到Petri网</h2><p>自动机是一个理论化的理想化的模型，它反映了一个牛顿式的世界观：</p>
<ul>
<li>空间和时间作为绝对参考系；</li>
<li>过程视为该参考系下由时钟驱动。</li>
</ul>
<p>而Petri网中：</p>
<ul>
<li>状态是分布式的，迁移是本地化的；</li>
<li>本地的因果关系取代了全局时间；</li>
<li>子系统之间通过显示的通信进行交互。</li>
</ul>
<p>和状态机相比，Petri网中的状态迁移是不同步的。</p>
<h1 id="Petri网"><a href="#Petri网" class="headerlink" title="Petri网"></a>Petri网</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Petri 网是一个图形化、数学化的建模工具，可以用来模拟并发的、非同步的、分布式的、并行的、非确定性的、随机的系统。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/Petri/1.png?raw=true" alt="1"></p>
<p>一般来说Petri网的组成要素有以下：</p>
<ul>
<li>地点(Places)：通常用来建模资源或者系统的部分状态，用圆形结点表示</li>
<li>转移(Transitions)：通常用来建模状态转换和同步，用条形结点表示</li>
<li>弧：有向边，总是连接不同类型的结点</li>
<li>令牌(tokens)：地点中的资源，用圆形结点里的黑点表示</li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Petri网定义为一个四元组$C=(P,T,I,O)$：</p>
<ul>
<li>$P$：地点集合</li>
<li>$T$：转移集合</li>
<li>$I$：是从迁移到输入地点的映射$T\rightarrow 2^P$</li>
<li>$O$：是从迁移到输出地点的映射$T\rightarrow 2^P$</li>
</ul>
<p>定义一张Petri网的标记(marking)为向量$\mu$，$\mu=(\mu_1,\cdots,\mu_n)$，其中$\mu_i$表示地点$i$上的令牌数量。</p>
<p>上图中的Petri网可以表示为：</p>
<p>$C=(\{p_1,p_2,p_3,p_4\},\{t_1,t_2,t_3\},\{(t_1,\{p_1,p_2,p_3\}),(t_2,\{p_4\}),(t_3,\{p_3\})\},\{(t_1,\{p_1\}),(t_2,\{p_2\}),(t_3,\{p_4\})\})$</p>
<p>标记为$\mu=1010$</p>
<h2 id="点火"><a href="#点火" class="headerlink" title="点火"></a>点火</h2><p>我们称一个特定转移$t$在特定标记$\mu$下是enabled，如果对于从任意地点$p$到$t$的弧，在该标记$\mu$下$p$都存在一个令牌。</p>
<p>一个在$\mu$下被赋能的转移$t$可以fire，导致一个新的标记$\mu’$。</p>
<p>fire一个被enabled的转移$t$会发生两件事：</p>
<ol>
<li>对于每一个从地点$p$到转移$t$的弧，从地点$p$中删除一个令牌。</li>
<li>对于每一个从转移$t$到地点$p$的弧，向地点$p$添加一个令牌。</li>
</ol>
<p>定义Petri网的一次运行(run)是一个标记和转移的序列，例如：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/Petri/2.png?raw=true" alt="2">)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/21/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/21/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/" class="post-title-link" itemprop="url">【十一】数字签名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-21 11:18:00" itemprop="dateCreated datePublished" datetime="2024-12-21T11:18:00+08:00">2024-12-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-25 16:51:32" itemprop="dateModified" datetime="2024-12-25T16:51:32+08:00">2024-12-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在公钥加密体系中，我们用数字签名实现完整性验证，对应私钥加密中的MAC。</p>
<p>数字签名允许资格签名者使用自己的私钥对消息进行签名，而他人通过签名者的公钥来进行验证。</p>
<p>数字签名相较于消息认证码有以下优势：</p>
<ul>
<li>可公开验证</li>
<li>可转移性</li>
<li>不可否认性</li>
</ul>
<p>与公钥和对称密钥加密的情况类似，消息认证码的生成和验证比数字签名更高效，效率通常高 2-3 个数量级。此外，消息认证码的长度也更短。因此，在无需公开验证、可转移性和/或不可否认性的场景下，且发送方主要与单一接收方通信（并能与其共享一个秘密密钥）时，应优先使用消息认证码。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一个数字签名方案是一个三元组$(Gen,Sign,Vrfy)$：</p>
<ul>
<li>$Gen(1^n)$生成一对公钥$pk$和私钥$sk$，其中$pk$和$sk$的长度均为$n$</li>
<li>$Sign(sk,m)$接受一个消息$m$，用私钥$sk$对$m$进行签名，并返回一个签名$\sigma\leftarrow Sign_{sk}(m)$</li>
<li>$Vrfy(pk,\sigma,m)$接受一个签名$\sigma$，一个消息$m$和一个公钥$pk$，并返回一个布尔值，表示签名$\sigma$是否与消息$m$匹配，$b:=Vrfy_{pk}(m,\sigma)$</li>
</ul>
<p>除非以可忽略的概率，$Vrfy<em>{pk}(m,Sign</em>{sk}(m))=1$。</p>
<p>签名方案的安全性意味着无法生成对一个新消息伪造签名，我们定义安全性实验$Sig-forge_{\mathcal{A},\prod}$：</p>
<ol>
<li>允许$Gen(1^n)$生成一对公钥$pk$和私钥$sk$</li>
<li>攻击者$\mathcal{A}$获得$pk$和签名查询机$Sign_{sk}(\cdot)$，最终输出$(m,\sigma)$</li>
<li>当且仅当 $Vrfy_{pk}(m,\sigma)=1$且这里的消息在之前没有被查询过时，实验结果为$1$，否则为$0$ </li>
</ol>
<p>我们定义一个数字签名方案是在选择消息攻击中不可伪造的当且仅当对于任何PPT攻击者$\mathcal{A}$，存在可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1.png?raw=true" alt="1"></p>
<h1 id="Hash-and-Sign"><a href="#Hash-and-Sign" class="headerlink" title="Hash-and-Sign"></a>Hash-and-Sign</h1><p>对于长消息，直接使用数字签名很麻烦，我们可以将其先使用哈希函数映射到短消息，再进行数字签名。</p>
<p>而这种方法也是安全的，安全性基于哈希函数的抗碰撞性。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/2.png?raw=true" alt="2"></p>
<h1 id="基于RSA的数字签名"><a href="#基于RSA的数字签名" class="headerlink" title="基于RSA的数字签名"></a>基于RSA的数字签名</h1><h2 id="Plain-RSA"><a href="#Plain-RSA" class="headerlink" title="Plain RSA"></a>Plain RSA</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>构造如下：</p>
<ul>
<li>$Gen$：运行$GenRSA(1^n)$生成$(N,e,d)$，公钥为$(N,e)$，私钥为$(N,d)$</li>
<li>$Sign$：接受私钥$(N,d)$和消息$m$，返回签名$\sigma=[m^d\bmod N]$</li>
<li>$Vrfy$：接受公钥$(N,e)$，签名$\sigma$，和消息$m$，返回$1$当且仅当$m=[\sigma^e\bmod N]$</li>
</ul>
<h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><h4 id="无消息攻击"><a href="#无消息攻击" class="headerlink" title="无消息攻击"></a>无消息攻击</h4><p>步骤如下：</p>
<ul>
<li>给定公钥$pk=(N,e)$，选择一个均匀分布的$\sigma\in \mathbb{Z}_N^*$</li>
<li>计算$m:=[\sigma^e\bmod N]$</li>
<li>输出伪造签名$(m,\sigma)$</li>
</ul>
<h4 id="对任意消息的签名伪造"><a href="#对任意消息的签名伪造" class="headerlink" title="对任意消息的签名伪造"></a>对任意消息的签名伪造</h4><ul>
<li>选择任意$m_1,m_2\in \mathbb{Z}_N^*$，满足$m=m_1\cdot m_2 \bmod N$</li>
<li>攻击者获得$m_1,m_2$的标签$\sigma_1,\sigma_2$</li>
<li>计算$\sigma:=[\sigma_1\cdot \sigma_2\bmod N]$</li>
<li>输出伪造签名$(m,\sigma)$</li>
</ul>
<h2 id="RSA-FDH"><a href="#RSA-FDH" class="headerlink" title="RSA-FDH"></a>RSA-FDH</h2><h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><p>令$H(\cdot)$是一个函数满足以下要求：</p>
<ul>
<li>这是一个单向函数或者很难求逆</li>
<li>这是一个不可操作的函数</li>
<li>这是一个抗碰撞函数</li>
</ul>
<p>构造如下：</p>
<ul>
<li>$Gen$：运行$GenRSA(1^n)$生成$(N,e,d)$，公钥为$(N,e)$，私钥为$(N,d)$</li>
<li>$Sign$：$\sigma:=[H(m)^d\bmod N]$</li>
<li>$Vrfy$：当且仅当$\sigma^e=H(m)\bmod N$时为$1$</li>
</ul>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>这个方案是安全的。</p>
<h1 id="基于Discrete-Logarithm-Problem的签名方案"><a href="#基于Discrete-Logarithm-Problem的签名方案" class="headerlink" title="基于Discrete-Logarithm Problem的签名方案"></a>基于Discrete-Logarithm Problem的签名方案</h1><h2 id="身份验证方案和签名"><a href="#身份验证方案和签名" class="headerlink" title="身份验证方案和签名"></a>身份验证方案和签名</h2><h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>我们需要在交互的时候向另一方自证身份。在身份验证方案中，我们称验证自己身份的一方是Prover，验证对方身份的一方是Verifier。我们只考虑公钥加密的情况，双方并未事先交换任何信息。验证者只知道证明者的公钥。身份验证协议的成功执行可以让验证者确信，它正在与预期的证明者而非冒名顶替者通信。</p>
<p>我们仅考虑一种特定形式的三轮身份验证方案，其中证明者由两个算法$P_1,P_2$指定，验证者由算法$V$指定。</p>
<ol>
<li>证明者运行$P_1(sk)$获得初始消息$I$和状态信息$st$，将$I$发送给验证者。</li>
<li>验证者从证明者公钥$pk$定义的$\Omega_{pk}$中均匀挑选一个$r$，发送给证明者。</li>
<li>证明者运行$P_2(sk,r,st)$，得到响应$s$，将$s$发送给验证者。</li>
<li>验证者运行$V(pk,r,s)$，并接受当且仅当结果与初始消息$I$一致。</li>
</ol>
<p>我们考虑基于discrete logarithm的签名方案。现在公钥是$y=g^x$，prover要证明自己知道x$。</p>
<p>如果prover直接将$x$发送给验证者验证，会丧失私钥的保密性。</p>
<p>我们考虑以下方案：</p>
<ol>
<li>prover随机选择$b\in \mathbb{Z}_p$，计算$I=g^b$，将$I$发送给验证者</li>
<li>verifier随机选择$a\in \mathbb{Z}_p$，发给prover</li>
<li>prover发送$X=[ax+b\bmod q]$给verifier</li>
<li>verifier验证是否$y^a\cdot I=g^x$</li>
</ol>
<p>这个方案是安全的，基于离散对数问题是困难的假设。</p>
<p>我们可以通过以下思路证明安全性：</p>
<ol>
<li>构造一个模拟器$S$，该模拟器在不知道私钥$x$的情况下，能够模拟窃听者在方案中所看到的视图或交互记录（即，窃听到的消息）。</li>
<li>证明没有多项式时间的攻击者能够区分模拟视图与真实视图：换句话说，任何 PPT 攻击者都无法分辨模拟器生成的视图和方案中真实交互生成的视图之间的区别。</li>
</ol>
<h2 id="Schnorr签名方案"><a href="#Schnorr签名方案" class="headerlink" title="Schnorr签名方案"></a>Schnorr签名方案</h2><p>构造如下，令$\mathcal{G}$是一个循环群生成算法，$H:\{0,1\}^* \to \mathbb{Z}_q$是一个哈希函数：</p>
<ul>
<li>$Gen$：运行$\mathcal{G}(1^n)$生成$(\mathbb{G},q,g)$，随机选择$x\in\mathbb{Z}_q$，计算$y=g^x$，公钥为$(\mathbb{G},q,g,y)$，私钥为$x$</li>
<li>$Sign$：接受私钥$x$和消息$m$，随机选择$b\in\mathbb{Z}_q$，计算$I=g^b$，计算$a=H(I,m),X=[ax+b\bmod q]$，输出签名$(a,X)$</li>
<li>Vrfy：接受公钥$(\mathbb{G},q,g,y)$，签名$(a,X)$，和消息$m$，计算$I’=g^X\cdot y^{-a}$，输出$1$当且仅当$H(I’,m)=a$。</li>
</ul>
<h1 id="证书与公钥基础设施"><a href="#证书与公钥基础设施" class="headerlink" title="证书与公钥基础设施"></a>证书与公钥基础设施</h1><p>我们要展示如何利用公钥密码学本身安全分发公钥。</p>
<p>我们要证明，如果一个可信方的公钥能够以安全的方式分发，该密钥可以用来引导其他任意数量公钥的安全分发，所以这从原则上讲，安全密钥分发的问题只需要解决一次。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书是将一个实体与一个公钥绑定在一起的签名。假设一方Charlie对某个安全的数字签名方案生成了密钥对$(pk<em>C,sk_C)$，这时另一方Bob也生成了密钥对$(pk_B,sk_B)$，Charlie可以为$pk_B$计算签名$cert</em>{C\to B}=Sign_{sk_C}(Bob’s key is pk_B)$，然后将签名提供给Bob。</p>
<h2 id="证书的使用"><a href="#证书的使用" class="headerlink" title="证书的使用"></a>证书的使用</h2><p>假设Bob想和知道$pk<em>C$的另一方Alice通信。Bob可以将$(pk_B,cert</em>{C\to B})$发送给Alice，Alice可以验证，如果信任Charlie，可以接受$pk_B$作为Bob的合法公钥。</p>
<p>指定所有完整的细节就构成了一个公钥基础设施(Public-key Infrastructure,PKI)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/20/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/20/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/" class="post-title-link" itemprop="url">【十】公钥加密</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-20 01:51:57" itemprop="dateCreated datePublished" datetime="2024-12-20T01:51:57+08:00">2024-12-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-23 23:45:25" itemprop="dateModified" datetime="2024-12-23T23:45:25+08:00">2024-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>公钥加密的引入是密码学领域的一场革命。</p>
<p>对称密码学的场景中必须双方都商定一个共享密钥，而公钥加密中这是非对称的，接收方生成一对密钥$(pk,sk)$，分别是公钥和私钥，发送方使用公钥加密消息，接受方使用私钥解密密文。</p>
<p>目标是避免双方事先见面交换任何信息，那么发送发如何获取公钥$pk$，假设A是接受方，B是发送方：</p>
<ol>
<li>A生成$(pk,sk)$并将$pk$发送给B，但是这里假设攻击者无法修改A发送给B的密钥，即经过认证安全的信道。</li>
<li>A提前公开自己的公钥，使得任何一方都可以使用相同的公钥与A进行加密童话。</li>
</ol>
<p>我们可以看到，公钥的本质是完全公开的。</p>
<h2 id="与对称加密的比较"><a href="#与对称加密的比较" class="headerlink" title="与对称加密的比较"></a>与对称加密的比较</h2><p>相比之下，公钥加密的优势有：</p>
<ul>
<li>解决密钥分发问题</li>
<li>单个接受多个发送方时更方便</li>
<li>支持开放系统</li>
</ul>
<p>公钥加密的主要缺点就是：</p>
<ul>
<li>效率低，速度比对称密钥加密要慢2-3个数量级。</li>
<li>公钥加密通常会导致更大的密文扩展（即需要存储或传输更多的比特）。</li>
</ul>
<h2 id="公钥的安全分发"><a href="#公钥的安全分发" class="headerlink" title="公钥的安全分发"></a>公钥的安全分发</h2><p>如果攻击者能纂改信道，破坏传输的公钥，那么在没有事先共享信息的情况下无法做到加密通信。所以我们目前讨论的是攻击者仅能获取公钥。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一个公钥加密方案是一个多项式概率算法三元组$(Gen,Enc,Dec)$，其中：</p>
<ul>
<li>$Gen$：接受输入$1^n$，输出密钥对$(pk,sk)$，其中$pk$是公钥，$sk$是私钥。我们不妨假设两个密钥的长度都为$n$。其中公钥$pk$可以定义消息空间为$\mathcal{M}_{pk}$。</li>
<li>$Enc$：接受$pk$和消息$m\in \mathcal{M}<em>{pk}$，输出密文$c\leftarrow Enc</em>{pk}(m)$。这里$Enc$一定是一个概率算法。</li>
<li>$Dec$：接受$sk$和密文$c$，输出消息$m:= Dec_{sk}(c)$。可以输出错误符号$\perp$。</li>
</ul>
<p>这里要求，除非以可忽略的概率，$\forall m\in \mathcal{M}<em>{pk},Dev</em>{sk}(Enc_{pk}(m))=m$。</p>
<h2 id="对于选择明文攻击的安全性-CPA"><a href="#对于选择明文攻击的安全性-CPA" class="headerlink" title="对于选择明文攻击的安全性(CPA)"></a>对于选择明文攻击的安全性(CPA)</h2><p>定义以下实验$PubK^{eav}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>运行$Gen(1^n)$获得$(pk,sk)$</li>
<li>攻击者$\mathcal{A}$获得$pk$，输出两个等长消息$m<em>1,m_2\in \mathcal{M}</em>{pk}$</li>
<li>随机均匀选择$b\in\{0,1\}$，计算$c\leftarrow Enc_{pk}(m_b)$，将其返回给$\mathcal{A}$</li>
<li>$\mathcal{A}$输出$b’$，当且仅当$b=b’$，实验结果为$1$，反之为$0$</li>
</ol>
<p>一个公钥加密方案被认为在有窃听者的情况下是不可区分的当且仅当对于任意PPT攻击者$\mathcal{A}$，存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/1.png?raw=true" alt="1"></p>
<p>攻击者知道公钥$pk$，而我们之前也说过加密方案也是不保密的，这意味着攻击者实际上得到一个加密查询机，可以进行选择明文攻击，所以上述定义的安全性等价于<strong>CPA-Security</strong>。这也就呼应了上述观点，加密算法一定是概率算法，不能为确定性算法。</p>
<h2 id="多消息加密"><a href="#多消息加密" class="headerlink" title="多消息加密"></a>多消息加密</h2><p>对于CPA安全的公钥加密方案，其多消息加密也是CPA安全的。</p>
<p>这也就意味着我们遇到长消息可以拆分成固定长度的块进行加密，从而实现从固定长度加密方案到任意长度的加密方案，而且修改后的方案仍然安全。</p>
<h2 id="对于选择密文攻击的安全性-CCA"><a href="#对于选择密文攻击的安全性-CCA" class="headerlink" title="对于选择密文攻击的安全性(CCA)"></a>对于选择密文攻击的安全性(CCA)</h2><p>在选择密文攻击中，攻击者能够解密其选择的任意密文。假设窃听者观察到一个S发送给R的密文$c$，有以下两种方式进行选择密文攻击：</p>
<ol>
<li>伪装成S发送修改后的密文$c’$</li>
<li>以自己的名义发送密文$c’$</li>
</ol>
<p>定义以下实验$PubK^{cca}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>运行$Gen(1^n)$获得$(pk,sk)$</li>
<li>攻击者$\mathcal{A}$获得$pk$和一个解密查询机$Dec<em>{sk}(\cdot)$，输出两个等长消息$m_1,m_2\in \mathcal{M}</em>{pk}$</li>
<li>随机均匀选择$b\in\{0,1\}$，计算$c\leftarrow Enc_{pk}(m_b)$，将其返回给$\mathcal{A}$</li>
<li>攻击者$\mathcal{A}$可以继续查询任何除了密文$c$本身以外的密文解密，最终$\mathcal{A}$输出$b’$</li>
<li>当且仅当$b=b’$，实验结果为$1$，反之为$0$</li>
</ol>
<p>一个公钥加密方案被认为在有选择密文攻击的情况下是不可区分的当且仅当对于任意PPT攻击者$\mathcal{A}$，存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/2.png?raw=true" alt="2"></p>
<p>如果一个公钥加密方案是CPA安全的，那么该方案对于多消息加密也是CPA安全的，但是上一小节中所述的从定长到任意长度的修改后方案不是CPA安全的，因为可以通过调换块的位置进行解密查询。</p>
<h1 id="混合加密与KEM-DEM范式"><a href="#混合加密与KEM-DEM范式" class="headerlink" title="混合加密与KEM/DEM范式"></a>混合加密与KEM/DEM范式</h1><p>公钥加密通常会导致更大的密文扩展（即需要存储或传输更多的比特）公钥加密通常会导致更大的密文扩展（即需要存储或传输更多的比特）公钥加密通常会导致更大的密文扩展（即需要存储或传输更多的比特）。</p>
<p>所以提出了混合加密的方案：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86/3.png?raw=true" alt="3"></p>
<p>密钥封装机制（Key-Encapsulation Mechanism, KEM）是一种公钥原语，用于在混合加密方案中高效生成对称密钥加密所需的加密密钥$k$及其对应的密文$c$。相应地，对称密钥加密方案在此场景中被称为数据封装机制（Data-Encapsulation Mechanism, DEM）。</p>
<h1 id="基于CDH-DDH加密"><a href="#基于CDH-DDH加密" class="headerlink" title="基于CDH/DDH加密"></a>基于CDH/DDH加密</h1><p>现在我们讨论一些构造实例。</p>
<h2 id="El-Gamal-加密"><a href="#El-Gamal-加密" class="headerlink" title="El Gamal 加密"></a>El Gamal 加密</h2><p>这是基于Diffie-Hellman密钥交换协议。</p>
<p>令$\mathcal{G}$是一个多项式概率性算法，其接受$1^n$作为输入，输出一个循环群$\mathcal{G}$，其阶$q$，其生成元$g\in\mathcal{G}$。</p>
<p>构造如下：</p>
<ul>
<li>$Gen$：接受$1^n$，运行$\mathcal{G}(1^n)$，获得$(\mathbb{G},q,g)$，均匀随机选择$x\in\mathbb{Z}_q$，计算$h:=g^x$，公钥就是$(\mathcal{G},q,g,h)$， 私钥是$(\mathbb{G},q,g,x)$，消息空间是$\mathbb{G}$</li>
<li>$Enc$：接受公钥$(\mathcal{G},q,g,h)$和消息$m\in \mathbb{G}$，随机均匀选择$y\in\mathbb{Z}_q$，密文是$(g^y,h^y\cdot m)$</li>
<li>$Dec$：接受私钥$(\mathbb{G},q,g,x)$和密文$(c_1,c_2)$，输出$c_2/ c_1^x$</li>
</ul>
<p>因为$\hat{m}=\frac{c_2}{c_1^x}=\frac{h^y\cdot m}{g^{xy}}=m$，所以这个方案是正确的。</p>
<p>如果DDH问题是难问题，那么这个加密方案是CPA安全的。</p>
<p>但是这个方案不是CCA安全的，因为这个加密方案是可操作的，比如我们有密文$(c_1,c_2)$，我们可以构造出$(c_1^2,c_2^2)$，其是$m^2$的密文。</p>
<h1 id="基于RSA加密"><a href="#基于RSA加密" class="headerlink" title="基于RSA加密"></a>基于RSA加密</h1><p>这里的构造基于RSA是难问题的假设。</p>
<h2 id="Plain-RSA"><a href="#Plain-RSA" class="headerlink" title="Plain RSA"></a>Plain RSA</h2><p>首先定义$GenRSA$，这是一个PPT算法，过程如下：</p>
<ol>
<li>接受输入$1^n$</li>
<li>运行$GenModules(1^n)$，获得$(N,p,q)$</li>
<li>计算$\phi(N)=(p-1)\cdot(q-1)$，选择$e$使$\gcd(e,\phi(N))=1$</li>
<li>计算$d:=[e^{-1}\bmod\phi(N)]$</li>
<li>输出$(N,e,d)$</li>
</ol>
<p>根据这个算法，我们有以下加密方案构造：</p>
<ul>
<li>$Gen$：接受$1^n$，运行$GenRSA(1^n)$，获得$(N,e,d)$，公钥是$(N,e)$，私钥是$(N,d)$，消息空间是$\mathbb{Z}_N^*$</li>
<li>$Enc$：接受公钥$(N,e)$和消息$m\in\mathbb{Z}_N^*$，密文是$c:=[m^e\bmod N]$ </li>
<li>$Dec$：接受私钥$(N,d)$和密文$c\in\mathbb{Z}_N^*$，输出$m:=[c^d\bmod N]$</li>
</ul>
<p>而这是一个确定性算法，所以不是CPA安全的。</p>
<h2 id="Padded-RSA"><a href="#Padded-RSA" class="headerlink" title="Padded RSA"></a>Padded RSA</h2><p>主要思想是需要一个填充算法：</p>
<ul>
<li>将原消息随即填充至$\mathbb{Z}_N^*$中的一个长消息，将其加密</li>
<li>解密后使用填充算法的逆算法进行换元，所以这就意味着填充必须是可逆的</li>
</ul>
<p>该方案的安全性依赖于具体的填充算法。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/18/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E5%8F%98%E9%9D%A9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/18/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E5%85%AC%E9%92%A5%E5%8A%A0%E5%AF%86%E5%8F%98%E9%9D%A9/" class="post-title-link" itemprop="url">【九】密钥管理与公钥加密变革</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-18 14:27:25" itemprop="dateCreated datePublished" datetime="2024-12-18T14:27:25+08:00">2024-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-20 01:50:56" itemprop="dateModified" datetime="2024-12-20T01:50:56+08:00">2024-12-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="密钥分发和密钥管理"><a href="#密钥分发和密钥管理" class="headerlink" title="密钥分发和密钥管理"></a>密钥分发和密钥管理</h1><p>我们一直没有讨论这样一个问题，在之前的私钥加密体系中，双方最初如何共享一个密钥。</p>
<p>显然，如果要安全的共享密钥，就必须要有一个安全的信道来可靠的共享，但这要付出很高的代价。保存密钥、分享密钥在开放系统中是非常困难的。</p>
<p>总之，关于私钥加密存在以下问题：</p>
<ul>
<li>密钥分发</li>
<li>管理和存储大量密钥</li>
<li>对开放系统的不适用性</li>
</ul>
<h1 id="部分解决方案：密钥分发中心"><a href="#部分解决方案：密钥分发中心" class="headerlink" title="部分解决方案：密钥分发中心"></a>部分解决方案：密钥分发中心</h1><p>一种解决的方法是使用密钥分发中心(Key-Distribution Center, KDC)。</p>
<p>假设这是一个大型公司的场景，所有员工之间需要能够进行安全通信，我们可以利用所有员工都信任某个实体（比如管理员），让这个可信实体充当KDC。</p>
<p>当新员工入职，KDC可以以安全的方式（比如面对面）交付给新员工密钥，这其中包括：</p>
<ol>
<li>KDC和新员工之间的共享密钥</li>
<li>新员工和员工之间共享的密钥</li>
</ol>
<p>当然这个方法需要员工储存很多密钥，我们可以通过另一种方式避免，考虑员工A和B需要进行通话：</p>
<ol>
<li>A用$k_A$向KDC发送消息，申请和B进行通话</li>
<li>KDC返回一个随机密钥$k$给A和B</li>
<li>A和B使用密钥$k$进行通信，结束后密钥$k$失效。</li>
</ol>
<p>以上方式的优点在于：</p>
<ul>
<li>每位员工只需要保存一个密钥</li>
<li>当一名员工加入组织，只需要与KDC建立密钥</li>
</ul>
<p>当然也存在缺点：</p>
<ul>
<li>对KDC的成功攻击会导致整个系统全部崩溃，也存在内部攻击的风险</li>
<li>KDC单点故障会或频繁请求会导致通信失败，负载过高。</li>
</ul>
<h2 id="使用-KDC-进行密钥分发的协议"><a href="#使用-KDC-进行密钥分发的协议" class="headerlink" title="使用 KDC 进行密钥分发的协议"></a>使用 KDC 进行密钥分发的协议</h2><p>我们下面介绍<strong>Needham–Schroeder协议</strong>。</p>
<p>当A请求和B通信：</p>
<ol>
<li>KDC将使用$k_A$加密的会话密钥和使用$k_B$加密的会话密钥(ticket)发送给A</li>
<li>A将ticket转发给B</li>
<li>双方获得会话密钥，进行通信</li>
</ol>
<p>以上方案的好处在于：</p>
<ul>
<li>减少了额外连接，KDC只需要建立一次连接</li>
<li>支持会话的重新启动，但是事实上ticket会有有效期</li>
</ul>
<h1 id="密钥交换和Diffie–Hellman协议"><a href="#密钥交换和Diffie–Hellman协议" class="headerlink" title="密钥交换和Diffie–Hellman协议"></a>密钥交换和Diffie–Hellman协议</h1><p>上述的方案仍然存在最底层的问题，就是在初始分发的时候依赖一个安全信道。但是在互联网这样的开放系统中，是难以实现的。</p>
<p>为了在没有私密信道的情况下进行私密通信，Diffie和Hellman提出了<strong>Diffie–Hellman 协议</strong>。</p>
<p>首先我们仅讨论：</p>
<ul>
<li>攻击者只能窃听，无法干预信道</li>
<li>通信双方在开始时没有任何共享信息</li>
</ul>
<h2 id="安全性定义"><a href="#安全性定义" class="headerlink" title="安全性定义"></a>安全性定义</h2><p>首先我们假设双方运行一个随机化协议$\prod$，能够双方独立运行后生成相同的密钥，直观上，我们希望这个协议生成的密钥和完全随机的密钥对于攻击者是不可区分的。</p>
<p>令$\prod$是密钥交换协议，$\mathcal{A}$是攻击者，$n$是安全参数。<br>定义以下密钥交换实验$KE^{eav}_{\mathcal{A},\prod}(n)$：</p>
<ol>
<li>双方都以$1^n$为参数运行$\prod$，得到$k$和$trans$（全部通信记录）</li>
<li>随机选择$b\in\{0,1\}$，如果$b=0$，则$\hat{k}=k$，否则随机选择$\hat{k}\in\{0,1\}^n$</li>
<li>$\mathcal{A}$接受trans和$\hat{k}$，并返回一个布尔值$b’$</li>
<li>如果$\mathcal{A}$返回$b’=b$，则实验结果为1，否则为0</li>
</ol>
<p>我们根据这个实验可以定义一个密钥交换协议$\prod$是安全的，当且仅当对于任何PPT攻击者$\mathcal{A}$，都存在一个可忽略函数$negl$，使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/1.png?raw=true" alt="1"></p>
<h2 id="Diffie–Hellman-密钥交换协议"><a href="#Diffie–Hellman-密钥交换协议" class="headerlink" title="Diffie–Hellman 密钥交换协议"></a>Diffie–Hellman 密钥交换协议</h2><p>令$\mathcal{G}$是一个多项式概率性算法，其接受$1^n$作为输入，输出一个循环群$\mathcal{G}$，其阶$q$，其生成元$g\in\mathcal{G}$。</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul>
<li>共同输入：$1^n$</li>
<li>协议<ol>
<li>A运行$\mathcal{G}(1^m)$获得$(\mathbb{G},q,g)$</li>
<li>A随机均匀选择$x\in \mathbb{Z}_q$，计算$h_A:=g^x$</li>
<li>A将$(\mathcal{G},q,g,h_A)$发给B</li>
<li>B接受到$(\mathcal{G},q,g,h_A)$，随机均匀选取$y\in\mathbb{Z}_q$，计算$h_B:=g^y$，B将$h_B$发给A并得到密钥$k_B:=h_A^y$</li>
<li>A接受$h_B$，得到密钥$k_A:=h_B^x$</li>
</ol>
</li>
</ul>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/2.png?raw=true" alt="2"></p>
<p>双方的密钥都为$g^{xy}$。因此该方案的正确性得以证明。</p>
<h3 id="安全性证明"><a href="#安全性证明" class="headerlink" title="安全性证明"></a>安全性证明</h3><p>这个协议是安全的，证明如下：</p>
<p>我们首先修改了安全性实验，令$\hat{KE}^{eav}_{\mathcal{A},\prod}(n)$在$b=1$时令$\hat{k}$从$\mathbb{G}$中均匀选取。</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/3.png?raw=true" alt="3"></p>
<p>而根据DDH问题的困难性假设，我们有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/4.png?raw=true" alt="4"></p>
<p>综上有</p>
<p><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86/5.png?raw=true" alt="5"></p>
<p>于是我们完成了证明。</p>
<h3 id="安全性评估"><a href="#安全性评估" class="headerlink" title="安全性评估"></a>安全性评估</h3><p>我们只考虑了攻击者仅窃听情况下的安全性，但是我们仍然要考虑：</p>
<ul>
<li>攻击者冒充一方</li>
<li>攻击者拦截并修改信息</li>
</ul>
<p>显然上述方案对这两种攻击不能防护。但是上述方案首次在理论上展示了不对称技术可以用于解决密码学中的难题。</p>
<h1 id="公钥加密变革"><a href="#公钥加密变革" class="headerlink" title="公钥加密变革"></a>公钥加密变革</h1><p>除了密钥交换，Diffie和Hellman还提出了公钥密码学的概念。</p>
<p>在公钥密码学中，希望进行安全通信的一方会生成一对密钥，一个公钥用于广泛传播，另一个私钥则保持秘密。这种方案也被称为非对称加密。我们可以通过公钥加密方案来保证消息的保密性，用数字签名保证消息的完整性。</p>
<p>公钥密码学的出现使得：</p>
<ol>
<li>允许通过公共信道进行密钥分发</li>
<li>减少了用户存储大量密钥的需求</li>
<li>更适合开放环境</li>
</ol>
<p>很显然，公钥密码学比对称密码学更强大，但是对称密码学更高效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/17/%E6%95%B0%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9B%B0%E9%9A%BE%E5%BA%A6%E5%81%87%E8%AE%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/17/%E6%95%B0%E8%AE%BA%E4%B8%8E%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9B%B0%E9%9A%BE%E5%BA%A6%E5%81%87%E8%AE%BE/" class="post-title-link" itemprop="url">【八】数论与密码学困难度假设</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-17 11:16:30" itemprop="dateCreated datePublished" datetime="2024-12-17T11:16:30+08:00">2024-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-23 18:58:56" itemprop="dateModified" datetime="2024-12-23T18:58:56+08:00">2024-12-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第九章 Number Theory and Cryptographic Hardness Assumptions</p>
<p>到目前为止我们构建的现代密码学系统无一例外都基于一些假设：</p>
<ul>
<li>对称密钥密码学和消息验证码都基于伪随机置换存在的假设</li>
<li>伪随机置换的存在基于单向函数存在的假设</li>
<li>单向函数的存在基于一些问题是难问题的假设</li>
</ul>
<p>这一章我们将研究数论，这是进一步研究难问题的基础。</p>
<h1 id="预备知识和基本群论"><a href="#预备知识和基本群论" class="headerlink" title="预备知识和基本群论"></a>预备知识和基本群论</h1><h2 id="素数和可除性"><a href="#素数和可除性" class="headerlink" title="素数和可除性"></a>素数和可除性</h2><p>首先，我们记$\mathbb{Z}$为整数集合。</p>
<p>对于$a,b\in\mathbb{Z}$，如果存在整数$c$，使得$ac=b$，则我们记作$a\mid b$，否则记作$a\nmid b$。（我们主要关注都是正数的情况，尽管这个定义在存在负数或零时也成立）</p>
<p>存在结论，如果$a\mid b$且$a\mid c$，那么$\forall X,Y\in\mathbb{Z}$，$s.t. a\mid(Xb+Yc)$。</p>
<p>如果$a\mid b$且$a&gt;0$，我们称$a$是$b$的<strong>除数</strong>(divisor)，如果$a\notin \{1,b\}$，则称$a$是$b$的<strong>非平凡除数</strong>(nontrivial divisor)或<strong>因子</strong>(factor)。如果一个大于一的正整数没有因子，则称其为<strong>素数</strong>(prime)，否则为<strong>合数</strong>(composite)。$1$既不是素数也不是合数。</p>
<p><strong>算数基本定理</strong>指出任何大于$1$的正整数可以唯一地写成素数的乘积，即$\forall N&gt;1,N= \prod_{i}p_i^{e_i}$。</p>
<p>我们熟悉的余数可以形式化表述为，令$a$是一个整数，$b$是一个正整数，一定存在唯一的整数$q,r$，使$a=qb+r$且$0\leq r&lt;b$。</p>
<p>对于给定整数的除法，我们可以在多项式事件内算出商和余数。在<strong>算法数论</strong>的背景下，整数输入通常用二进制表示，因此算法的运算时间是根据输入整数$N$的长度衡量的，记作$\parallel N \parallel =  \lfloor \log N\rfloor +1$。</p>
<p>我们称整数$a,b$的<strong>最大公约数</strong>(greatest common divisor)，记作$\gcd(a,b)$，是满足$c\mid a$和$c\mid b$的最大整数$c$。我们一般只考虑$a,b$都是正整数的情况。但是要注意$\gcd(0,b)=\gcd(b,0)=b$。若$p$为素数，则$\gcd(p,q)=1$或$gcd(p,q)=p$。如果$\gcd(a,b)=1$，则称$a,b$<strong>互质</strong>(relatively prime)。</p>
<p>对于$a,b$是正整数，那么存在整数$X,Y$使得$Xa+Yb=\gcd(a,b)$。</p>
<p>存在算法在多项式时间内计算$\gcd(a,b)$和对应的$X,Y$。</p>
<p>如果$c\mid ab$且$\gcd(a,c)=1$，则$c\mid b$。如果$p$是质数且$p\mid ab$，则$p\mid a$或$p\mid b$。</p>
<p>如果$a\mid N$且$b\mid N$且$\gcd(a,b)=1$，则$ab\mid N$。</p>
<h2 id="模运算"><a href="#模运算" class="headerlink" title="模运算"></a>模运算</h2><p>我们用$a \bmod b$表示$a$被$b$整除的余数。</p>
<p>$a$和$b$同余表示为$a=b \bmod N$，等价于$N\mid (a-b)$。</p>
<p>同余是一个等价关系，其满足自反性、对称性、传递性。</p>
<p>同余也满足加法、减法和乘法的算数法则，如果$a=a’\bmod N,b=b’\bmod N$：</p>
<ul>
<li>$(a+b)=(a’+b’)\bmod N$</li>
<li>$ab=a’b’\bmod N$</li>
</ul>
<p>显然对于除法，同余是不可传递的。但是我们可以定义一种有意义的除法。</p>
<p>如果对于给定的整数$b$，存在一个整数$c$使得$bc=1\bmod N$，我们称$b$在模$N$的意义下是<strong>可逆的</strong>(invertible)，并称$c$是$b$在模$N$下的逆元。</p>
<p>$0$是不可逆的。如果$c$是$b$在模$N$下的逆元，那么$c\bmod N$也是。</p>
<p>当$b$是可逆的时候，我们记$b^{-1}$为唯一的在$\{1,\cdots,N-1\}$范围内的乘法逆元。</p>
<p>当$b$是可逆时，我们定义除以$b$等价于乘$b^{-1}$，即$[\frac{a}{b}\bmod N]=[ab^{-1}\bmod N]$。</p>
<p>那么问题的关键就是哪些整数在模$N$下是可逆的。我们有以下结论：令$b\ge 1,N&gt;1$是整数，那么$b$在模$N$下是可逆的当且仅当$gcd(b,N)=1$。</p>
<p>要求$b$在模$N$下的逆元，先找出$X,Y$使得$bX+NY=1\bmod N$，然后计算$b^{-1}=[X\bmod N]$</p>
<p>当然，有关模的计算都是可以多项式时间内完成的。</p>
<ul>
<li>$[a+b\bmod N]$</li>
<li>$[a-b\bmod N]$</li>
<li>$[ab\bmod N]$</li>
<li>$[a^{-1}\bmod N]$</li>
<li>$[a^{k}\bmod N]$</li>
</ul>
<h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>令$\mathbb{G}$是一个集合，该集合上的一个二元运算就是一个将该集合中的两个元素映射到另一个元素的函数$\circ (\cdot,\cdot)$。我们写作$g\circ h$而非$\circ(g,h)$。</p>
<p>一个<strong>群</strong>(group)是一个集合$\mathbb{G}$和一个二元运算$\circ$，满足以下条件：</p>
<ul>
<li>闭包：$\forall g,h\in\mathbb{G},g\circ h\in\mathbb{G}$</li>
<li>存在单位元：$\exists e\in\mathbb{G},s.t.\forall g\in \mathbb{G},e\circ g=g\circ e=g$</li>
<li>存在逆元：$\forall g\in\mathbb{G},\exists h\in\mathbb{G},s.t.g\circ h=h\circ g=e$，我们称之为<strong>逆元</strong>(inverse)。</li>
<li>结合性：$\forall g,h,k\in\mathbb{G},(g\circ h)\circ k=g\circ (h\circ k)$</li>
</ul>
<p>一个群被称为<strong>阿贝尔群</strong>(abelian group)，当且仅当它还满足以下性质：</p>
<ul>
<li>交换性：$\forall g,h\in\mathbb{G},g\circ h=h\circ g$</li>
</ul>
<p>当$\mathbb{G}$为有限集合时，我们用$|\mathbb{G}|$来表示集合$\mathbb{G}$的阶(order)。</p>
<p>我们称$\mathbb{H}$是$\mathbb{G}$的子群(subgroup)，当且仅当$\mathbb{H}\subseteq \mathbb{G}$且$\mathbb{H}$在相同运算下也构成一个群。要验证是子群，我们需要检查：</p>
<ul>
<li>闭包</li>
<li>单位元</li>
<li>逆元</li>
<li>结合性和交换性无需单独验证，自动继承</li>
</ul>
<p>每个群$\mathbb{G}$都有两个<strong>平凡子群</strong>(trivial subgroup)：$\mathbb{G}$和$\{e\}$(单位元)。</p>
<p>若$\mathbb{H}\not = \mathbb{G}$，我们称之为<strong>真子群</strong>(strict subgroup)。</p>
<p>令$\mathbb{G}$是一个群，$a,b,c\in \mathbb{G}$，如果$ac=bc$，则$a=b$。如果$ac=a$，则$a$是该群的单位元。</p>
<h3 id="群的指数运算"><a href="#群的指数运算" class="headerlink" title="群的指数运算"></a>群的指数运算</h3><p>群中的元素可以多次计算：</p>
<ul>
<li>加法： $mg=g+g+\cdots+g$</li>
<li>乘法： $g^m=g\cdot g\cdot \cdots\cdot g$</li>
</ul>
<p>以下性质仍然成立：</p>
<ul>
<li>$g^m\cdot g^n=g^{m+n}$</li>
<li>$(g^m)^n=g^(mn)$</li>
</ul>
<p>如果该群是阿贝尔群，则还满足$g^n\cdot h^n=(gh)^n$。</p>
<p>这些也可以相应拓展到$m$为零或者负数的情况。</p>
<p>一般我们使用$0$表示加法中的单位元，$1$表示乘法中的单位元。</p>
<h3 id="相关定理"><a href="#相关定理" class="headerlink" title="相关定理"></a>相关定理</h3><p>令$\mathbb{G}$是一个有限群，其阶为$m$，那么$\forall g\in \mathbb{G},g^m=1$。</p>
<p>令$\mathbb{G}$是一个有限群，其阶为$m$，那么$\forall g\in \mathbb{G},x\in \mathbb{Z}$，我们有$g^x=g^{x\bmod m}$。</p>
<p>设$\mathbb{G}$是一个有限群，且$|\mathbb{G}| = m &gt; 1$。设$e &gt; 0$是一个整数，并定义函数$f_e : \mathbb{G} \to \mathbb{G}$，其形式为$f_e(g) = g^e$。如果$\gcd(e, m) = 1$，那么$f_e$是一个<strong>置换</strong>（即一个双射）。此外，若$d = e^{-1} \bmod m$，则 $f_d$是$f_e$的<strong>逆函数</strong>。</p>
<p>这个构造在密码学应用中很有用。</p>
<h2 id="群-mathbb-Z-N"><a href="#群-mathbb-Z-N" class="headerlink" title="群$\mathbb{Z}^*_N$"></a>群$\mathbb{Z}^*_N$</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>$\mathbb{Z}^*_N=\{b\in\{1,\cdots,N-1\}\mid \gcd(b,N)=1\}$</p>
<h3 id="相关定理-1"><a href="#相关定理-1" class="headerlink" title="相关定理"></a>相关定理</h3><p>$\mathbb{Z}^*_N$在群运算是模$N$下的乘法，即$ab=[ab\bmod N]$，构成一个阿贝尔群。</p>
<p>定义$\phi(N)=|\mathbb{Z}^*_N|$</p>
<ul>
<li>当$N$为素数时，$\phi(N)=N-1$</li>
<li>当$N=pq$且$p,q$都是不同的质数时，$\phi(N)=(p-1)(q-1)$</li>
</ul>
<p>令$N=\prod_i p_i^{e^i}$，其中$p_i$都是质数，$e_i$都是正整数，那么$\phi(N)=\prod_i p_i^{e^i-1}(p_i-1)$。</p>
<p>取任意整数$N&gt;1$和$a\in \mathbb{Z}^*_N$，有$a^{\phi(N)}=1\bmod N$。如果$N=p$是素数且$a\in\{1,\cdots,p-1\}$，有$a^{p-1}=1\bmod p$。</p>
<p>设$N&gt;1$。对于大于零的整数$e$，定义$f_e:\mathbb{Z}^<em>_N\to \mathbb{Z}^</em>_N$，$f_e(x)=[x^e\bmod N]$。如果$e$和$\phi(N)$互质，则$f_e$是一个置换。如果$d=e^{-1}\bmod \phi(N)$，那么$f_d$是$f_e$的逆函数。</p>
<h2 id="同构和中国剩余定理"><a href="#同构和中国剩余定理" class="headerlink" title="同构和中国剩余定理"></a>同构和中国剩余定理</h2><h3 id="同构的定义"><a href="#同构的定义" class="headerlink" title="同构的定义"></a>同构的定义</h3><p>令$\mathbb{G},\mathbb{H}$是群，其操作符号分别为$\circ<em>{\mathbb{G}},\circ</em>{\mathbb{H}}$，我们称函数$f:\mathbb{G}\to\mathbb{H}$为<strong>同构</strong>(isomorphism)，当且仅当：</p>
<ul>
<li>$f$是一个双射</li>
<li>$\forall g,h\in\mathbb{G},f(g\circ<em>{\mathbb{G}}h)=f(g)\circ</em>{\mathbb{H}}f(h)$</li>
</ul>
<p>如果两个群之间存在这样一个函数，我们写作$\mathbb{G}\cong\mathbb{H}$</p>
<h3 id="中国剩余定理-Chinese-Remainder-Theorem-CRT"><a href="#中国剩余定理-Chinese-Remainder-Theorem-CRT" class="headerlink" title="中国剩余定理(Chinese Remainder Theorem, CRT)"></a>中国剩余定理(Chinese Remainder Theorem, CRT)</h3><p>令$N=pq$，其中$p,q$为互质的正整数，我们有以下结论：</p>
<script type="math/tex; mode=display">\mathbb{Z}_N\cong\mathbb{Z}_p\times\mathbb{Z}_q\text{ and }\mathbb{Z}^*_N\cong\mathbb{Z}^*_p\times\mathbb{Z}^*_q</script><p>令$f$是一个函数，定义为$f(x)=([x\bmod p],[x\bmod q])$，$f$是从$\mathbb{Z}_N$到$\mathbb{Z}_p\times\mathbb{Z}_q$的同构，同时$f$是从$\mathbb{Z}^<em>_N$到$\mathbb{Z}^</em>_p\times\mathbb{Z}^*_q$的同构。</p>
<h3 id="CRT应用举例"><a href="#CRT应用举例" class="headerlink" title="CRT应用举例"></a>CRT应用举例</h3><p>假设我们要计算$g=g_1\circ_G g_2$，其中$g_1,g_2\in\mathbb{G}$，要么直接计算，要么：</p>
<ol>
<li>计算$h_1=f(g_1),h2=f(g_2)$</li>
<li>计算$h=h_1\circ_H h_2$</li>
<li>计算$g=f^{-1}(h)$</li>
</ol>
<h4 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h4><p>计算$14\cdot 13\bmod 15$</p>
<ol>
<li>$(4,2)=f(14),(3,1)=f(13)$</li>
<li>$(4,2)\cdot (3,1)=([4\cdot 3\bmod 5],[2\cdot 1\bmod 3])=(2,2)$</li>
<li>$f^{-1}(2,2)=2$</li>
</ol>
<p>$14\cdot 13\bmod 15=2\bmod 15$</p>
<h4 id="Example2"><a href="#Example2" class="headerlink" title="Example2"></a>Example2</h4><p>计算$11^{53}\bmod 15$</p>
<ol>
<li>$f(11)=([11\bmod 5],[11\bmod 3])=(1,2)$</li>
<li>$(1,2)^{53}=([1^{53}\bmod 5],[(-1)^{53}\bmod 3])=(1,2)$</li>
<li>$f^{-1}(1,2)=11$</li>
</ol>
<p>$1^{53}\bmod 15=11\bmod 15$</p>
<h4 id="Example3"><a href="#Example3" class="headerlink" title="Example3"></a>Example3</h4><p>我们很容易求$f(x)=([x\bmod p],[x\bmod q])$，但如何求逆？</p>
<p>$(x_p,x_q)=x_p\cdot(1,0)++x_q\cdot(0,1)=x_p\cdot f^{-1}(1,0)+x_q\cdot f^{-1}(0,1)$</p>
<p>问题转变为求$1_p=f^{-1}(1,0)$和$1_q=f^{-1}(0,1)$</p>
<p>我们找$X,Y$使$Xp+Yq=1$</p>
<p>$1_q=[X_p\bmod N],1_p=[Yq\bmod N]$</p>
<h1 id="一些难问题假设"><a href="#一些难问题假设" class="headerlink" title="一些难问题假设"></a>一些难问题假设</h1><h2 id="Factoring"><a href="#Factoring" class="headerlink" title="Factoring"></a>Factoring</h2><p>令$GenModulus$是一个多项式时间算法，输入为$1^n$，输出为$(N,p,q)$，其中$N=pq$，$p,q$是长度为$n$比特的素数。该算法以可忽略的概率失败。</p>
<p>定义以下实验$Factor_{\mathcal{A},GenModulus}(n)$：</p>
<ol>
<li>运行$GenModulus(1^n)$，得到$(N,p,q)$</li>
<li>$\mathcal{A}$获得$N$，并输出$p’,q’$</li>
<li>如果$N=p’\cdot q’$，实验结果为$1$，否则为$0$</li>
</ol>
<p>因数分解是困难的，我们有以下结论，对于任何PPT算法$\mathcal{A}$，都存在$negl$使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E8%AE%BA/1.png?raw=true" alt="1"></p>
<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><p>令$GenRSA$是一个多项式时间算法，输入为$1^n$，输出为$(N,e,d)$，其中$N$是两个长度为$n$比特的素数的乘积，并且$\gcd(e,\phi(N))=1,ed=1\bmod \phi(N)$。该算法以可忽略的概率失败。</p>
<p>定义以下实验$RSA-inv_{\mathcal{A},GenRSA}(n)$：</p>
<ol>
<li>运行$GenRSA(1^n)$，得到$(N,e,d)$</li>
<li>随机均匀选择$y\in\mathbb{Z}^*_N$</li>
<li>$\mathcal{A}$获得$N,e,y$，并输出$x\in\mathbb{Z}^*_N$</li>
<li>如果$x^e=y\bmod N$，实验结果为$1$，否则为$0$</li>
</ol>
<p>对于任何PPT算法$\mathcal{A}$，都存在$negl$使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E8%AE%BA/2.png?raw=true" alt="2"></p>
<h1 id="循环群中的密码学假设"><a href="#循环群中的密码学假设" class="headerlink" title="循环群中的密码学假设"></a>循环群中的密码学假设</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>令$\mathbb{G}$是一个阶为$m$的有限群，对于任意$g\in \mathbb{G}$，我们考虑以下集合：</p>
<script type="math/tex; mode=display">< g >=\{g_0,g_1,\cdots\}</script><p>根据之前的结论，我们有$g^m=1$，现在我们令$i$为最小的正整数使$g^i=1$，所以</p>
<script type="math/tex; mode=display">< g >=\{ g^0,g^1,\cdots,g^{i-1}\}</script><p>不难证明$&lt; g &gt;$是$\mathbb{G}$的子群。我们称$g$是$\mathbb{G}$的生成元(generator)。</p>
<p>我们定义在有限群$\mathbb{G}$中的一个元素$g$的阶是$i$，$g^i=1$。对于任意$g\in \mathbb{G}$，有$g^x=g^{[x\bmod i]}$。有以下推论：$g^x=g^y$当且仅当$x=y\bmod i$。</p>
<p>令$\mathbb{G}$是一个有限群，阶为$m$，如果存在一个元素$g\in\mathbb{G}$，使$&lt; g &gt; =\mathbb{G}$，则称$\mathbb{G}$是一个循环群(cyclic)，$g$称为该群的生成元$generator$。注意一个循环群可能有多个生成元。</p>
<p>令$\mathbb{G}$是一个有限群，阶为$m$，对于$g\in\mathbb{G}$，其阶为$i$，我们有$i\mid m$。</p>
<p>令$\mathbb{G}$是一个有限群，阶为$m$是一个质数，那么这是一个循环群，其中除了单位元之外的所有元素都是$\mathbb{G}$的生成元。</p>
<p>如果$p$是一个质数，那么$\mathbb{Z}_P^*$是一个阶为$p-1$的循环群。</p>
<h2 id="难问题假设"><a href="#难问题假设" class="headerlink" title="难问题假设"></a>难问题假设</h2><p>现在引入一些针对循环群的计算问题，这些问题被视为是难解的。</p>
<h3 id="The-discrete-logarithm-problem-and-assumption"><a href="#The-discrete-logarithm-problem-and-assumption" class="headerlink" title="The discrete-logarithm problem and assumption"></a>The discrete-logarithm problem and assumption</h3><p>离散对数问题是计算循环群中均匀选择的元素的离散对数，可以用以下实验来描述$DLog_{\mathcal{A},\mathcal{G}}$，其中$\mathcal{G}$是一个群生成算法：</p>
<ol>
<li>运行$\mathcal{G}(1^n)$，得到$(\mathbb{G},q,g)$，其中$\mathbb{G}$是一个循环群，阶为$q$是一个素数，$g$是$\mathbb{G}$的生成元</li>
<li>随机均匀选择$h\in \mathbb{G}$</li>
<li>$\mathcal{A}$获得$(\mathbb{G},q,g,h)$，并输出$x\in\mathbb{Z}_q$</li>
<li>如果$g^x=h$，则实验结果为1，否则为0</li>
</ol>
<p>这个问题目前被视为难问题，也就是说，对于任何PPT算法$\mathcal{A}$，都存在$negl$使：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E6%95%B0%E8%AE%BA/3.png?raw=true" alt="3"></p>
<h3 id="The-Diffie-Hellman-problems-and-assumptions"><a href="#The-Diffie-Hellman-problems-and-assumptions" class="headerlink" title="The Diffie-Hellman problems and assumptions"></a>The Diffie-Hellman problems and assumptions</h3><p>这包含两个问题：</p>
<ul>
<li>CDH problem：给定$g,g^x,g^y$，计算$g^{xy}$</li>
<li>DDH problem：给定$g,g^x,g^y,g^{xy}$，区别$g^{xy}$和任意选择的群中元素$g^z$</li>
</ul>
<p>目前这两个问题被视为难问题。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/12/16/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A1%AC%E6%A0%B8%E8%B0%93%E8%AF%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Gisyxi7">
      <meta itemprop="description" content="nju cs">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gisyxi7's blogs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/12/16/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A1%AC%E6%A0%B8%E8%B0%93%E8%AF%8D/" class="post-title-link" itemprop="url">【七】单向函数与硬核谓词</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-12-16 18:03:40" itemprop="dateCreated datePublished" datetime="2024-12-16T18:03:40+08:00">2024-12-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-12-24 01:01:54" itemprop="dateModified" datetime="2024-12-24T01:01:54+08:00">2024-12-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>对应<a target="_blank" rel="noopener" href="http://www.cs.umd.edu/~jkatz/imc.html">教材</a>第八章Theoretical Constructions of Symmetric-Key Primitives</p>
<p>我们已经引入了伪随机性的概念，并且定义了一些基础的密码学原语，包括伪随机生成器、伪随机函数和伪随机置换。在本章中，我们正式引入单向函数的概念——一种从非正式上讲“易于计算但难以反向计算”的函数——并展示如何在仅假设单向函数存在的情况下构造伪随机生成器、伪随机函数和伪随机置换。</p>
<h1 id="单向函数-One-Way-Functions"><a href="#单向函数-One-Way-Functions" class="headerlink" title="单向函数 One-Way Functions"></a>单向函数 One-Way Functions</h1><p>在本节中，我们将正式定义单向函数，并简要讨论一些被认为符合该定义的函数。接下来，我们引入硬核谓词（hard-core predicates）的概念，它可以被视为封装了单向函数反向计算的难度，并将在随后的构造中被广泛使用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单向函数$f$，是计算简单，但是难以反向计算的函数。</p>
<p>计算简单很容易形式化定义：即$f$是一个可以在多项式时间内计算的函数。</p>
<p>难以反向计算可以通过以下实验进行定义：<br>The inverting experiment $Invert_{\mathcal{A},f}(n)$</p>
<ol>
<li>均匀选取定义域中的x，并计算$f(x)$。</li>
<li>$\mathcal{A}$接受输入$1^n$和$y$，并输出$x’$。（这里$1^n$只是为了保证运行在关于安全参数n的多项式时间内）</li>
<li>若$y=f(x’)$，则实验结果为1，否则为0。</li>
</ol>
<p>注意，这里的实验并不要求必须满足$x=x’$，只要$y=f(x’)$即可。</p>
<p><strong>定义8.1</strong><br>$f$是一个单向函数，当且仅当满足以下两个条件：</p>
<ol>
<li>存在一个多项式时间算法$M_f$来计算$f$，使$M_f(x)=f(x)$。</li>
<li>对于任意多项式时间算法$\mathcal{A}$，都存在negl使<br>$Pr[Invert_{\mathcal{A},f}(n)=1]\leq negl(n)$</li>
</ol>
<p>条件2还可以用以下形式表示：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/1.png?raw=true" alt="1"></p>
<p>一个不是单向的函数并不意味着它在所有情况下（甚至“大多数情况下”）都容易求逆。</p>
<p>任何单向函数都可以通过指数时间的暴力搜索进行求逆。换句话说，这涉及一个原则上可以解决的问题，但假定它难以高效解决。</p>
<p>当一个函数始终满足$|f(x)|=|x|$时，我们称该函数为length-preserving的，如果在此基础上这个函数还是单射函数，那么称这个函数为one-way permutation的（单向置换）。</p>
<p>上述单向函数和置换的定义方便地考虑了一个在无限定义域和值域上的单一函数。然而，大多数候选单向函数和置换并不完全符合这一框架。相反，它们通常是通过某种算法生成一组参数。</p>
<p><strong>定义8.2</strong><br>$\prod=(Gen,Samp,f)$是一个概率多项式函数三元组，当其符合下面条件时被称为一个function family：</p>
<ol>
<li>Gen：输入$1^n$，输出参数$I$，其中$|I|\ge n$。每个$I$对应定义了集合$\mathcal{D}_I$和$\mathcal{R}_I$，分别是函数$f_I$的定义域和值域。</li>
<li>Samp：输入$I$，输出一个随机均匀分布的元素$x\in\mathcal{D}_I$。</li>
<li>f：一个确定性的算法，输入$I$和$x\in\mathcal{D}_I$，输出$y=f_I(x)\in\mathcal{R}_I$。</li>
</ol>
<p>当对于任意$I$，$\mathcal{D}_I=\mathcal{R}_I$且$f_I(x)$是双射时，我们称$\prod$是一个permutation family。</p>
<p>我们现在可以对应更改上述实验<br>The inverting experiment $Invert_{\mathcal{A},\prod}(n)$</p>
<ol>
<li>运行$Gen(1^n)$，并得到参数$I$。然后运行$Samp(I)$，并得到一个随机均匀分布的元素$x\in\mathcal{D}_I$。最后计算$y=f_I(x)$。</li>
<li>$\mathcal{A}$接受输入$I$和$y$，并输出$x’$。</li>
<li>若$y=f_I(x’)$，则实验结果为1，否则为0。</li>
</ol>
<p><strong>定义8.3</strong><br>一个function/permutation family $\prod$是one-way的，如果对对于任意多项式时间算法$\mathcal{A}$，都存在negl使<br>$Pr[Invert_{\mathcal{A},\prod}(n)=1]\leq negl(n)$</p>
<h2 id="潜在的单向函数"><a href="#潜在的单向函数" class="headerlink" title="潜在的单向函数"></a>潜在的单向函数</h2><h3 id="Candidate-1"><a href="#Candidate-1" class="headerlink" title="Candidate 1"></a>Candidate 1</h3><p>我们尚且不能无条件的证明单向函数的存在，所以我们目前必须假设他们的存在，这基于以下事实：一些被广泛研究的问题目前尚未能发现任何多项式时间算法能解决，比如大整数的质因数分解。这个问题难就难在<strong>将两个数相乘得到它们的积很容易，但给定一个数找到它的因数却非常困难</strong>。</p>
<p>这给了我们灵感，我们定义$f_{mult}(x,y)=x\cdot y$，限制x，y的定义域为等长的素数。</p>
<h3 id="Candidate-2"><a href="#Candidate-2" class="headerlink" title="Candidate 2"></a>Candidate 2</h3><p>这个单向函数的构造依赖于子集求和问题，其定义为<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/2.png?raw=true" alt="2"><br>其中$x_i$是一个n比特的字符串，解释为一个整数，$J$是一个n比特字符串，表示指定了子集$\{1,\cdots,n\}$的元素。</p>
<p>这个函数的逆函数是一个NP-complete问题。</p>
<h3 id="Candidate-3"><a href="#Candidate-3" class="headerlink" title="Candidate 3"></a>Candidate 3</h3><p>现在展示一个a family of permutations是单向的。其中Gen是一个概率多项式时间算法，输出一个n比特素数$p$，以及一个特殊元素$g\in \{2,\cdots,p-1\}$。Samp输出一个均匀分布的整数$x\in \{1,\cdots,p-1\}$。最后，定义$f_{p,g}(x)=g^x \bmod p$</p>
<p>可以证明这个函数是单射，因此是一个置换。反转这个函数的困难基于离散对数问题的假设。</p>
<h2 id="硬核谓词-Hard-core-Predicates"><a href="#硬核谓词-Hard-core-Predicates" class="headerlink" title="硬核谓词 Hard-core Predicates"></a>硬核谓词 Hard-core Predicates</h2><p>尽管根据定义单向函数很难反转，这并不意味着我们不能得到任何有用的信息。</p>
<p>举个例子，假设$g$是一个单向函数，我们定义<br>$f(x_1,x_2)=(x_1,g(x_2))$，其中$|x_1|=|x_2|$。<br>很容易证明$f$是一个单向函数，尽管泄露了一半的输入信息。</p>
<p>对于我们的应用，我们需要识别某些关于$x$的特定信息，但是这些信息被$f(x)$隐藏。这促使了<strong>硬核谓词</strong>的概念。</p>
<p><strong>定义8.4</strong><br>一个函数$hc:\{0,1\}^*\rightarrow\{0,1\}$是函数$f$的硬核谓词，当且仅当$hc$可以在多项式时间内计算，并且对于任何的多项式时间算法$\mathcal{A}$，都存在negl使<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/3.png?raw=true" alt="3"></p>
<p>注意，这里的硬核谓词是一个布尔值函数。同时，上述定义并不要求$f$是一个单向函数。但是如果$f$是一个置换函数，那么除非他是单向的，否则没有硬核谓词。</p>
<p>硬核谓词不能简单的构造，这里给出定理，对于任何固定的谓词$hc$，总存在一个单向函数，使这个谓词不是这个单向函数的硬核谓词。</p>
<p>当然，也存在简单的硬核谓词，比如，假设$f$是一个函数，其输出就是丢弃最后的一个比特。那么$hc(x)=x_n$就是$f$的一个硬核谓词。这里$f$是不是单向函数无关紧要。但是，这种简单的硬核谓词在我们后续的构造工作中是没有作用的。</p>
<h1 id="从单向函数到伪随机性"><a href="#从单向函数到伪随机性" class="headerlink" title="从单向函数到伪随机性"></a>从单向函数到伪随机性</h1><p>这节我们展示如何从单向函数构造伪随机生成器，伪随机函数和置换。</p>
<p>首先，我们说明任何是否任何一个单向函数都有一个硬核谓词，这仍然是一个开放性问题。我们可以展示一个弱一些的结论。</p>
<p><strong>定理8.5(Goldreich–Levin theorem)</strong><br>假设存在一个单向函数$f$，那么一定存在另一个单向函数$g$和$g$的硬核谓词$gl$。</p>
<p>我们可以通过以下方式进行构造：<br>令$g(x,r)=(f(x),r)$，其中$|x|=|r|$。<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/4.png?raw=true" alt="4"></p>
<p>下一步我们展示如何从一个单项置换的硬核谓词构造一个伪随机函数。</p>
<p><strong>定理8.6</strong><br>假设存在一个单向置换$f$，其硬核谓词为$hc$，那么我们可以构造以下的伪随机数生成器，其中expansion factor是$l(n)=n+1$。<br>$G(s)=f(s)||hc(s)$</p>
<p>直觉上看，因为输入是均匀的，所以置换后看起来也是均匀的，最后连接一个看起来是随机的$hc(s)$，所以整体上看起来是随机的。</p>
<p>当然，只能拓展一位的伪随机数生成器用处限制很大，但是幸运的是，我们可以获得任何多项式扩展因子的伪随机生成器。</p>
<p><strong>定理8.7</strong><br>如果存在一个expansion factor是$l(n)=n+1$的伪随机数生成器，那么对于任意的多项式$poly$，都存在expansion factor是l(n)=poly(n)$的伪随机数生成器。</p>
<p>因此，我们得出结论：可以从任何单向置换构造具有任意（多项式）扩展因子的伪随机生成器。</p>
<p>伪随机生成器对于构造 EAV 安全的私钥加密方案是足够的。然而，对于 CPA 安全的私钥加密（更不用说消息认证码了），我们依赖于伪随机函数。以下结果表明，后者可以从前者构造出来。</p>
<p><strong>定理8.8</strong><br>如果存在一个expansion factor是$l(n)=2n$的伪随机数生成器，则存在一个伪随机函数。</p>
<p><strong>定理8.9</strong><br>如果存在一个伪随机函数，则存在一个伪随机置换。</p>
<p>综合上述定理，我们发现，只要有单项置换函数，我们就可以构造出</p>
<ul>
<li>存在任意扩展因子的伪随机生成器、伪随机函数和强伪随机置换。</li>
<li>存在认证加密方案和安全的消息认证码。</li>
</ul>
<h1 id="来自单向函数的硬核谓词"><a href="#来自单向函数的硬核谓词" class="headerlink" title="来自单向函数的硬核谓词"></a>来自单向函数的硬核谓词</h1><p>我们在这一节证明<strong>定理8.5</strong>。<br>略</p>
<h1 id="构造伪随机数生成器"><a href="#构造伪随机数生成器" class="headerlink" title="构造伪随机数生成器"></a>构造伪随机数生成器</h1><p>我们首先展示如何在假设单向置换存在的情况下，构造将输入扩展一个比特的伪随机生成器。然后，我们再展示如何扩展这一构造，以获得任意多项式扩展因子。</p>
<h2 id="最小扩展因子的伪随机数生成器"><a href="#最小扩展因子的伪随机数生成器" class="headerlink" title="最小扩展因子的伪随机数生成器"></a>最小扩展因子的伪随机数生成器</h2><p><strong>定理8.18</strong><br>令$f$为一个单向置换，其硬核谓词为$hc$，那么我们可以构造以下的伪随机数生成器，其中expansion factor是$l(n)=n+1$。<br>$G(s)=f(s)||hc(s)$</p>
<p>证明如下：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/6.png?raw=true" alt="6"><br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/5.png?raw=true" alt="5"></p>
<h2 id="多项式扩展因子的伪随机数生成器"><a href="#多项式扩展因子的伪随机数生成器" class="headerlink" title="多项式扩展因子的伪随机数生成器"></a>多项式扩展因子的伪随机数生成器</h2><p>如果存在扩展因子为$n+1$的伪随机数生成器，那么存在任意多项式扩展因子的伪随机数生成器。</p>
<p>原理如下图：<br><img src="https://github.com/Gisyxi7/Hexo-Pics/blob/main/2412/%E5%8D%95%E5%90%91%E5%87%BD%E6%95%B0/7.png?raw=true" alt="7"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Gisyxi7</p>
  <div class="site-description" itemprop="description">nju cs</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gisyxi7</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
